### 读后感

读完这本书感觉android中好多的架构思想，设计思想都是参考计算机系统来进行开发的，比如Glide等图片加载框架的三级缓存原理，就是仿照计算机存储结构来进行开发的。网络编程中的套接字的真正含义等。cpu是如何管理进程，线程的，资源是如何分配的。我们所看到很多都是假像。并发并不是真正意义上的并发，时间碎片的抢占等。



### 第一章

编译系统分为4个阶段：



### 预处理器--->编译器--->汇编器--->链接器

1.预处理阶段：

将hello.c编译成hello.i

2.编译阶段：

将hello.i编译成hello.s

3.汇编阶段:

将hello.s编译成hello.o

4.链接阶段

将hello.o编译成可执行的hello程序



### 一个程序的执行流程

先从本地磁盘读取到主存中，然后从主存到处理器 ，然后处理完成之后复制到主存，再从主存复制到显示设备上。



### 进程

进程是操作系统对一个正在运行的程序的一种抽象，并发运行，并不是独立的使用硬件。 由内核对进程进行统一的调用。内核会常驻主存中。

### 上下文

操作系统保持跟踪进程运行所需的所有的所有状态信息，这种状态就是上下文。当操作系统决定要把控制权从当前进程切换到另一个进程的时候，就会进行上下文切换。即保存当前进程的上下文，恢复新进层的上下文，然后将控制权给新的进程，新锦成就会从它上次停止的位置开始。

### 虚拟内存

![image-20200601214554050](/Users/apple/Library/Application Support/typora-user-images/image-20200601214554050.png)





从下往上依次是：

1. 程序代码和数据

2. 堆

3. 共享库

4. 栈

5. 内核虚拟内存

### Amdahi定律

当我们对系统的某个部分加速是，其对系统整体性能的影响取决于该部分的重要性和加速程度。



## 8.1 异常

* 异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现。

### 8.1.1 异常处理

* 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。处理器中的示例包含被零除，缺页，内存访问违例，断点以及算术运算溢出。操作系统内核包括系统调用和来自外部I/O设备的信号。

* 方法是执行间接异常调用，有异常跳转表来作为中转站，当异常发生时，会去查找异常跳转表，然后根据当前异常号找到对应异常处理程序，

### 8.1.2 异常的类别

异常可以分为四类：中断，陷阱，故障和终止

## 8.2 进程

* 多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。

## 8.4 进程控制

* 父进程fork出来的子进程会共享父进程的一切资源，区别是两个进程会有不同的PID
* fork 函数调用一次，会返回两次结果，一次是在调用进程（父），一次是在新创建的子进程中。
* 相同但是独立的地址空间。
* 共享文件
* 进程终止之后，不会被内核立即清除，而是等待父进程进行回收，僵尸进程。如果子进程没有被父进程回收，父进程就已经销毁了，那么init进程成为养父。

 

### 第九章-笔记

虚拟内存提供了三个重要的能力：

* 他讲主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。

* 它为每个进程提供了一致的地址空间。从而简化了内存管理

* 它保护了每个进程的地址空间不被其他进程破坏。

##### 9.1 物理寻址，虚拟寻址

cpu直接通过物理地址从主存中读取数据，称为物理寻址

虚拟寻址，cpu通过生成一个虚拟地址，经过地址翻译成对应的物理地址来访问主存。

##### 9.3 虚拟内存作为缓存的工具

虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组



### 第十一章读书笔记

套接字接口是一组函数，他们和Unix I/O函数结合起来，用以创建网络应用。

* socket函数
* connect函数
* bind函数
* listen函数
* accept函数

### 第十二章 并发编程

#### 基于进程的并发编程

- 构造并发程序最简单的方法是用进程，比如fork,exec,waitpid

#### 基于I/O多路复用的并发

- 使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后才返回给应用程序
- 基于I/O多路复用的并发事件驱动服务器
- 优势
  1. 比基于进程的设计给了程序员更多的对于程序行为的控制
  2. 运行在单一进程上下文中，逻辑流之间共享数据变得容易，便于使用调试工具，不需要进程上下文切换，因此也是高效的
- 事件驱动设计的缺点是编码复杂，此外不能充分利用多核处理器

#### 基于线程的并发操作

- 基于线程的并发程序，它是进程和I/O多路复用的结合。线程是运行在进程中的逻辑流，由内核自动调度。每个线程都有自己的线程上下文（thred context），包括线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。内核通过一个整数ID来识别线程。多个线程运行在单一进程上下文中，因此共享进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库以及打开的文件。
- 线程执行模型
- Posix线程
- 终止线程
- 回收已终止的线程资源
- 分离线程
- 初始化线程
- 基于线程的并发服务器

#### 多线程程序中的共享变量

- 线程内存模型
- 将变量映射到内存
- 共享变量

#### 用信号量同步锁

- 进度图
- 信号量
- 使用信号量实现互斥
- 利用信号量调度共享资源
- 基于预线程化的的并发服务器



























