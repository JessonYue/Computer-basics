# 源程序

源程序就是0和1组成的比特序列, 8bit为一组, 称为字节, 每个字节表示程序中的某些文本字符.

ASCII
一个唯一的单字节大小的整数值来表示每个字符

程序是以字节序列的方式存储在文件中,文本以一个看不见的换行符来结束
系统中的所有信息都是有一串比特表示的, 区分不同数据对象的唯一方法是解析数据时的上下文

程序的生命周期

1. 高级C语言(以人的角度思考)
2. 翻译成机器语言
3. 按照特定格式打好包
4. 二进制磁盘文件形式存储

通过编译器驱动将c文件翻译成可执行目标文件

1. 预处理; (.c --> .i)

2. 编译器ccl(.i -> .s), 汇编语句,用文本的形式描述机器指令

3. 汇编器 as (.s->.o) .0是二进制文件

4. 链接器 ld (.o->可执行文件) 将标准函数的.o文件以特定方式合并到之前编译的.o文件中

> 汇编
> 将不同编译器的语言转为统一的汇编指令


为什么要了解编译系统的原理

- 优化性能
- 理解链接是出现的错误
- 避免安全漏洞

### shell

命令行解释器, 等待输入一个命令行, 如果该命令行的第一个单词不是内置的shell命令, 那么shell就会假设他是一个可执行文件,并加载运行

##硬件模型

1. 总线
   - 贯穿整个系统的电子官道, 用于携带信息字节并在各个部件间传递.
2. I/O 设备
   - I/O 是系统与外界沟通的桥梁
   - IO设备通过设备器或者控制器与IO总线相连,传递信息
3. 主存
   - 临时存储设备, 用于存放程序和程序处理的数据
   - 逻辑上来说,是一组线性的字节数组, 每个字节都有唯一的地址, 地址都是从零开始
4. 处理器
   - 解释存储在主存中的指令的引擎,其内部有一个存储设备(或者寄存器)指向主存中的指令地址
   - 处理器处理流程
        1. 加载,从主存中加载数据到寄存器,覆盖原内容
        2. 存储,从寄存器中赋值数据到主存,覆盖主存的内容
        3. 操作,将寄存器的内容复制到ALU做运算,并将结果写入到寄存器
        4. 跳转,重写程序计数器的值,让它指向下一条指令
   - 指令集架构
     - 描述的是每条机器代码指令的效果
   - 微体系结构
     - 描述处理器实际上是如何实现的
5. 寄存器 todo

### hello文件的执行过程

1. 启动shell,等待用户输入

2. 通过IO读取字符串到寄存器,再写入到内存

3. 执行hello文件,将文件从磁盘读入到内存

4. 执行hello中的main函数的机器指令

5. hello中的机器指令将文本从主存复制到寄存器,在从寄存器写入到显示器

***程序设计的主要目标之一就是减少复制操作的开销***

机械原理: 较大的存储设备要比较小的存储设备运行的慢

 1. 处理器从寄存器中读取信息的速度远远快于从主存读取

 2. 加快处理器的速度比加快主存速度要容易和便宜

 3. 高速缓存用于协调主存和处理器之间数据的读取差异, 处理器读取高速缓存几乎和读取寄存器一样快

 4. 程序员能利用高速缓存将程序的性能提高一个量级

> 存储器结构的主要思想: 上一层的存储器作为第一层存储器的高速缓存

### 进程

- 进程是操作系统对一个正在运行的程序的一种抽象;
- 并发则是指一个进程的指令和另一个进程的指令交错执行;
- 处理器通过进程切换时间交替执行指令
- 进程切换就是指: 处理器保存当前进程的上下文,恢复新进程的上下文,并传递控制权

### 线程

- 一个进程由多个线程组成
- 线程之间共享数据比进程之间要容易
- 线程比进程更高效
  
----

### Q&A

什么是文件?如果所有信息是以字节序列来存储,那么区分文件与内容的边界是什么?