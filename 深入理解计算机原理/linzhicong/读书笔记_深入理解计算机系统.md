#深入理解计算机系统

##本书总结和感悟
- 其实阅读这本书的主要目的，是要理解计算机系统的一些本质概念。哪些方面会影响到应用程序的正确性、性能和实用性。
- 读完了整本书后，对于计算机系统的整体认知有了一定的概念。特别是对一串代码，变成一个可执行文件的过程，有了更深入的理解。
- 刚开始读这本书的时候，过于在意一些细节的知识，导致读书的效率很慢。后来，慢慢地有目的地把一些不需要深入了解的知识点，给忽略掉，读书的效率慢慢地提了起来。
- 现在虽然读完了这本书，但是很多知识点都还只停留在很浅的理解，而且没能跟实际应用联系起来。而且也很容易忘记，还需要反复的回顾和阅读，才能让我们的理解根深蒂固

## 第二章
本章主要介绍了信息存储的格式及一些数据的运算。

### 信息存储
#### 十六进制表示法
二进制、十进制、十六进制的存储方式，以及相互之间的转换；

#### 寻址和字节顺序
&x   地址表达式
小端法：最低有效位在最前面
大端法：最高有效位在最前面

#### 位级运算
通过异或运算实现两个指针值交换：

	void inplace_swap(int *x, int *y) {
		*y = *x ^ *y;
		*x = *x ^ *y;
		*y = *x ^ *y;
	}

### 整数
#### 有符号和无符号之间的转换
保持位置不变，改变解释行为

### 浮点数
十进制浮点数转为二进制 -- 整数部分除以2取余数（反序），小数部分乘以2后取整数位（正序）

## 第三章
本章主要介绍了我们运行的程序代码，在底层是如何实现的；了解到了一些指令码，一些程序语句的实现原理，如：条件判断、指令跳转等；还有内存、寄存器的一些知识，对整个计算机指令的执行有了一些了解；

### 程序编码
执行：gcc -o p p.c 的过程

- 1、预处理：预处理器根据以#开头的命令，取读取系统头文件，然后插入到程序文本，得到 p.i；
- 2、编译：编译器将 p.i 翻译成 p.s，即转化为汇编语言；
- 3、汇编：汇编器将 p.s 翻译成机器语言指令，打包成一个 可重定向目标程序，保存到 p.o 文件中；
- 4、链接：把程序中用到的标准C库函数，合并到 p.o 中，得到 p 的可执行目标文件；

### 机器级代码
- 程序计数器PC：用 %rip 表示，给出将要执行的下一条指令在内存中的地址；
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。有的存储地址、有的用来记录某些重要的程序状态、有的保存临时数据；
- 条件码寄存器：保存最近执行的算数或逻辑指令的状态信息；
- 向量寄存器：可以存放一个或多个整数或浮点型数值；

程序内存（使用虚拟地址来寻址）包含：

- 程序可执行机器代码；
- 操作系统需要的一些信息；
- 用于管理过程调用和返回的运行时栈；
- 用户分配的内存块；

操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 访问信息
一个 x86-64 的CPU包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。不同的寄存器有不同的作用。
#### 操作数指示符
大多数指令有一个或多个操作数，操作数可以分为一下三个类型：

- 立即数：用来表示常数值，用 ‘$’ + 整数 表示，如：$0xFF；
- 寄存器：表示某个寄存器的内容；
- 内存引用：根据计算出来的有效地址去访问某个内存位置；
#### 数据传送指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

最简单形式的数据传输指令————MOV类，由四条指令组成：

- movb：1个字节
- movw：2个字节
- movl：4个字节
- movq：8个字节

它们执行的操作是一样的，只是操作的数据大小不一样。

指令示例：movw %bp, %sp ———— 这里为什么要用movw呢？

因为 movw 可操作2个字节的数据，而 %bp, %sp 都代表寄存器低位部分的两个字节。
#### 指令传送示例
C语言代码：

    long exchange(long *xp, long y) {
		long x = *xp;
		*xp = y;
		return x;
	}

汇编代码：

	long exchange(long *xp, long y)
	xp in %rdi, y in %rsi
	1	exchange:
	2		movq	(%rdi), %rax
	3		movq	%rsi, (%rdi)
	4		ret

xp保存在%rdi寄存器，y保存在%rsi寄存器；

指令2：从内存中直接读出x，即xp指向的内存位置，保存到%rax中，用于稍后返回，直接实现了操作long x = *xp；

指令3：将y写入到%rdi中xp指向的内存位置，直接实现了操作*xp = y；

### 算术和逻辑操作

- 加载有效地址：leaq 指令，实际上就是 movq 指令的变形；
- 一元和二元操作：先把源元素从寄存器或者内存位置中取出来，运算，把运算结果保存到目的寄存器或内存位置；
- 位移操作：通过位移量和要位移的数，进行算术和逻辑的左移或者右移；

### 控制

- 条件码：存放于一组单个位的条件码寄存器，用于描述最近的算术或逻辑操作的属性；

- 跳转指令 jmp .L2 ： 使用 jmp 指令来实现执行指令的顺序跳转

- 条件控制 goto 指令：通过 if 判断，通过后使用 goto 指令实现跳转

- 循环 实际上就是： 条件控制+跳转指令

	- do-while 循环
	
	loop:
		body-statement
		t = test-expt;
		if(t)
			goto loop;

	- while 循环

		goto test;
	loop:
		body-statement
	test:
		t = test-expt;
		if(t)
			goto loop;

	- for 循环
	
		init-expt;
		goto test;
	loop:
		body-statement;
		update-expt;
	test:
		t = test-expt;
		if(t)
			goto loop;

	- switch 语句 这个比较特殊一点，实现方式：
		- 1、先把可能跳转到的指令地址保存到一个数组（跳转表）中；
		- 2、然后通过条件控制，计算出 index ，通过 index 从数组中取到相应要执行的指令地址；

### 过程

- 运行时栈：在过程调用中需要用到栈这种数据结构，通过后进先出这种特性，实现了当前调用到的过程入栈，过程执行完了就出栈，然后接着执行上一个过程；
- 转移控制和数据传送
	- 控制转移：call 指令，指明被调用过程起始的指令地址。达到控制转移的效果；
	- 数据传送：一个过程调用另外一个过程的时候，需要传参时，则需要把需要的参数复制到特定的寄存器；当返回时，上一个过程也可以访问寄存器中的返回值；
- 栈上的局部存储：一般用于存放局部变量，想起了 JVM 中，局部变量也是存放于栈帧中，应该是同一个道理吧。
- 递归过程：其实递归跟循环一样，而且栈天生就是像为递归而打造的；况且我很过程的调用，其实也是一种递归的过程。

### 数组分配和访问

- 指针运算：其实指针运算跟数组运算基本一致，都是 起始地址+一个元素的size
- 数组
	- 嵌套数组：即二维数组；
	- 定长数组：有确定大小的数组；
	- 变长数组：需要通过给定的参数，去开辟相应的内存空间；

### 结构体和联合体

- 结构体：用 struct 表示，里面有定义个成员，每个成员都需要内存空间；
- 联合体：用 union 表示，可以定义多个成员，但只能存在一个成员实例；为了解决 struct 中内存占用过大问题，减少一些不必要的内存开销；

### 数据对齐

出现的原因：只要是为了提高计算机的访问效率；

## 第五章
这一章主要讲了一些可以提高编译器性能的途径和方法手段，以及其提高性能的原理。
### 提高编译器的性能
- 消除循环的低效率
如果循环中的判定条件是需要计算的，则可以先在循环外部计算出结果，在循环中使用过该结果；
- 减少过程调用：可以使用指针操作代替过程调用；
- 消除不必要的内存引用：对于在循环中需要不断的对内存进行读写操作的，可以使用局部变量代替，得出的最终结果再写进需要的内存中；
- 循环展开：通过增加每次迭代计算的元素的数量，减少循环的迭代次数；
- 提高并行性：
	- 多个累计变量：计算 n 个数的乘积，在一个循环中，可以变成求 n 为奇数的乘积，保存在 acc0 中，和 n 为偶数的乘积保存在 acc1 中，循环结束后，再求 acc0 和 acc1 的乘积；相当于使用了两次循环展开；
	- 重新结合变换：计算 n 个数的乘积，可以变成计算出 i 和 i+1 的乘积，再乘以 acc，把乘积保存到 acc 中；

## 第六章
这一章主要介绍了计算机系统中的存储技术和模型，整个从 CPU 到主存之间的结构。

- 存储技术：一些存储设备和存储技术的介绍，内存读写的流程；
- 局部性：局部性有两种不同的形式，分为时间局部性和空间局部性，怎么理解呢？
	- 时间局部性：一个内存位置，被多次调用；
	- 空间局部性：相邻的内存位置，被有序的调用；

	所以，有良好局部性的程序，比局部性差的程序，运行得更快。

- 存储器的层次结构：可以当成是一个三角形的结构，越靠近顶部，使用的内存越小，访问的速度也就越快；
### 高速缓存存储器
为了解决 CPU 读取主存速度慢的问题，在 CPU 和主存之间添加了高速缓存存储器，有三个，分别为 L1、L2、L3；占用内存从小到大，访问速度从快到慢。其中 L1 的访问速度几乎与访问寄存器的速度相等。

#### 直接映射高速缓存确定一个请求是否命中
直接映射高速缓存的每个组只有一行。

- 1、组选择：高速缓存从 w 的地址中间抽取 s 个组索引位，定位到某个组；
- 2、行匹配：从 w 中的标记与组中的标记进行对比；
- 3、字抽取：通过 w 中的 b 位，即块偏移，找到块中的起始地址；

如果不命中，则需要从下一层中去读取。

#### 组相联高速缓存确定一个请求是否命中
组相联高速缓存的每个组可以有多行；具体的读取请求与直接映射高速缓存基本一样。

#### 全相联高速缓存确定一个请求是否命中
全相联高速缓存中只有一个组，所以读取的时候，不需要判断组，只需要通过标记和块偏移来读取就好了。


## 第七章 链接
这一章主要介绍了链接的编译时链接和加载时链接所涉及到的理论知识和数据结构。

### 静态链接
为了构造可执行文件，链接器必须完成两个任务：

- 符号解析：目标文件定义和引用符号，每个符号对应一个函数、全局变量或静态变量。符号解析的作用就是将每个符号引用正好和一个符号定义关联起来；
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置；

### 目标文件

目标文件的三种形式：

- 1、可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，生成一个可执行目标文件；
- 2、可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行；
- 3、共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接；

### 可重定位目标文件
ELF可重定向目标文件的格式：

1、ELF头和节头部表；

2、夹在ELF头和节头部表之间的都是节，有：

- .text：已编译程序的机器代码
- .rodata：只读数据
- .data: 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在.data 节中，也不出现在 .bss 节中
- .bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0
- .symtab: —个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。 然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。
- .rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
- .rel.data: 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .line: 原始 C 源程序中的行号和.text 节中机器指令之间的映射。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .strtab: —个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的令名字。字符串表就是以 null 结尾的字符串的序列。

### 符号和符号表

符号表：每个可重定向目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。

在链接器的上下文中，有三种不同的符号：

- 全局符号：由模块 m 定义并能被其他模块引用。对应于非静态的C函数和全局变量；
- 外部符号：由其他模块定义并被模块 m 引用的全局符号。对应于其他模块定义的非静态的C函数和全局变量；
- 局部符号：只被模块 m 定义和引用。对应于带 static 属性的C函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用；

### 符号解析

#### 解析多重定义的全局符号
强弱符号的定义：

- 强符号：函数和已初始化的全局变量
- 弱符号：未初始化的全局变量

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：

- 1、不允许有多个同名的强符号
- 2、如果有一个强符号和多个弱符号同名，那么选择强符号
- 3、如果有多个弱符号同名，那么从中任意选择一个

#### 与静态库链接
静态库定义：将所有相关的目标模块打包成一个单独的文件，称为静态库。

为什么要使用静态库：
	
	因为使用静态库，在链接时，链接器只会复制被程序引用的目标模块，
	这就减少了可执行文件在磁盘和内存中的大小；
	另一方面，应用程序员只需要包含较少的库文件的名字。

#### 使用静态库来解析引用

链接器维护一个可重定位目标文件的集合 E(这个集合中的文件会被合并起来形成可执行文件）， 一个未解析的符号(即引用了但是尚未定义的符号)集合U,以及一个在前面输人文件中已定义的符号集合D, 初始时E、 U 和 D 均为空。

- 于命令行上的每个输人文件 f，链接器会判断 f是一个目标文件还是一个存档文件。如果 f是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映f中的符号定义和引用，并继续下一个输入文件
- 如果果是一个存档文件(.a)，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m 定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 中，并且链接器修改(U 和 D 来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U和 D都不再发生变化。此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。
- 果当链接器完成对命令行上输人文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

关于库的一般准则是将它们放在命令行的结尾，如果这些库的成员是相互独立的，这些库就可以以任意顺序放置；如果这些库不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号 S, 在命令行中至少有一个 S 的定义是在对 S 的引用之后的。

### 重定位
重定位由两步组成：

- 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节
- 重定位节中的符号引用：链接器将修改代码节和数据节中对每个符号的引用，是的它们指向正确的运行时地址

#### 重定位条目
**重定位条目定义**：无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在 .rel.data 中。

ELF 定义了 32 种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定位类型

- R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用
- R_X86_64_32：重定位一个使用 32 位绝对地址的引用

#### 重定位符号引用
- 重定位PC相对引用
- 重定位绝对引用

### 可执行目标文件
**可执行目标文件**的格式类似于可重定位目标文件的格式。除此之外，.init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。可执行文件是完全链接的（已被重定位），所以不需要 rel 节

### 加载可执行文件
**加载**：将程序复制到内存并运行的过程叫加载。

### 动态链接共享库
共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个内存中的程序链接起来，这个过程称为**动态链接**。是由一个叫做**动态链接器**的程序来执行的。**共享库**也称为共享目标，在Linux系统中通常用**.so**后缀来表示。

共享库是以两种不同的方式来“共享”的：

- 在任何给定的文件系统 中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中；
- 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享；

### 位置无关代码

多进程如何共享程序的一个副本？

- 一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库；这种方法会造成一些严重的问题，因为即使一个进程不使用这个库，那部分空间还是会被分配出来，并且它也难以管理。
- 另一种方法是使用位置无关代码（PIC），可以避免缺陷的发生


## 第八章 异常控制流
这一章主要介绍了异常的类别和处理，同时也介绍了进程、上下文、信号量的一些概念。


**异常控制流：**是系统通过使控制流发生突变来对这些情况做出反应。

### 异常
**异常**是异常控制流的一种形式，它一部分由硬件实现，一部分由软件实现。
#### 异常处理
- 在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得表木 k 包含异常 k 的处理程序的地址
- 在运行时，处理器检测的发送了一个事件，并且确定了相应的异常号 k，随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k 跳转到相应的处理程序的地址

异常类似与过程调用，但是有一些不同的地方。

#### 异常的类别
异常可以分为四类：中断、陷阱、故障和终止。

- 中断：异步发生的，是来自处理器外部的I/O设备的信号的结果
- 陷阱：有意的异常，是执行一条指令的结果
- 故障：由错误的情况引起，它可能能够被故障处理程序修正
- 终止：不可恢复的致命错误造成的结果

### 进程
#### 逻辑控制流
定义：调试器单步执行程序，由一系列的程序计数器（PC）的值，这些值唯一地对应与包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值得序列叫做**逻辑控制流**
#### 并发流
并发流：一个逻辑流得执行在时间上与另一个流重叠，称为**并发流**；

并发：多个流并发地执行称为**并发**；

多任务：一个进程和其他进程轮流运行称为**多任务**

时间片：一个进程执行它得控制流得一部分的每一时间段叫做**时间片**。因此，多任务也叫做**时间分片**。

#### 用户模式和内核模式

处理器通过用某个控制寄存器中的一个**模式位**来提供这种功能。

- 设置的模式位，进程就运行在内核模式
- 没有设置模式位，进程就运行在用户模式

#### 上下文切换

内核为每个进程维持一个**上下文**。上下文就是内核重新启动一个被抢占的进程所需的状态。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做**调度**。是由内核中称为**调度器**的代码处理的。

上下文切换：

- 1、保存当前进程的上下文
- 2、恢复某个先前被抢占的进程被保存的上下文
- 3、将控制传递给这个新恢复的进程

### 进程控制

- 获取进程id：getpid 函数返回调用进程的 PID。getppid 函数返回它父进程的 PID。
- 创建和终止：
	- 进程有三种状态：运行、停止和终止
	- fork 函数创建进程：会返回两次
	- exit 函数终止进程
- 回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。
- 让进程休眠：sleep 函数
- 加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序

### 信号
一个**信号**就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。
#### 信号术语
一个发出而没有被接收的信号叫做**待处理信号**。在任何时刻，一种类型至多只会有一个待处理信号。

一个待处理信号最多只能被接收一次。
#### 发送信号
- 进程组
- 用 /bin/kill 程序发送信号
- 键盘
- kill 函数
- alarm 函数

#### 接收信号
每个信号类型都有一个预定义的默认行为，是下面的一种：

- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）直到被 SIGCONT 信号重启
- 进程忽略该信号

#### 阻塞和解除阻塞信号
Linux 提供阻塞信号的隐式和显式的机制

- 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号
- 显式阻塞机制：应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号

#### 编写信号处理程序
- 处理程序要尽可能简单
- 在处理程序中只调用异步信号安全的函数
- 保存和恢复 errno
- 阻塞所有的信号，保护对共享全局数据结构的访问
- 用 volatile 声明全局变量
- 用 sig_atomic_t 声明标志

### 非本地跳转
通过 setjmp 和 longjmp 函数来提供非本地跳转


## 第九章 虚拟内存
这一章介绍了虚拟内存的由来及其的实际应用和原理。

为什么需要理解虚拟内存：

- 虚拟内存式核心
- 虚拟内存是强大的
- 虚拟内存是危险的

### 物理和虚拟寻址
计算机系统的主存被组织成一个有 M 个连续的字节大小的单元组成的数组。每个字节都有唯一的**物理地址**。CPU 使用物理地址访问内存，称为**物理寻址**。

现代处理器使用的是一种称为**虚拟寻址**，CPU 通过生成一个**虚拟地址**来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。

将一个虚拟地址转换为物理地址的任务叫做**地址翻译**。

### 地址空间
地址空间是一个非负整数地址的有序集合

### 虚拟内存作为缓存的工具
在任意时刻，虚拟页面的集合都分为三个不相交的子集：

- 未分配的：VM 系统还未分配的页
- 缓存的：当前已缓存在物理内存中的已分配页
- 未缓存的：未缓存在物理内存中的分配页

#### DRAM 缓存的组织结构
- SRAM 缓存：表示位于 CPU 和主存之间的 L1、L2 和 L3 高速缓存；
- DRAM 缓存：表示虚拟内存系统的缓存，它在主页中缓存虚拟页；

#### 页表
页表：将虚拟页映射到物理页。

#### 页命中
#### 缺页

### 地址翻译
当页面命中时，CPU 硬件执行的步骤：

- 处理器生成一个虚拟地址，并把它传给 MMU
- MMU 生成 PTE 地址，并从高速缓存/主存请求得到它
- 高速缓存/主存向MMU 返回 PTE
- MMU 构造物理地址，并把它传送给高速缓存/主存
- 高速缓存/主存返回所请求的数据给处理器

### 多级页表
多级页表的作用可以减少内存的消耗

### 内存映射
Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为**内存映射**。虚拟内存区域可以映射到两种类型的对象中：

- Linux 文件系统中的普通文件
- 匿名文件

### 动态内存分配
- 显式分配器：要求应用显式地释放任何已分配的快
- 隐式分配器：要求分配器检测一个分配快何时不再被程序所使用，那么就释放这个快

#### 为什么要使用动态内存分配
因为经常要直到程序实际运行时，才知道某些数据结构的大小。

#### 分配器的要求和目标
- 处理任意请求序列
- 立即响应请求
- 只使用堆
- 对齐块
- 不修改已分配的块

#### 碎片
- 内部碎片：在分配一个已分配块比有效载荷大时发生
- 外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生

#### 合并空闲块
当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空间块相邻。这些邻接的空闲块可能引起一种现象，叫做**假碎片**。

为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为**合并**。

### C 程序中常见的与内存有关的错误
- 间接引用坏指针
- 读未初始化的内存
- 允许栈缓冲区溢出
- 指针指向的对象时相同大小
- 造成错位错误
- 引用指针，而不是它所指向的对象
- 误解指针运算
- 引用不存在的变量
- 引用空闲堆块中的数据
- 引起内存泄漏


## 第十章 系统级 I/O
这一章节主要介绍了文件的相关操作。还有文件描述符的介绍和使用。

### 文件的类型
- 普通文件
- 目录
- 套接字

### 打开和关闭文件
使用 open 函数来打开一个文件。open 函数将 fileName 转换为一个文件描述符（fd）

### 共享文件
内核用三个相关的数据结构来表示打开文件：

- 描述符表：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向**文件表**中的一个表项
- 文件表：打开文件的集合是由一张文件表来表示的
- v-node 表：同文件表一样


## 第十一章 网络编程
这一章主要介绍了网络编程相关的，有经典的客户端服务端模式，IP 地址的结构，Socket 套接字的介绍，也使用到 fd 。

### 全球 IP 因特网
**TCP/IP** 实际是一个协议族，其中每个都提供不同的功能。

把因特网看做一个世界范围的主机集合，满足一下特性：

- 主机集合被映射为一组 32 未得 IP 地址
- 这组 IP 地址被映射为一组称为**因特网域名**的标识符
- 因特网主机上的进程能够通过**连接**和任意其他因特网主机上的进程通信

**IP 地址** 是一个 32 位无符号整数。

### 套接字

**套接字接口** 是一组函数，用以创建网络应用。

从 Linux 内核的角度看，一个**套接字**就是通信的一个端点。从 Linux 程序的角度看，**套接字**就是一个有相应描述符的打开文件。

网络连接用大的一些函数：

- socket 函数：客户端和服务器用于创建一个**套接字描述符**
- connect 函数：客户端用于建立和服务器的连接
- bind 函数：服务器用于和客户端建立连接
- listen 函数：服务器调用 listen 函数告诉内核，描述符是被服务器而不是客户端使用的，用于监听来自客户端的连接请求，被创建一次，并存在于服务器的整个生命周期
- accept 函数：服务器通过调用 accept 函数来等待来自客户端的连接请求。可以创建多次。


## 第十二章 并发编程
这一章介绍了并发编程的三种实现方式，及其优缺点。还有并发引起的一些问题，及其解决方式。还有线程的使用方式。
### 基于进程的并发编程
这种并发编程方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信（IPC）**机制。

优缺点：进程有独立的地址空间，这样一个进程不会把另外一个进程给覆盖了，这是优点；同样，这也是缺点，独立的地址空间使得进程间的信息共享变得困难，必须要使用显式的 IPC 来共享信息。

### 基于 I/O 多路复用的并发编程
在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。

书中使用 **select** 函数来实现：

- select 函数处理类型为 fd_set 的集合，也叫做描述符集合。将描述符集合看成一个大小为 n 的位向量：Bn-1,...,B1,B0 ；每个位 Bk 对应描述符 k 。只有当 Bk=1 ，描述符 k 才表明是描述符集合中的一个元素；
- select 函数会一直阻塞，直到有一个描述符准备可读时，select 才不会阻塞；
- select 返回时，使用 FD_ISSET 宏指令来确定哪个描述符可读
- 然后我们就得到一个文件描述符（fd）了；

优缺点：

- 优点：
	- 1、给程序员更多对程序的控制；
	- 2、运行单一的进程上下文，每个逻辑流都能访问进程的全部地址空间；
- 缺点：编码复杂；

### 基于线程的并发编程
线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用流一样共享同一个虚拟地址空间。

线程使用的一些函数：

- 创建线程：pthread_create ；
- 终止线程：pthread_exit 显式地终止； pthread_cancel 终止传入当前线程 id ；
- 回收线程：pthread_join 等待其他线程终止；
- 分离线程：pthread_detach 
- 初始化线程：pthread_once

### 多线程中的共享变量
多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：

- 全局变量：定义在函数之外的变量。任何线程都可以引用；
- 本地自动变量：定义在函数内部且没有 static 修饰。每个线程都有自己的本地变量实例；
- 本地静态变量：定义在函数内部且有 static 修饰。与全局变量一样；

### 信号量同步线程
共享变量是十分方便，但是它们也引入了**同步错误**（synchronization error)的可能性；

有个关键点：一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。

使用 P 和 V 的包装函数

#### 利用信号量来调度共享资源
- 生产者-消费者
- 读者-写者

### 多处理器提高线程并行性
同时执行的线程数与处理器数一样，每个线程运行时间最短，如果线程数再增加，会有上下文切换的时间开销，时间会相对多一点。

### 其他并发问题
#### 线程安全
线程不安全函数类：

- 不保护共享变量的函数
- 保持跨越多个调用的状态的函数
- 返回指向静态变量的指针的函数
- 调用线程不安全函数的函数

#### 可重入性
具有属性：当被多个线程调用时，不会引用任何共享数据

#### 竞争
当一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点时，就会发生**竞争**。

####死锁
指的是一个线程被阻塞了，等待一个永远也不会为真的条件。

##本书总结和感悟
- 其实阅读这本书的主要目的，是要理解计算机系统的一些本质概念。哪些方面会影响到应用程序的正确性、性能和实用性。
- 读完了整本书后，对于计算机系统的整体认知有了一定的概念。特别是对一串代码，变成一个可执行文件的过程，有了更深入的理解。
- 刚开始读这本书的时候，过于在意一些细节的知识，导致读书的效率很慢。后来，慢慢地有目的地把一些不需要深入了解的知识点，给忽略掉，读书的效率慢慢地提了起来。
- 现在虽然读完了这本书，但是很多知识点都还只停留在很浅的理解，而且没能跟实际应用联系起来。而且也很容易忘记，还需要反复的回顾和阅读，才能让我们的理解根深蒂固。