# 第七章 链接

## 1、静态链接
为了构造可执行文件，链接器必须完成两个任务：

- 符号解析：目标文件定义和引用符号，每个符号对应一个函数、全局变量或静态变量。符号解析的作用就是将每个符号引用正好和一个符号定义关联起来；
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置；

## 2、目标文件

目标文件的三种形式：

- 1、可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，生成一个可执行目标文件；
- 2、可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行；
- 3、共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接；

## 3、可重定位目标文件
ELF可重定向目标文件的格式：

1、ELF头和节头部表；

2、夹在ELF头和节头部表之间的都是节，有：

- .text：已编译程序的机器代码
- .rodata：只读数据
- .data: 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在.data 节中，也不出现在 .bss 节中
- .bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0
- .symtab: —个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。 然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。
- .rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
- .rel.data: 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .line: 原始 C 源程序中的行号和.text 节中机器指令之间的映射。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .strtab: —个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的令名字。字符串表就是以 null 结尾的字符串的序列。

## 4、符号和符号表

符号表：每个可重定向目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。

在链接器的上下文中，有三种不同的符号：

- 全局符号：由模块 m 定义并能被其他模块引用。对应于非静态的C函数和全局变量；
- 外部符号：由其他模块定义并被模块 m 引用的全局符号。对应于其他模块定义的非静态的C函数和全局变量；
- 局部符号：只被模块 m 定义和引用。对应于带 static 属性的C函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用；

## 5、符号解析

### 1、解析多重定义的全局符号
强弱符号的定义：

- 强符号：函数和已初始化的全局变量
- 弱符号：未初始化的全局变量

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：

- 1、不允许有多个同名的强符号
- 2、如果有一个强符号和多个弱符号同名，那么选择强符号
- 3、如果有多个弱符号同名，那么从中任意选择一个

### 2、与静态库链接
静态库定义：将所有相关的目标模块打包成一个单独的文件，称为静态库。

为什么要使用静态库：
	
	因为使用静态库，在链接时，链接器只会复制被程序引用的目标模块，
	这就减少了可执行文件在磁盘和内存中的大小；
	另一方面，应用程序员只需要包含较少的库文件的名字。

### 3、使用静态库来解析引用

链接器维护一个可重定位目标文件的集合 E(这个集合中的文件会被合并起来形成可执行文件）， 一个未解析的符号(即引用了但是尚未定义的符号)集合U,以及一个在前面输人文件中已定义的符号集合D, 初始时E、 U 和 D 均为空。

- 于命令行上的每个输人文件 f，链接器会判断 f是一个目标文件还是一个存档文件。如果 f是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映f中的符号定义和引用，并继续下一个输入文件
- 如果果是一个存档文件(.a)，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m 定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 中，并且链接器修改(U 和 D 来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U和 D都不再发生变化。此时，任何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。
- 果当链接器完成对命令行上输人文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

关于库的一般准则是将它们放在命令行的结尾，如果这些库的成员是相互独立的，这些库就可以以任意顺序放置；如果这些库不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号 S, 在命令行中至少有一个 S 的定义是在对 S 的引用之后的。

## 6、重定位
重定位由两步组成：

- 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节
- 重定位节中的符号引用：链接器将修改代码节和数据节中对每个符号的引用，是的它们指向正确的运行时地址

### 1、重定位条目
**重定位条目定义**：无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在 .rel.data 中。

ELF 定义了 32 种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定位类型

- R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用
- R_X86_64_32：重定位一个使用 32 位绝对地址的引用

### 2、重定位符号引用
- 重定位PC相对引用
- 重定位绝对引用

## 7、可执行目标文件
**可执行目标文件**的格式类似于可重定位目标文件的格式。除此之外，.init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。可执行文件是完全链接的（已被重定位），所以不需要 rel 节

## 8、加载可执行文件
**加载**：将程序复制到内存并运行的过程叫加载。

## 9、动态链接共享库
共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个内存中的程序链接起来，这个过程称为**动态链接**。是由一个叫做**动态链接器**的程序来执行的。**共享库**也称为共享目标，在Linux系统中通常用**.so**后缀来表示。

共享库是以两种不同的方式来“共享”的：

- 在任何给定的文件系统 中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中；
- 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享；

## 10、位置无关代码

多进程如何共享程序的一个副本？

- 一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库；这种方法会造成一些严重的问题，因为即使一个进程不使用这个库，那部分空间还是会被分配出来，并且它也难以管理。
- 另一种方法是使用位置无关代码（PIC），可以避免缺陷的发生

## 11、库打桩机制
- 编译时打桩
- 链接时打桩
- 运行时打桩