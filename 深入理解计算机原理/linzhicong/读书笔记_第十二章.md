# 第十二章 并发编程
## 1、基于进程的并发编程
这种并发编程方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信（IPC）**机制。

优缺点：进程有独立的地址空间，这样一个进程不会把另外一个进程给覆盖了，这是优点；同样，这也是缺点，独立的地址空间使得进程间的信息共享变得困难，必须要使用显式的 IPC 来共享信息。

## 2、基于 I/O 多路复用的并发编程
在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。

书中使用 **select** 函数来实现：

- select 函数处理类型为 fd_set 的集合，也叫做描述符集合。将描述符集合看成一个大小为 n 的位向量：Bn-1,...,B1,B0 ；每个位 Bk 对应描述符 k 。只有当 Bk=1 ，描述符 k 才表明是描述符集合中的一个元素；
- select 函数会一直阻塞，直到有一个描述符准备可读时，select 才不会阻塞；
- select 返回时，使用 FD_ISSET 宏指令来确定哪个描述符可读
- 然后我们就得到一个文件描述符（fd）了；

优缺点：

- 优点：
	- 1、给程序员更多对程序的控制；
	- 2、运行单一的进程上下文，每个逻辑流都能访问进程的全部地址空间；
- 缺点：编码复杂；

## 3、基于线程的并发编程
线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用流一样共享同一个虚拟地址空间。

线程使用的一些函数：

- 创建线程：pthread_create ；
- 终止线程：pthread_exit 显式地终止； pthread_cancel 终止传入当前线程 id ；
- 回收线程：pthread_join 等待其他线程终止；
- 分离线程：pthread_detach 
- 初始化线程：pthread_once

## 4、多线程中的共享变量
多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：

- 全局变量：定义在函数之外的变量。任何线程都可以引用；
- 本地自动变量：定义在函数内部且没有 static 修饰。每个线程都有自己的本地变量实例；
- 本地静态变量：定义在函数内部且有 static 修饰。与全局变量一样；

## 5、信号量同步线程
共享变量是十分方便，但是它们也引入了**同步错误**（synchronization error)的可能性；

有个关键点：一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。

使用 P 和 V 的包装函数

#### 利用信号量来调度共享资源
- 生产者-消费者
- 读者-写者

## 6、多处理器提高线程并行性
同时执行的线程数与处理器数一样，每个线程运行时间最短，如果线程数再增加，会有上下文切换的时间开销，时间会相对多一点。

## 7、其他并发问题
### 7.1 线程安全
线程不安全函数类：

- 不保护共享变量的函数
- 保持跨越多个调用的状态的函数
- 返回指向静态变量的指针的函数
- 调用线程不安全函数的函数

### 7.2 可重入性
具有属性：当被多个线程调用时，不会引用任何共享数据

### 7.4 竞争
当一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点时，就会发生**竞争**。

### 7.5 死锁
指的是一个线程被阻塞了，等待一个永远也不会为真的条件。