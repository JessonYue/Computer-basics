# 第八章 异常控制流
**异常控制流：**是系统通过使控制流发生突变来对这些情况做出反应。
## 1、异常
**异常**是异常控制流的一种形式，它一部分由硬件实现，一部分由软件实现。
### 1.1、异常处理
- 在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得表木 k 包含异常 k 的处理程序的地址
- 在运行时，处理器检测的发送了一个事件，并且确定了相应的异常号 k，随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k 跳转到相应的处理程序的地址

异常类似与过程调用，但是有一些不同的地方。

### 1.2、异常的类别
异常可以分为四类：中断、陷阱、故障和终止。

- 中断：异步发生的，是来自处理器外部的I/O设备的信号的结果
- 陷阱：有意的异常，是执行一条指令的结果
- 故障：由错误的情况引起，它可能能够被故障处理程序修正
- 终止：不可恢复的致命错误造成的结果

## 2、进程
### 2.1 逻辑控制流
定义：调试器单步执行程序，由一系列的程序计数器（PC）的值，这些值唯一地对应与包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值得序列叫做**逻辑控制流**
### 2.2 并发流
并发流：一个逻辑流得执行在时间上与另一个流重叠，称为**并发流**；

并发：多个流并发地执行称为**并发**；

多任务：一个进程和其他进程轮流运行称为**多任务**

时间片：一个进程执行它得控制流得一部分的每一时间段叫做**时间片**。因此，多任务也叫做**时间分片**。

### 2.3 私有地址空间
### 2.4 用户模式和内核模式

处理器通过用某个控制寄存器中的一个**模式位**来提供这种功能。

- 设置的模式位，进程就运行在内核模式
- 没有设置模式位，进程就运行在用户模式

### 2.5 上下文切换

内核为每个进程维持一个**上下文**。上下文就是内核重新启动一个被抢占的进程所需的状态。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做**调度**。是由内核中称为**调度器**的代码处理的。

上下文切换：

- 1、保存当前进程的上下文
- 2、恢复某个先前被抢占的进程被保存的上下文
- 3、将控制传递给这个新恢复的进程

## 3、系统调用错误处理
使用错误处理包装函数

## 4、进程控制

- 获取进程id：getpid 函数返回调用进程的 PID。getppid 函数返回它父进程的 PID。
- 创建和终止：
	- 进程有三种状态：运行、停止和终止
	- fork 函数创建进程：会返回两次
	- exit 函数终止进程
- 回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。
- 让进程休眠：sleep 函数
- 加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序

## 5、信号
一个**信号**就是一条小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。
### 5.1 信号术语
一个发出而没有被接收的信号叫做**待处理信号**。在任何时刻，一种类型至多只会有一个待处理信号。

一个待处理信号最多只能被接收一次。
### 5.2 发送信号
- 进程组
- 用 /bin/kill 程序发送信号
- 键盘
- kill 函数
- alarm 函数

### 5.3 接收信号
每个信号类型都有一个预定义的默认行为，是下面的一种：

- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）直到被 SIGCONT 信号重启
- 进程忽略该信号

### 5.4 阻塞和解除阻塞信号
Linux 提供阻塞信号的隐式和显式的机制

- 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号
- 显式阻塞机制：应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号

### 5.5 编写信号处理程序
- 处理程序要尽可能简单
- 在处理程序中只调用异步信号安全的函数
- 保存和恢复 errno
- 阻塞所有的信号，保护对共享全局数据结构的访问
- 用 volatile 声明全局变量
- 用 sig_atomic_t 声明标志

## 5、非本地跳转
通过 setjmp 和 longjmp 函数来提供非本地跳转

## 问题
1、子进程的回收，为什么系统要定义为让父进程进行回收？