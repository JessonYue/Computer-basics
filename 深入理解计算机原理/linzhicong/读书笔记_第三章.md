# 第三章

##3.2 程序编码
执行：gcc -o p p.c

- 1、预处理：预处理器根据以#开头的命令，取读取系统头文件，然后插入到程序文本，得到 p.i；
- 2、编译：编译器将 p.i 翻译成 p.s，即转化为汇编语言；
- 3、汇编：汇编器将 p.s 翻译成机器语言指令，打包成一个 可重定向目标程序，保存到 p.o 文件中；
- 4、链接：把程序中用到的标准C库函数，合并到 p.o 中，得到 p 的可执行目标文件；

###3.2.1 机器级代码
- 程序计数器PC：用 %rip 表示，给出将要执行的下一条指令在内存中的地址；
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。有的存储地址、有的用来记录某些重要的程序状态、有的保存临时数据；
- 条件码寄存器：保存最近执行的算数或逻辑指令的状态信息；
- 向量寄存器：可以存放一个或多个整数或浮点型数值；

程序内存（使用虚拟地址来寻址）包含：

- 程序可执行机器代码；
- 操作系统需要的一些信息；
- 用于管理过程调用和返回的运行时栈；
- 用户分配的内存块；

操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

##3.3 数据格式
大多数GCC生成的汇编代码都有一个字符的后缀，表明操作数的大小。

##3.4 访问信息
一个 x86-64 的CPU包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。不同的寄存器有不同的作用。
###3.4.1 操作数指示符
大多数指令有一个或多个操作数，操作数可以分为一下三个类型：

- 立即数：用来表示常数值，用 ‘$’ + 整数 表示，如：$0xFF；
- 寄存器：表示某个寄存器的内容；
- 内存引用：根据计算出来的有效地址去访问某个内存位置；
###3.4.2 数据传送指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。

最简单形式的数据传输指令————MOV类，由四条指令组成：

- movb：1个字节
- movw：2个字节
- movl：4个字节
- movq：8个字节

它们执行的操作是一样的，只是操作的数据大小不一样。

指令示例：movw %bp, %sp ———— 这里为什么要用movw呢？

因为 movw 可操作2个字节的数据，而 %bp, %sp 都代表寄存器低位部分的两个字节。
###3.4.3 指令传送示例
C语言代码：

    long exchange(long *xp, long y) {
		long x = *xp;
		*xp = y;
		return x;
	}

汇编代码：

	long exchange(long *xp, long y)
	xp in %rdi, y in %rsi
	1	exchange:
	2		movq	(%rdi), %rax
	3		movq	%rsi, (%rdi)
	4		ret

xp保存在%rdi寄存器，y保存在%rsi寄存器；

指令2：从内存中直接读出x，即xp指向的内存位置，保存到%rax中，用于稍后返回，直接实现了操作long x = *xp；

指令3：将y写入到%rdi中xp指向的内存位置，直接实现了操作*xp = y；

##3.5 算术和逻辑操作

- 加载有效地址：leaq 指令，实际上就是 movq 指令的变形；
- 一元和二元操作：先把源元素从寄存器或者内存位置中取出来，运算，把运算结果保存到目的寄存器或内存位置；
- 位移操作：通过位移量和要位移的数，进行算术和逻辑的左移或者右移；

## 3.6 控制

### 条件码

条件码：存放于一组单个位的条件码寄存器，用于描述最近的算术或逻辑操作的属性；

### 跳转指令

jmp .L2 ： 使用 jmp 指令来实现执行指令的顺序跳转

### 条件控制

goto 指令：通过 if 判断，通过后使用 goto 指令实现跳转

### 循环

实际上就是： 条件控制+跳转指令

#### do-while 循环
	loop:
		body-statement
		t = test-expt;
		if(t)
			goto loop;

#### while 循环
		goto test;
	loop:
		body-statement
	test:
		t = test-expt;
		if(t)
			goto loop;

#### for 循环
		init-expt;
		goto test;
	loop:
		body-statement;
		update-expt;
	test:
		t = test-expt;
		if(t)
			goto loop;

#### switch 语句

这个比较特殊一点，实现方式：

- 1、先把可能跳转到的指令地址保存到一个数组（跳转表）中；
- 2、然后通过条件控制，计算出 index ，通过 index 从数组中取到相应要执行的指令地址；

## 3.7 过程

### 运行时栈

在过程调用中需要用到栈这种数据结构，通过后进先出这种特性，实现了当前调用到的过程入栈，过程执行完了就出栈，然后接着执行上一个过程；

### 转移控制和数据传送

- 控制转移：call 指令，指明被调用过程起始的指令地址。达到控制转移的效果；
- 数据传送：一个过程调用另外一个过程的时候，需要传参时，则需要把需要的参数复制到特定的寄存器；当返回时，上一个过程也可以访问寄存器中的返回值；

### 栈上的局部存储

一般用于存放局部变量，想起了 JVM 中，局部变量也是存放于栈帧中，应该是同一个道理吧。

### 递归过程

其实递归跟循环一样，而且栈天生就是像为递归而打造的；况且我很过程的调用，其实也是一种递归的过程。

## 3.8 数组分配和访问

### 指针运算

其实指针运算跟数组运算基本一致，都是 起始地址+一个元素的size

### 数组

- 嵌套数组：即二维数组；
- 定长数组：有确定大小的数组；
- 变长数组：需要通过给定的参数，去开辟相应的内存空间；

## 3.9 异质的数据结构

### 结构体和联合体

- 结构体：用 struct 表示，里面有定义个成员，每个成员都需要内存空间；
- 联合体：用 union 表示，可以定义多个成员，但只能存在一个成员实例；为了解决 struct 中内存占用过大问题，减少一些不必要的内存开销；

### 数据对其

出现的原因：只要是为了提高计算机的访问效率；

## 总结
本章主要介绍了我们运行的程序代码，在底层是如何实现的；了解到了一些指令码，一些程序语句的实现原理，如：条件判断、指令跳转等；还有内存、寄存器的一些知识，对整个计算机指令的执行有了一些了解；