## 深入理解计算机系统第一周总结

### 第一章 计算机系统漫游

​	系统中的所有的信息-包括磁盘文件,内存中的程序,内存中存放的用户数据以及网络上传送的数据，都是有一串比特表示的，区分不同数据对象的唯一方法是我们读到这些数据对象的上下文。

​	系统的硬件组成：总线，I/O设备，主存，处理器。

​    运行hello.c程序:

​     ![image-20200606232649588](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606232649588.png)

 结合硬件的运行方式:

![image-20200606232904996](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606232904996.png)



![image-20200606233006430](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606233006430.png)

![image-20200606233024900](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606233024900.png)

 	处理器从寄存器文件中读取数据要比主存中快几乎100倍，随着技术的发展甚至更多，所以针对这种差异，系统的设计者采用了更小更快的存储设备（高速缓存存储器），作为暂时的集结区域。采用L1和L2这种静态随机访问存储器（SRAM）的硬件技术实现，几乎可以像访问寄存器文件一样，但是容量更高。

寄存器位置图：

  ![image-20200606234028007](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606234028007.png)

进程，线程介绍的相对简单，后面的章节继续跟进。

虚拟内存地址空间从上到下：程序代码和数据->运行时堆->共享库的内存映射区域->用户栈(运行时创建)->内核虚拟空间。

文件就是字节序列。

Amdahl定律(可以计算提升某一部分性能所带来的效果定律)。



### 第二章：程序结构和执行

​	计算机中最小可寻址单元：byte(字节，块)。         

​	机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)；内存中的每一个字节都由一个唯一 的数字来标识，被称为地址(address);所有可能地址的集合被称为虚拟地址空间(virtual address space)

  多字节对象的存储在内存中大多数都是按照顺序来进行存储的，而存储的方法也分为两种：以最低有效字节为最前面的有效字节的方式，即小端法(little endian), 和以最高有效字节为最前面的有效字节的方式，即大端法   (big endian)。     

​	大多数的Intel兼容机都只支持小端法，而大多数的IBM和Oracle(从2010收购Sun公司开始)默认是大端法。  

​	Android和IOS只支持小端法。当然这个不取决于公司和系统，而是取决于处理器。     

​	存储方法的影响：1.网络通信时，解决方式是应用程序在发送的时候必须遵循网络标准，而接收方按照网络标准来改   为内部数据。      2.阅读表示整数数据的字节序列时。通常发生于检查机器级程序的时候，可以通过反汇编器来解决。      3.当编写规避正常的类型系统的程序时。在C语言中可以使用强制类型转换(cast)和联合(union)来允许以一种数据   类型引用一个对象。(大多数应用编程强烈不推荐这种技巧，但是对于系统级编程却很有用，甚至是必须的。)   逻辑符号，对于右移来说，存在着逻辑右移和算术右移两种情况，针对有符号的情况，大多是使用的是算术右移

![img](https://upload-images.jianshu.io/upload_images/19936678-4d37d1f448c6094d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	如果无符号运算出现 a +b  = x 且 a > x，则说明运算溢出。因为溢出的操作是截断操作，即截取到当前最高位。

​	时钟周期：CPU最小的工作周期。

​	计算机执行的整数运算实际上是一种模运算形式，表示数字的有限长度限制了可能的取值范围，结果运算可能溢出。

​	补码表示提供了一种既能表示附属也能表示正数的灵活方法，同时使用了与执行无符号算数相同的位级实现。

​	浮点表示通过将数字编码为x*2^y的形式来近似的表示实数。浮点运算只有有限的范围和精度，而且不遵守普遍的算数属性，比如结合性。

### 第三章: 程序的机器级表示

​	![image-20200607003408357](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003408357.png)

​	

​	大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

![image-20200607003703978](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003703978.png)

​	

​	栈指针%rsp，用来指明运行时栈的结束位置，有些程序会明确的读写这个寄存器。

![image-20200607003914673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003914673.png)

​		常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的地址.movbsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的地址。

​	因为程序的运行时在运行时栈中进行，所以有压入和弹出栈数据的指令、

![image-20200607004508362](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004508362.png)

​		

![image-20200607004626368](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004626368.png)

​		

![image-20200607004859406](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004859406.png)

![image-20200607004914278](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004914278.png)

​		rep和repz的用处:在AMD系统上运行时，因为不能正确预测ret指令的目的，所以rep指令其实是空操作来作为跳转目的插入。综上，除了这个能让代码在AMD运行更快点之外，对代码不会有影响，可以无视这两个指令。

(截止到第三章第九节完成)

--------------------------------------------------------------------------------------------------------------------------------------------

