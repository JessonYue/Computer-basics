第二部分 在系统上运行

第七章 链接：

链接器使得分离编译成为可能，这样可以把程序模块化，从而使程序开发的时候可以分工更加明确，细化。这应该就是第一章里面编译里面的最后一步，把当前编译的文件和头文件里面的内容连接起来。

链接器的上下文中有三类不同的符号：由本模块定义并能被其它模块引用的全局符号，对应本模块的非静态的C函数和全局变量；有其他模块定义的并被本模块引用的全局符号，对应其他模块的非静态的C函数和全局变量；只被本模块定义和引用的局部符号，他们对应带有static属性的C函数和全局变量。(C 中的static对应java中的private public之类的关键字)

/code/link/elfstructs.c

打桩的操作是，假定一个目标函数，创建一个包装函数(与目标函数的原型相同)，再通过打桩的机制欺骗系统使用包装函数，这样包装函数就可以调用目标函数，并把值返回给调用者。

被编译的位置无关代码的共享库可以加载到任何地方，也可以运行时被多个进程共享。为了加载链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。

动态链接器将可执行文件的内容映射到内存并执行这个程序。

链接器可以生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的为解析的引用。

在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。



第八章 异常控制流：

异常返回之后的三种处理方式(即在exception handler【即异常处理程序】对照完exception table之后)：1.处理程序将控制返回给当前指令，即事件发生时正在执行的指令。2.处理程序将控制返回给下一个指令，如果没有异常将开始执行下一条指令。3.处理程序终止被中断的程序。





