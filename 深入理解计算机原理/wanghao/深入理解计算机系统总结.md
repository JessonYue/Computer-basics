## 深入理解计算机系统总结

### 第一章 计算机系统漫游

​	系统中的所有的信息-包括磁盘文件,内存中的程序,内存中存放的用户数据以及网络上传送的数据，都是有一串比特表示的，区分不同数据对象的唯一方法是我们读到这些数据对象的上下文。

​	系统的硬件组成：总线，I/O设备，主存，处理器。

​    运行hello.c程序:

​     ![image-20200606232649588](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606232649588.png)

 结合硬件的运行方式:

![image-20200606232904996](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606232904996.png)



![image-20200606233006430](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606233006430.png)

![image-20200606233024900](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606233024900.png)

 	处理器从寄存器文件中读取数据要比主存中快几乎100倍，随着技术的发展甚至更多，所以针对这种差异，系统的设计者采用了更小更快的存储设备（高速缓存存储器），作为暂时的集结区域。采用L1和L2这种静态随机访问存储器（SRAM）的硬件技术实现，几乎可以像访问寄存器文件一样，但是容量更高。

寄存器位置图：

  ![image-20200606234028007](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200606234028007.png)

进程，线程介绍的相对简单，后面的章节继续跟进。

虚拟内存地址空间从上到下：程序代码和数据->运行时堆->共享库的内存映射区域->用户栈(运行时创建)->内核虚拟空间。

文件就是字节序列。

Amdahl定律(可以计算提升某一部分性能所带来的效果定律)。



### 第二章：程序结构和执行

​	计算机中最小可寻址单元：byte(字节，块)。         

​	机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)；内存中的每一个字节都由一个唯一 的数字来标识，被称为地址(address);所有可能地址的集合被称为虚拟地址空间(virtual address space)

  多字节对象的存储在内存中大多数都是按照顺序来进行存储的，而存储的方法也分为两种：以最低有效字节为最前面的有效字节的方式，即小端法(little endian), 和以最高有效字节为最前面的有效字节的方式，即大端法   (big endian)。     

​	大多数的Intel兼容机都只支持小端法，而大多数的IBM和Oracle(从2010收购Sun公司开始)默认是大端法。  

​	Android和IOS只支持小端法。当然这个不取决于公司和系统，而是取决于处理器。     

​	存储方法的影响：1.网络通信时，解决方式是应用程序在发送的时候必须遵循网络标准，而接收方按照网络标准来改   为内部数据。      2.阅读表示整数数据的字节序列时。通常发生于检查机器级程序的时候，可以通过反汇编器来解决。      3.当编写规避正常的类型系统的程序时。在C语言中可以使用强制类型转换(cast)和联合(union)来允许以一种数据   类型引用一个对象。(大多数应用编程强烈不推荐这种技巧，但是对于系统级编程却很有用，甚至是必须的。)   逻辑符号，对于右移来说，存在着逻辑右移和算术右移两种情况，针对有符号的情况，大多是使用的是算术右移

![img](https://upload-images.jianshu.io/upload_images/19936678-4d37d1f448c6094d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

​	如果无符号运算出现 a +b  = x 且 a > x，则说明运算溢出。因为溢出的操作是截断操作，即截取到当前最高位。

​	时钟周期：CPU最小的工作周期。

​	计算机执行的整数运算实际上是一种模运算形式，表示数字的有限长度限制了可能的取值范围，结果运算可能溢出。

​	补码表示提供了一种既能表示附属也能表示正数的灵活方法，同时使用了与执行无符号算数相同的位级实现。

​	浮点表示通过将数字编码为x*2^y的形式来近似的表示实数。浮点运算只有有限的范围和精度，而且不遵守普遍的算数属性，比如结合性。

### 第三章: 程序的机器级表示

​	![image-20200607003408357](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003408357.png)

​	

​	大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

![image-20200607003703978](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003703978.png)

​	

​	栈指针%rsp，用来指明运行时栈的结束位置，有些程序会明确的读写这个寄存器。

![image-20200607003914673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607003914673.png)

​		常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的地址.movbsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的地址。

​	因为程序的运行时在运行时栈中进行，所以有压入和弹出栈数据的指令、

![image-20200607004508362](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004508362.png)

​		

![image-20200607004626368](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004626368.png)

​		

![image-20200607004859406](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004859406.png)

![image-20200607004914278](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200607004914278.png)

​		rep和repz的用处:在AMD系统上运行时，因为不能正确预测ret指令的目的，所以rep指令其实是空操作来作为跳转目的插入。综上，除了这个能让代码在AMD运行更快点之外，对代码不会有影响，可以无视这两个指令。

第四章：处理器体系结构

ISA:指令及体系结构，在处理器行为和如何实现处理器之间提供了一层抽象。\

ISA提供了程序执行的一种顺序说明，也就是一条指令执行结束，下一条才能开始。

从lA32指令开始，简化了类型， 地址模式和指令编码，定义了Y86-64指令集，得到的ISA既有RISC指令集属性，也有CISC指令集的属性。

第五章  优化程序性能：

 1.向量的抽象数据类型：向量由头信息加上指定长度的数组来表示

2.CPE:每元素的周期数，一种表示程序性能并指导我们改进代码的方式。

3.优化的方式：1)编译器优化，类似于GCC中的 -o1,-o2参数

​                          2)消除循环的低效率

​                          3)减少调用过程

​					      4)减少不必要的引用



第二部分 在系统上运行

第七章 链接：

链接器使得分离编译成为可能，这样可以把程序模块化，从而使程序开发的时候可以分工更加明确，细化。这应该就是第一章里面编译里面的最后一步，把当前编译的文件和头文件里面的内容连接起来。

链接器的上下文中有三类不同的符号：由本模块定义并能被其它模块引用的全局符号，对应本模块的非静态的C函数和全局变量；有其他模块定义的并被本模块引用的全局符号，对应其他模块的非静态的C函数和全局变量；只被本模块定义和引用的局部符号，他们对应带有static属性的C函数和全局变量。(C 中的static对应java中的private public之类的关键字)

/code/link/elfstructs.c

打桩的操作是，假定一个目标函数，创建一个包装函数(与目标函数的原型相同)，再通过打桩的机制欺骗系统使用包装函数，这样包装函数就可以调用目标函数，并把值返回给调用者。

被编译的位置无关代码的共享库可以加载到任何地方，也可以运行时被多个进程共享。为了加载链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。

动态链接器将可执行文件的内容映射到内存并执行这个程序。

链接器可以生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的为解析的引用。

在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。



第八章 异常控制流：

异常返回之后的三种处理方式(即在exception handler【即异常处理程序】对照完exception table之后)：1.处理程序将控制返回给当前指令，即事件发生时正在执行的指令。2.处理程序将控制返回给下一个指令，如果没有异常将开始执行下一条指令。3.处理程序终止被中断的程序。



第九章 虚拟内存

地址空间是一个非负整数地址的有序集合，如果地址空间的整数是连续的，则是一个线性地址空间。

虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。

虚拟页面的集合被分为三个不相交的子集：未分配的：虚拟内存系统中未分配的页；缓存的：当前已缓存在物理内存的已分配的页；未缓存的：未缓存在物理内存的已分配的页

虚拟内存是对主存的一个抽象。

现代系统通过将虚拟内存片和磁盘上的文件片关联起来，来初始化虚拟内存片，这个过程叫内存映射。



第十章 系统级I/O

输入/输出（I/O）是在主存和外部设备（磁盘驱动器、终端、网络）之间复制数据的过程。输入操作是从I/O设备复制数据到主存，输出操作使从主存复制数据到I/O设备。



每个Linux文件都有一个类型来表明它在系统中的角色:    普通文件包含任意数据: 应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII和Unicode字符的普通文件。二进制文件时所有的其他文件，对内核系统而言，文本文件和二进制文件没有区别;  目录 :是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录;  套接字:是用来与另一个进程进行跨网络通信的文件.

RIO提供了两种不同的函数：无缓冲的输入输出函数和有缓冲的输入输出函数。

I/O重定向允许用户将磁盘文件和标准输入输出联系在一起(dup2函数)

Unix I/O比标准 I/O 更适合网络编程。



第十一章 网络编程：

客户端-服务端模型中的基本操作是事务。

客户端-服务器模型中的基本操作是事务，一个客户端-服务器的事务由以下四步组成

1. 当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。例如，当web浏览器需要一个文件时，它就发送一个请求给web服务器
2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当web服务器收到web浏览器发的请求后，它就读一个磁盘文件
3. 服务器给客户端发送一个响应，并等待下一个请求。例如，web服务器将文件发送回客户端
4. 客户端收到响应并处理它。例如，当web浏览器收到来自服务器的一页后，就在屏幕上显示此页。

![image-20200620180008595](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfywr8gn3gj314608ywmr.jpg)



![image-20200620193336156](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyzgi4vfmj316c0lkh45.jpg)

第十二章 并发编程：

并发编程的三种方式：进程，I/O多路复用，线程。

![image-20200620210930778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz289y2ugj30me0dkqcu.jpg)



线程安全

线程不安全函数类：不保护共享变量的函数，保持多个跨越调用的状态的函数， 返回指向静态变量的指针的函数 ，调用线程不安全函数的函数。



![image-20200620211935040](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2iqt00cj310m0fik2o.jpg)



信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁，它指的是一组线程被阻塞了，等待一个永远也不会为真的条件。

![image-20200620212137487](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2kwfkkoj31100s0e35.jpg)



给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。.

![image-20200620213637816](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz30hkht0j30ye0nqarx.jpg)

一个并发程序是由在时间上重叠的一组逻辑组成的。

进程和线程都是由内核自由调度的。



--------------------------------------------------------------------------------------------------------------------------------------------

