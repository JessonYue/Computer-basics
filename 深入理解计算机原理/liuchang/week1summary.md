本周总结

在本周，主要遵从路哥建议开始阅读深入理解计算机系统一书。

由于头四天阅读的是英文版，发现文中出现了少许阅读困难的地方，造成阅读速度缓慢，头四天只完成前三章节的阅读，但是，在阅读中发现有比较多的公式和定义，由于自身知识的不牢固，造成了多次反复查阅资料，而造成折返跑的现象。

体现出来的问题：

1、对第二章的知识 包括位、有符号、无符号、信息储存等基础概念，理解不够透彻

2、对于补码编码，计算不够熟练

而进入第三章后，阅读速度略有提升，设计到一些类代码的知识，并结合相应的日志示例理解起来简单许多，并且出现问题较少。

再通过路哥讲解阅读重点后，我也在调整阅读重心，每章节采取偏重形式进行阅读，并在第四章转为阅读中文文档。

而前5天的算法题，难度不算大，只有第二天借助了leetcode 的解题思路，进行解题，后面逐步改进提交习题的质量，并将算法思路进行描述。

后面逐步会考虑 时间复杂度和空间复杂度，并逐步提出优化方案。

第一章知识点：

GCC编译器编译的编译阶段

GCC编译器 将源文件编译成可执行文件 主要分为四个阶段：

1、预处理器（cpp）：根据#开头的命令，修改原始的C程序

2、编译器（ccl）：将.i 文件 编译以为一个包含汇编语言程序的 .s 文件

3、汇编器（as）：将 .s 文件 编译成为 机器语言

4、链接器（ld）：将 某些预编译文件 进行合并

进程概念：一种操作程序对于正在运行的程序的抽象描述，但实际上，其实这只是看上去的表象，而实际上，是可以多个进程运行，在单核情况下，某一时刻只有一个进程可以运行。

线程概念：是线程中的一个单元，一个进程可以有多个线程单元，并且一个进程的每个线程都持有该进程的上下文，并共享一个进程内的全局资源。

虚拟内存区块分布

1、代码与数据：可直接执行的目标文件的内容进行初始化的，代码是从统一固定位置开始，紧接着是C全局变量对应的数据位置。

2、堆

3、共享库：存放一个公用的库的位置

4、栈

5、内核虚拟内存

并行与并发

并发：指一个程序具有同时多个活动

并行：指利用并发是程序执行的更快

第二章知识点：

指针的描述：

指针是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也是有两个方面，：值和类型。他的值表示某个对象的位置，而他的类型表示那个位置上所存储对象的类型。

C语言中的typedef声明提供了一种给数据类型命名的方式。例如：typedef int *int_ponter。

C语言中字符串被编码为一个以null字符结尾的字符数组。

基本编码，成为Unicode的“统一字符集”，使用32位来表示字符。

不同的机器类型使用不同的且不兼容的指令和编码方式。所以即使在完全一样的进程下，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。

计算机系统的一个基本概念就是，从机器角度来看，程序仅仅是字节序列。

C语言支持整数类型的有符号和无符号运算。同时也允许无符号和有符号之间的转换。

非规格化数的两个用途：

1、在规格化数，我们必须M>=1 ,所以我们就无法表示0，而非规格化数，为我们提供了一个表示数值0的方法

2、当数值分布均匀的接近于0.0的时候，非规格化值提供了一种属性被称为逐渐溢出

特殊值 无穷 当指阶码全部为1时，小数域全为0，s为0时为正无穷 ，s为1时为负无穷。

C浮点数特性：

 1、从 int 转换成 float ，数字不会溢出，但是可能被舍入。

2、从 int 或 float 转换成 double ，因为 double 有更大的范围，也有更高精度，所以能保留个精确的数值

3、从 double 转换成 float ，因为范围要小一些， 所以值可能会溢出成为 正负无穷，

4、从 float 或 double 转换成 int ，值会被四舍五入。

本章思考

1、读完全篇并没有明白有符号数到无符号数的隐式转化会造成什么问题？

2、无符号算数到底是干什么用的呢？想不明白

3、感觉看了一堆公式没有总结出什么来

第三章知识点：

GCC C语言编译以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。

GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。

高级语言编写的程序可以在多个不同机器上编译和执行，而汇编代码则是与特定机器密切相关的。

®能够阅读和理解汇编代码对于程序猿仍是一种很重要的技能。

第一部分 历史观点

Inter 处理器系列俗称 x86 ，经过了一个长期的、不断进化的发展过程。

摩尔定律：在一个固定周期内，计算机的的多个方面中，某一个方面呈现翻倍增长的的现象。此定律对业内任何公司适用。

第二部分 程序编程

编译选择 -Og 告诉编译器适用会生成符合原始 C 代码正题结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系难以理解。

扩充知识：GCC版本 4.8 引入了优化等级。在此之前的版本和非GUN编译器 并无法识别这个选项。但是 对于某些编译器使用优化效果会更好。

优化过程：

1、C 预处理器扩展源代码，插入 include 命令指定的文件，并扩展所有用 include 生命过的宏。

2、编译器将产生源文件的汇编代码。

3、汇编器将汇编代码转换成为二进制代码文件。

4、链接器将目标代码文件与实现库函数代码合并，并产生可执行文件。

一、机器级代码

机器级代码 两种抽象方式：

1、指令集体系结构或 指令集架构：它定义了 处理器状态、指令格式和指令对处理器状态的影响。

2、虚拟内存：看上去是一个很大的数组。

在编译过程中，编译器会将抽象的的对象转化为计算机可执行的的基本指令。

C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码知识见的的将内存看作一个很大的，按字节寻址的数组。

程序内存包含：程序的可执行机器代码，操作系统需要的信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。

关键点：一条指令只执行一个基本的操作。

不同GCC产生的代码也是不相同的。

根据示例 产生一些特性：

1、常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。

2、设计指令个的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。

3、反汇编器只是基于机器代码文件中的自己序列来确定汇编代码。

4、反汇编器使用的指令命令规则与 GCC 生成的汇编代码使用的有些细微的差别。

程序员使用汇编代码来访问机器的低级特性：

1、用汇编代码编写整个程序

2、利用GCC支持，直接在C程序中嵌入汇编代码

C 程序与汇编代码结合方式：

1、编写完整函数放入一个独立汇编文件，让汇编器和链接器把所有代码合并起来。

2、使用内联汇编特性。

操作数可以被分为三类：

1、立即数：用来表示常数值

2、寄存器：用来寄存某个寄存内容

3、内存引用：根据地址访问内存位置

CPU在整数寄存器外，还维护了一组单个位的条件码寄存器，他们用于描述算数或逻辑属性，可以用来执行条件分支指令。

在原有顺序下不按照原有顺序，执行一个全新的位置。跳转标示符号（label）。

跳转指令会先对地址进行确认，在确认好了跳转目标在进行弹出指令，从而进行跳转。

跳转：

跳转指令可以根据反编译发现 在指令符 后面 会有相应跳转地址，而地址后面 会指明跳转的目标，同样根据目标也是可以计算出最终跳转的地址。

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，按照满足的路径执行，反之，则执行不满足的路径。

处理器通过使用流水线来获取高性能，在流水线中，一条指令的处理需要经过一系列操作，每个阶段执行所需操作的一部分。这种方法通过重叠连续指令的步骤来获得高性能。

处理器采用精密的分支预测逻辑来猜测分支去向。

源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

同条件跳转不同，处理器不用预测测试的结果就可以执行条件传送。

不是所有条件表达式都可以用条件传送来编译。无论测试结果如何，我们给出的抽象代码会对then-expr和 else-expr都求值。

条件数据传送提供了一种用条件控制转移来实现操作的替代侧裂。他们只能用于受限制的情况，但这些情况还是相当常见，而且与现代处理器的运行方式更加契合

循环

C语言提供了多种循环结构，包括do-while、while和for

do-while

通用式：

do

​    body-statement

​    while（test-expr）

如果求值的结果为非零，就继续循环，在do-while 情况下 ，循环至少会被执行一次。

while

通用式：

while（test-expr）

​    body-statement

对值进行判断，如果不符合条件，则不会进入 body-statement，反之，则会进入循环体。

在编译器使用了 guarded-do 的翻译方法，在 jle指令的作用下 初始值不成立的情况下，将忽略循环代码。此处可以得出结论 编译语言在控制结构上不一定与根据翻译规则翻译的代码一致。

for

通用式：

for（init-expr; test-expo; update-expr）{

​	body-statement

}

Switch 该语句可以格局一个整数索引值进行多重分支。通过使用跳转表这种数据结构使得实现更加高效。

使用局部存储的情况包括：

1、寄存器不足够存放所有的本地数据。

2、对一个局部变量使用地址运算符‘&’，因此必须能够为他产生一个地址。

3、某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

结构：用关键字struct来声明，将多个对象集合到一个单位中

联合：用关键字union来声明，允许用几个不同类型来引用一个对象

指针的关键原则：

1、每个指针都对应一个类型。

2、每个指针都有一个值。

3、指针用‘&’运算符创建。

4、* 操作符用于间接引用指针。

5、数组与指针紧密联系。

6、将指针从一种类型强制转换成另一种类型，只是改变了他的类型，但是他的值并不会被改变。

7、指针也可以指向函数。

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到其上，包括：

1、对浮点数据操作的指令。

2、使用传递和返回规则。

3、保存到寄存器的规则。

GCC 会使用两种指令之一，即用vmovaps 传送单精度数，或者 用 vmovapd 传送双精度。

XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值，规律如下：

1、XMM寄存器%xmm0～%xmm7 最多可以传递8个浮点参数，按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。

2、函数使用寄存器%xmm0来返回浮点值。

3、所有的 XMM 寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

小结：

第一章：主要学习计算机在硬件与系统之间交互的知识，通过描述，了解到在外接设别输入与输出过程，并了解到系统与硬件内部的交互过程。

第二章：主要学习，系统内数据存储过程中，所使用到的计算方法，并了解系统内部数据存储、位运算和信息存储过程。

第三章：主要学习到在计算机中，常规的数据格式，并根据格式来对数据进行访问，同时，了解到程序中一些基础控制、过程、分配和访问，并将各个操作在系统中日志所代表的意义学习到。同时根据反编译内容了解到每个操作符和指令在系统中的形式和行为。

第一次总结 感觉 总结的不是很好 后面会优化这方面。