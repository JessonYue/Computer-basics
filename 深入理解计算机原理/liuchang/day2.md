第二章 信息的表示和处理

C++编程语言是建立在C语言基础之上，他们使用完全相同的数字表示和算法。

Java 创造了一种新的数字表示和算法。

大多数计算机使用8位的块或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。

机器级程序将内存是为一个非常大的字节数组，成为虚拟内存。内存中每个自己都由一个唯一数字来标示，成为地址。

指针的描述：

指针是C语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也是有两个方面，：值和类型。他的值表示某个对象的位置，而他的类型表示那个位置上所存储对象的类型。

尽管“char”是由于它被用来存储文本串中的单个字符这一事实而得名，但是它也能被用来存储数值。

字节顺序会造成的问题，首先在不同类型的机器之间通过网络传输二进制数据时，一个常见的问题时党小端法机器产生的数据被发送到大端的机器时，接收程序会发现，字里的字节成了反序的。

第二种情况，当阅读表示整数数据的字节序列时字节数序也是很重要的，但是这回造成什么问题呢？

第三种情况是当编写规避正常的类型系统的程序时，在C语言中，可以通过使用强制类型转换或联合来允许一种数据类型引用一个对象，而这种数据类型与创建这个对象时定的数据类型不同。

C语言中的typedef声明提供了一种给数据类型命名的方式。例如：typedef int *int_ponter。

C语言中字符串被编码为一个以null字符结尾的字符数组。

基本编码，成为Unicode的“统一字符集”，使用32位来表示字符。

不同的机器类型使用不同的且不兼容的指令和编码方式。所以即使在完全一样的进程下，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。

计算机系统的一个基本概念就是，从机器角度来看，程序仅仅是字节序列。

C语言支持整数类型的有符号和无符号运算。同时也允许无符号和有符号之间的转换。

整数运算

补码加法：超过给定范围，需要准确的表示，需要将扩大位，通过江表示截断相应的位，来避免数据无止境的扩张。

![image-20200603113356372](/Users/liuchang/Library/Application Support/typora-user-images/image-20200603113356372.png)

补码的非：任何数值的负数作为加法的逆，两者相加等于0。

乘法要比其他运算花费更多时间周期，计算机优化使用位移来替代乘法。当k表示需要左移的位数。

整数除法比整数乘法还要慢很多时间周期。同样适用位移替换除法。k表示需要右移的位数。

看完整数运算感觉还是很懵，主要是没有get到他讲述的无符号运算是什么，感觉自己只是知道，这些运算都涉及到了位。

浮点数 对于执行非常大的数字、非常接近于0（｜V|<<1)的数字，以及获取更接近运算的近似值。

二进制小数：小数点左边的数字的权是2的正幂，得到整数值，而小数点右边的数字的权是2的负幂，得到小数值。

小数点左边的数字的权是10的正幂，得到整数值，而小数点右边的数字的权是10的负幂，得到小数值。

非规格化数的两个用途：

1、在规格化数，我们必须M>=1 ,所以我们就无法表示0，而非规格化数，为我们提供了一个表示数值0的方法

2、当数值分布均匀的接近于0.0的时候，非规格化值提供了一种属性被称为逐渐溢出

特殊值 无穷 当指阶码全部为1时，小数域全为0，s为0时为正无穷 ，s为1时为负无穷。

C浮点数特性：

 1、从 int 转换成 float ，数字不会溢出，但是可能被舍入。

2、从 int 或 float 转换成 double ，因为 double 有更大的范围，也有更高精度，所以能保留个精确的数值

3、从 double 转换成 float ，因为范围要小一些， 所以值可能会溢出成为 正负无穷，

4、从 float 或 double 转换成 int ，值会被四舍五入。



小结：

计算机将信息编码为位（byte），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同约定。

大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754 编码。

在相同长度的无符号和有符号整数之间进行强制类型转化时，大多数C语言实现遵循的原则是底层的位模式不变。

由于编码的长度有限，与传统整数和实数想运算相比，计算机运算具有非常不同的属性。

思考

1、读完全篇并没有明白有符号数到无符号数的隐式转化会造成什么问题？

2、无符号算数到底是干什么用的呢？想不明白

3、感觉看了一堆公式没有总结出什么来