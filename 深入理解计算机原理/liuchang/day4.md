程序的机器级表示(下) 第6部分-第10部分

六、控制

（1）条件码

CPU在整数寄存器外，还维护了一组单个位的条件码寄存器，他们用于描述算数或逻辑属性，可以用来执行条件分支指令。

最常见的条件码：

1、CF：进位标志

2、ZF：零标志

3、SF：符号标志

4、OF：溢出标志

（2）访问条件码

1、根据条件码的某种组

2、根据条件跳转部分

3、有条件的进行传送数据

![image-20200604190358506](/Users/liuchang/Library/Application Support/typora-user-images/image-20200604190358506.png)

注意 其实可以发现 在 有符号 和无符号 的标示之间存在差别，说明在对于两种植的处理是存在差别的。在内部 是有不用的条件码组合表示，在外部 有可能会有不同的指令进行处理。

（3）跳转指令

在原有顺序下不按照原有顺序，执行一个全新的位置。跳转标示符号（label）。

跳转指令会先对地址进行确认，在确认好了跳转目标在进行弹出指令，从而进行跳转。

（4）跳转指令的编码

跳转指令可以根据反编译发现 在指令符 后面 会有相应跳转地址，而地址后面 会指明跳转的目标，同样根据目标也是可以计算出最终跳转的地址。

（5）用条件控制来是极限条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

（6）用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，按照满足的路径执行，反之，则执行不满足的路径。

处理器通过使用流水线来获取高性能，在流水线中，一条指令的处理需要经过一系列操作，每个阶段执行所需操作的一部分。这种方法通过重叠连续指令的步骤来获得高性能。

处理器采用精密的分支预测逻辑来猜测分支去向。

源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。

同条件跳转不同，处理器不用预测测试的结果就可以执行条件传送。

不是所有条件表达式都可以用条件传送来编译。无论测试结果如何，我们给出的抽象代码会对then-expr和 else-expr都求值。

条件数据传送提供了一种用条件控制转移来实现操作的替代侧裂。他们只能用于受限制的情况，但这些情况还是相当常见，而且与现代处理器的运行方式更加契合

（7）循环

C语言提供了多种循环结构，包括do-while、while和for

do-while

通用式：

do

​    body-statement

​    while（test-expr）

如果求值的结果为非零，就继续循环，在do-while 情况下 ，循环至少会被执行一次。

while

通用式：

while（test-expr）

​    body-statement

对值进行判断，如果不符合条件，则不会进入 body-statement，反之，则会进入循环体。

在编译器使用了 guarded-do 的翻译方法，在 jle指令的作用下 初始值不成立的情况下，将忽略循环代码。此处可以得出结论 编译语言在控制结构上不一定与根据翻译规则翻译的代码一致。

for

通用式：

for（init-expr; test-expo; update-expr）{

​	body-statement

}

Switch 该语句可以格局一个整数索引值进行多重分支。通过使用跳转表这种数据结构使得实现更加高效。

不同代码块（C 标号 loc_A到 loc_D和 loc_def）实现了 switch 语句的不同分支。

七、过程

过程时软件中一种很重要的抽象，它提供了一种封装代码方式，用一组指定的参数和一个可选的返回值实现了某种功能，并且，可以在程序中不同的地方调用这个函数。

不同编程语言中，过程的形式多样：函数（function）、方法（method）、子例程（subroutine）、处理函数（handler）等等，但是他们有一些共有的特性。

（1）运行时栈

过程调用机制遵循先进后出的原则。

为了提高空间和时间效率，x86-64 过程只分配字节所需要的栈帧部分。

（2）数据传送

当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程dialing还可能暴扣吧数据作为参数传递，而从过程返回还有可能包括返回一个只。

（3）栈上的局部存储

使用局部存储的情况包括：

1、寄存器不足够存放所有的本地数据。

2、对一个局部变量使用地址运算符‘&’，因此必须能够为他产生一个地址。

3、某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

（4）寄存器中局部存储空间

在给定时刻只有一个过程是活动的，但是我们仍需要确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后回使用的积存值。x86-64采用了一组统一的寄存器使用管理。

（5）递归过程

寄存器和栈的惯例是的x86-64过程能够递归调用自身。

栈规则提供了一种机制，每次函数调用都有自己私有的状态信息存储空间，而且它还可以提供局部变量的村中。

八、数组分配和访问

（1）基本原则：

char a[12];

char *b[8];

int c[6];

double *d[5];

![image-20200605230906892](/Users/liuchang/Library/Application Support/typora-user-images/image-20200605230906892.png)

b和d 都是指针数组，因此每个数组元素都是8个字节。

（2）指针运算

根据运算计算出的值回格局改置针应用的数据类型的大小进行伸缩。

（3）嵌套的数组

要访问多维数组的元素，编译器会以数组起始的基地址，偏移量作为索引，产生计算预期的元素的偏移量，然后使用某种MOV指令。

计算式为：T D[R] [C]；

元素地址为：&D[i] [j]= Xd+L(C·i+i);

（4）变长数组

需要使用malloc 或 calloc 这样的函数为这些数组非配存储空间，而不得不显式编码，用行优先索引将多维数组应到一维数组。

九、异质的数据结构

结构：用关键字struct来声明，将多个对象集合到一个单位中

联合：用关键字union来声明，允许用几个不同类型来引用一个对象

（1）结构

声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。

将所有的存放部分放入一段连续的区域，根据首字节的地址就是指针指向的位置。

（2）联合

允许以多种类型来引用一个对象。用不同的字段来引用相同的内存块。

（3）数据对齐

对齐限制简化了形成处理器和内存系统之间借口的硬件设计。

![image-20200605234625570](/Users/liuchang/Library/Application Support/typora-user-images/image-20200605234625570.png)

根据上表，确保没中数据类型都是按照指定值的倍数进行组织和分配。

十、在机器级程序中将控制与数据结合起来

（1）理解指针

什么是指针？以一种统一的方式，对不同数据结构中的元素产生引用。

指针的关键原则：

1、每个指针都对应一个类型。

2、每个指针都有一个值。

3、指针用‘&’运算符创建。

4、* 操作符用于间接引用指针。

5、数组与指针紧密联系。

6、将指针从一种类型强制转换成另一种类型，只是改变了他的类型，但是他的值并不会被改变。

7、指针也可以指向函数。

（2）使用GDB调试器

![image-20200606000414884](/Users/liuchang/Library/Application Support/typora-user-images/image-20200606000414884.png)



