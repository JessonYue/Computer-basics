程序的机器级表示(下) 第11部分-第12部分

十一、浮点代码

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到其上，包括：

1、对浮点数据操作的指令。

2、使用传递和返回规则。

3、保存到寄存器的规则。

媒体指令开始包括那些对标量浮点数据进行操作的指令，使用XMM 或YMM寄存器的低32位或64位中的单个值。

每个 YMM 寄存器 都是256位（32字节）。当需要对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于float）或64位（对于double）。

（1）浮点传送和转换操作

引用内存的指令时标量指令，意味着他们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中，要么保存在XMM寄存器中。

指令表![image-20200606203636040](/Users/liuchang/Library/Application Support/typora-user-images/image-20200606203636040.png)

GCC 会使用两种指令之一，即用vmovaps 传送单精度数，或者 用 vmovapd 传送双精度。

指令名字的字母‘a’表示“aligned（对齐）”。

转化用指令集：

![image-20200606204207775](/Users/liuchang/Library/Application Support/typora-user-images/image-20200606204207775.png)

vunpcklps 指令通常用来交叉防止来自两个 XMM 寄存器的值，把它们存储到第三个寄存器中。

fcvt 的所有参数都是通过通用寄存器传递的，因为它们既不是整数也不是指针。

（2）过程中的浮点代码

XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值，规律如下：

1、XMM寄存器%xmm0～%xmm7 最多可以传递8个浮点参数，按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。

2、函数使用寄存器%xmm0来返回浮点值。

3、所有的 XMM 寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

（3）浮点运算操作

精度指令表

![image-20200606210841766](/Users/liuchang/Library/Application Support/typora-user-images/image-20200606210841766.png)

（4）定义和使用浮点常数

和整除运算操作不同，AVX 浮点操作不能以立即树脂作为操作数。

（5）对浮点代码的观察结论

AVX2 有能力在封装好的数据上执行并行操作，是计算执行的更加快捷。

编译器开发者致力于自动化从标量代码到并行代码的转化，代码目前通过并行获得更高性能的最可靠的方法是GCC 支持的、操纵向量数据的 C 语言扩展。







