三、Y86-64 的顺序是先

（1）将处理组织成阶段

​		各个阶段以及各个阶段内执行操作的描述：

​			1、取值（fetch）：取值阶段会从内存读取指令字节，地址为程序计数器的值，从指令中抽取出指令指示符字节的两个四位部分，称为icode（指令代码） 和 ifun（指令功能）。

​			2、译码（decode）：译码阶段从寄存器文件读入最多两个操作符，得到值。

​			3、执行（execute）：执行阶段，算术/逻辑单元要么执行指令指明的操作，要么增加或减少栈指针。

​			4、访存（memory）：可以将数据写入内存，或者从内存读取数据。

​			5、写回（write back）：最多可以写两个结果到寄存器文件。

​			6、更新PC（PC update）：将 PC 设置成下一个指令的地址。

![image-20200607232939332](/Users/liuchang/Library/Application Support/typora-user-images/image-20200607232939332.png)

（2）SEQ 时序

时钟寄存器：程序计数器和条件码寄存期

随机访问存储器：寄存器文件、指令内存和数据内存

一个时钟变化会引发一个组合逻辑的流，来执行整个整个指令。

（3）SEQ 小结

根据之前的描述，发现在执行每条不同指令所需的步骤组成一个统一的流程，就可以用很少量的各种硬件单元以及一个时钟来控制计算的顺序，从而实现整个处理器。

疑问：

1、那 X86-64 是不是也是这么去执行的呢

2、那 X86-64 与 Y86-64 在执行上有什么区别呢？

四、流水线的通用原理

（1）计算流水线

随着 时钟不停的上升和下降，不同的指令会通过流水线进入不同的阶段，而且互相之间并不会干扰。

![image-20200608000742603](/Users/liuchang/Library/Application Support/typora-user-images/image-20200608000742603.png)

根据图可知，在 240 开始的时候，I1指令首先执行完毕B阶段的计算，在此时已经达到B阶段的寄存器，并向寄存器输入，而这个时候，I2指令完成了A阶段的计算，并完成A阶段寄存器的输入，此时I3并没有开始计算，所以并没有执行任何计算，也没有输入寄存器操作。在240开始时钟向上，则I1开始C操作。

根据以上结论，发现如果时钟运行过快的话，值可能会来不及通过组合逻辑。

（2）局限性

1、不一致的划分：当有一个阶段一直处于活动状态，那么其他阶段也需要划分时钟，造成延迟增加。

2、流水线过深，收益下降：当划分层级比较多的阶段的时候，造成计算时间减少了 但是流水线中寄存器的延迟增加了 ，并没有达到提高收益的效果。

疑问：

既然阶段变多，收益下降，那么为什么要增加家阶段呢？

五、Y86-64的流水线实现

（1）SEQ+：只需要对整个硬件结构做最小的改动，对于流水线阶段中的活动的时序，他能工作的更好，被称之为“SEQ+”。

（2）SEQ 在时钟周期结束时候，计算出寄存器的值，而SEQ+通过创建状态寄存器来保存指令过程计算出来的值。

（3）标示大写表示流水线寄存器的状态码字段，小写表示流水线阶段。

（4）避免冒险手段：

1、使用暂停来避免数据冒险

2、加载/使用数据冒险

3、用转发来避免数据冒险

4、减少控制冒险

疑惑：

那如果SEQ+工作能力更好，那为什么还有使用SEQ的情况呢？







