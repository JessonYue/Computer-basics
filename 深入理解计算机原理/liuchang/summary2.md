​																			总结

在本周主要学习了第二阶段的章节，和部分第三阶段的章节

主要学习到 处理器体系结构，在本章主要学到

一个处理器支持的指令和指令的字节集编码成为他的指令集体系结构（Instruction-Set Architecture，ISA）。各种处理器都有不同的ISA。

ISA 模型看上去应该是顺序指令执行。

为什么需要了解处理器的设计呢？

\- 处理器设计是非常重要的。可以了解到处理器的结构和规则。

\- 理解处理器工作原理能够帮助理解整个计算机系统如何工作。

\- 可以帮助设计硬件系统。可以完成最基础的系统上做更低抽象级别上进行设计和编程。

\- 完成工作。

（1）逻辑门

逻辑门是数字电路的基本计算单元。

逻辑门总是活动的，一旦一个门输入变化了，在很短的时间内，数据就会相应的变化

（2）存储器和时钟

时钟寄存器 存储单个位或字节，控制寄存器加载输入值。

随机访问存储器 储存多个字，用地址来选择该读或该写那个字节。

在硬件中，寄存器直接将他的输入和输出线连接到电路的其他部分。

时钟寄存器：程序计数器和条件码寄存期

随机访问存储器：寄存器文件、指令内存和数据内存

1、使用暂停来避免数据冒险

2、加载/使用数据冒险

3、用转发来避免数据冒险

4、减少控制冒险

第五章主要学习到

每个运算都是由延迟、发射时间和容量来刻画的

1、延迟：表示完成运算所需要的总时间

2、发射时间：表示两个连续的同类型的运算之间需要的最小时钟周期数

3、容量：表示能够执行该运算的功能单元的数量

对于循环形成的代码片段，我们可以访问到的寄存器分为四类：

只读：作为源值，可以用来计算内存地址，但是不能修改

只写：制作为数据传送操作。

局部：在循环内部被修改和使用。

循环：在一次迭代产生的值会在下一次迭代中使用

疑问？计算机中的只读和只写与寄存器的只读与只写是不是一个概念的呢

程序优化主要学习到

优化程序性能的基本策略：

1、使用高级设计：为遇到问题选择适当的算法和数据结构。要特别警觉，要避免使用那些会渐近的产生早的性能的算法或编码技术。

2、基本编码原则：避免限制玉华的因素，这样编译器就能产生高效的代码。

​	（1）消除连续的函数调用：在可能时，将计算移动到循环外。

​	（2）消除不必要的内存引用：引入临时变量来保存中间见过。

3、低级优化：结构化代码以利用硬件功能。

   （1）展开循环、降低开销，并使之进一步得到优化的可能性。

   （2）通过使用例如过个累积变量和重新结合等技术，找到方法提高指令级并行。

   （3）用功能性的风格重写条件操作，是编译采用条件数据传送。

在高速缓存中如何去除请求的字的过程：

1、根据需要被提取的目标的地址取出组索引位，根据索引位去匹配告诉内存中组中的索引位，当位相匹配的组被查询到的时候，将该组提取出来。

2、根据表示，确定行标示是否提取目标的标示是否匹配。

3、最后根据块偏移对行中值进行命中。

如何优化带来的思考：

1、尽量减少不命中的操作，减少写的操作；

2、尽量使用局部变量；

3、尽量减少循环核心部分。

链接主要学习

链接器必须完成的任务：



1、符号解析，将目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。



疑问 ：是否java中的变量是否与符号解析有关联呢，是否通过C语言惊醒关联的呢？



2、重定位编译器和汇编器生成从地址0开始的代码和数据

GNU READELE 程序是一个查看目标文件内容的很方便工具。

链接器解析符号引用的方法是将每个引用于他输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。

函数和已出初始化的全局变量是强符号，为初始化的全局变量是弱符号。

产生疑问：符号与java 中的引用有关系吗？

Linux 链接器使用下面古泽来处理多重定义的符号名：

1、不允许有多个同名的强符号；

2、如果有一个强符号和多个弱符号同名，则会选择强符号；

3、如果有多个弱符号同名，从中任意选择一个。

基本重定向类型：

R_X86_64_PC32：重定向一个使用32位PC相对地址的引用。

R_X86_64_32:重定位一个使用32位绝对地址的引用。

可执行目标文件的格式类似于可重定位目标文件的格式，ELF头描述文件的总体格式。

共享库是一个目标模块，在运行时或加载时，可以加载到任意的内存地址，并和一个内存中的程序连接起来，是有一个叫做动态链接器的程序执行的。