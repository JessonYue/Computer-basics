## 									动态链接（第一部分）

把链接这个过程推迟道理运行时进行，就是动态链接。

动态链接的基本实现：基本思想是吧程序按照模块拆分成各个相对独立部分，在程序运行时才讲它们连接在一起形成一个完整的程序而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。

动态链接设计运行时的链接及多个文件的装载，必须要有操作系统的支持，因为动态链接情况袭，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存空间、进程线程等机制在动态链接下也会产生一系列微妙的变化。

ELF动态链接文件被称动态共享对象（DSO，Dynamic Shared Objects)

1、地址无关代码

（1）装载时重定位

当程序在编译时假设被装载的目标地址为0x1000，但是在装载时操作系统发线 0x1000 这个地址已经被别的程序占用，但是发现 有另外一块足以容纳程序的空间 0x4000，这是程序被装载到了 0x4000，程序指令或数据中的所有绝对引用只要 都加上 0x3000 的偏移量就可以了。

（2）地址无关代码

装载时重定位时解决动态模块汇总有绝对地址引用的办法之一，但是它有一个很大的缺点，就是指令部分无法跨进程共享。

将指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程拥有一个副本。

模块间数据访问：ELF 的做法是在数据表里面建立一个指向这些变量的指针数组，也被称为全局偏移表，当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用。

![image-20200627193146127](/Users/liuchang/Library/Application Support/typora-user-images/image-20200627193146127.png)

使用GCC产生地址无关代码很简单，我们只需要使用“-fPIC”参数即可，“-fPIC” 产生代码要大很多，而“-fpic” 产生的代码相对较小。

2、延迟绑定

我们知道动态链接比静态链接慢的主要原因是动态链接下对于全局和静态的数据访问都要进行复杂的 GOT 定位，然后寻址；对于模块间的调用也要线定位 GOT ，然后在进行间接跳转，如此一来，程序的运行速度必定会减慢。

解决方案 ELF 采用了延迟绑定的做法，当函数第一次被使用到的时候才进行绑定，如果没使用到则不进行绑定。

PLT为了实现延迟绑定，在这个过程中间有增加了一层间接跳转，调用函数并不直接通过 GOT 跳转，而是通过一个叫做 PLT 项的结构来进行跳组昂，每个外部函数在 PLT 中都有一个相应的项，通过对应项进行函数争取调用。

3、动态链接相关结构

首先操作系统会读取可执行文件的头部.检査文件的合法性,然后从头部中的“ Program Header" 中读取每个 “Segment ” 的虚拟地址、文件地址和诚性，并将它们映射到进程虚拟 空间的相应位置， 这些步骤跟前面的静态链接情况下的装载基本无异。在静态链接情况卜 操作系统接着就可以把控制权转交给可执行文件的入口地址，然后程序开始执行。

但是在动态链接情况下，操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件，因为我们知道可执行文件依赖于很多共亨对象。这时候，可执行文件里对于很多外部符号的引用还处于无效地址的状态，即还没有跟相应的共享对象中的实际位置链接起来。 所以在映射完可执行文件之后，操作系统会先启动一个动态链接器 ( Dynamic Linker)。

为了完成动态链接.最关键的还是所依赖的符号和相关文件的信息。我们知道在静态链 接中，有一个专门的段叫做符号表 .symtab (SymbolTable)里保存了所有关于该目标文件的符号的定义和引用。

共享对象需要重定位的主要原因是导入符号的存在。动态链接下，无论是可执行文件或 共享对象 一旦它依赖于其他共亨对象，也就是说有导入的符号时，那么它的代码或数据中 就会有对于导入符号的引用• 在编译时这些导入符马的地址未知，在静态链接中，这些未知 的地址引用在最终链接时被修正 m是在动态链接中.导入符号的地址在运行时才确定 所 以需要在运行时将这些导入符号的引用修正，即需要重定位。

进程初始化的时候，堆找里曲保存了关于进程执行环境和命令行参数等信息。事实上，堆栈里面还保存了动态链接器所需要的一作辅助信息数组(Auxiliary Vector ）。

![image-20200627202349181](/Users/liuchang/Library/Application Support/typora-user-images/image-20200627202349181.png)

![image-20200627202404806](/Users/liuchang/Library/Application Support/typora-user-images/image-20200627202404806.png)

AT_PHDR，值为0x08048034，程序表头位于 0x08048034.

AT_PHENT， 值为20，程序表头中每个项的大小为20字节。

AT_PHNUM，值为 7 ，程序表头共有 7个项。

AT_ENTRY , 0x08048320，程序入口地址为 0x08048320。