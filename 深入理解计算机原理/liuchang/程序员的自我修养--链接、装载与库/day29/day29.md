## 										Linux 共享库的组织

### 1、共享库版本

#### 1、共享库兼容性

- 兼容更新：所有的更新只是在原有的共享库基础上添加一些内容，所有原有的接口都保持不变
- 不兼容更新：共享库更新改变了原有的接口，使用该共享库原有接口的程序可能不能运行或运行不正常

![image-20200629160932581](/Users/liuchang/Library/Application Support/typora-user-images/image-20200629160932581.png)

导致 C 语言的共享库 ABI 改变的行为主要有4种行为：

1. 导出函数的行为发生改变，也就是说调用这个函数以后产生的结果与以前不一样，不再满足旧版本规定的函数行为准则。
2. 导出函数被删除。
3. 导出数据的结构发生变化。
4. 导出函数的接口发生变化。

C++ 防止 ABI 不兼容，注意点：

1. 不要再接口类使用函数
2. 不要改变类中任何成员变量的位置和类型
3. 不要删除非内嵌的public 或protected 成员函数
4. 不要将非内嵌的成员函数改变成内嵌成员函数
5. 不要改变成员函数的访问权限
6. 不要在接口中使用模版
7. 不要改变接口的任何部分或干脆不要使用 C++ 作为共享库接口

#### 2、共享库版本命名

最前向使用前缀 lib 、中间是库的名字和后缀“.so ”，最后面跟卷的是三个数字组成的版本号。

### 2、符号版本

#### 1、基于符号的版本机制

基于符号的版本机制：这个方案的基本思路就是让每个导入导出的符号都有一个相关联的版本号，它的实际做法类似于名称修复的方法。

#### 2、Solaris 中的符号版本机制

Solaris的 ld 链接器为共享库增加了版本机制（Versioning）和范围机制（Scoping）。

版本机制：定义一些符号的集合，每个集合都包含一些指定的符号。

这种方式可以用丁保护那些共享库内部的公用实用函数，但是共享库的作者又不希望共享库的使用者能够有意或无意地访问这些函数。这种方法 又被称为范围机制(Scoping), 它实际上是对 C 语言没有很好的符号可见范围的控制机制 的一种补充，或者说是一种补救性质的措施。

事例：比如.一个共享库 libfoo.so.l 中有 6 个符号版本，从 SUNW 1.1 到 SUNW_1.6, 某个应用程序 app_foo 在编译时，系统中的 libfoo.so. 1 的符号版本为 SUNW_1.6, 但实际上 app_foo 只用到了最高到 SUNW_1.3 集合的符号，那么 应用程序实际上依赖于 SUNW_1.3, 而不是 SUNW_1.6。链接器会计算出 app_foo 所用到的 最高版本的符号，然后把 SUNW_1.3 记录到 app_foo 的可执行文件内。

### 3、共享库系统路径

大多数包括 Linux 在内的幵源操作系统都遵守个叫做 FHS ( File Hierarchy Standard) 的标准，这个标准规定了 一个系统中的系统文件应该如何存放，包括各个目录的结构、组织和作用，这有利于促进各个开源操作系统之间的兼容性。

- /lib, 这个位置主要存放系统最关键和苺础的共笋库 比如动态链接器、C 语言运行库、 数学库等，这些库主要是那些/bin 和/sbin 下的程序所需要用到的库 还有系统启动时 需要的库。
- /usr/lib, 这个目录下主要保存的是一些非系统运行时所需要的关键性的共亨库.主要是一些开发时用到的共享库，这些共亨库般不会被用户的程序或 shell 脚本直接用到。这个目录下面还包含了开发时可能会用到的静态库、目标文件等。
- /usr/IocaUlib 这个目录用来放 W—些跟操作系统本身并不十分相关的库，主要是一些 第三方的应用程序的库。比如我们在系统中安装了 python 语言的解释器 那么与它相 关的共享库可能会被放到/usr/local/lib/python, 而它的可执行文件可能被放到 /usr/loca /bin 卜。GNU 的标准推 第三方的程序应该默认将库安装到/usr/local/lib下。

### 4、共享库查找过程

Linux 系统中都有一个叫做 ldconfig 的程序，这个程序的作用是为共享库目录下的各个共享库创建、删除或更新相应的 SO- NAME( 即相应的符号链接)，这样每个共享库的 SO- NAME就能够指向正确的共享库文件;并且这个程序还会将这些 SO NAME 收集起来，集中存放到/etc/Id.so.cache 文件里面，并建立一个 SO NAME 的缓存。当动态链接器要查找共享库时，它可以直接从/etc/ld.so.cache 里面查找。而/etc/Id.so.cache 的结构是经过特殊设计的，非常适合査找，所以这个设计大大加快了共享库的查找过程。如果动态链接器在/etc/ldsoxache里面没有找到所需耍的共享库，那么它还会遍历/lib 和/usr/lib 这两个目录，如果还是没找到，就宣告失败。

所以理论上，如果我们在系统制定的共享目录下添加、删除或更新任何一个共享库，或者我们更改了/etc/ld.so.conf 的配置，都应该运行 ldconfig 这个程序，以便调整 SO—NAME 和 /etc/ld.so.cache。

### 5、环境变量

#### LD_LIBRARY_PATH

是一个由若干个路径组成的环境变量，每个路径之间由冒号隔开。

默认情况下，LD_LIBRARY_PATH为空，如果我们为某个进程设置LD_LIBRARY_PATH，那么进程在启动时，动态链接器在查找共享库时，会首先查找有 LD_LIBRARY_PATH 指定的目录。

LD LIBRARY PATH 对子共享库的开发和测试来说十分方便，但是它不应该被滥用。 也就是说，普通用户在正常情况下不应该随总设置LD LIBRARY PATH 来调整共亨库搜索 目录。随意修改 LD LIBRARY PATH 并且将其导出至全局范围，将可能引起其他应用程序 运行出现的问题；LD LIBRARY PATH也会影响GCC编译时查找库的路径，它里面包含的 目录相当于链接时 GCC 的 “ -L ” 参数。

#### LD PRELOAD

系统中另外还有一个环境变量叫做LD PRELOAD,这个文件中我们可以指定预先装载的一些共享库或是目标文件。它比LD LIBRARY PATH里面所指定的目录中的共享库还要优 先。

#### LD DEBUG

这个变量可以打幵动态链接器的调试被提前装载。LD DEBUG功能，当我们设置这个变量时，动态链接器会在运行时打印出各种有用的信息，对于我们开发和调试共亨库有很大的帮助。

LD_DEBUG 还可以设置成其他值：

- “bindings” 显示动态链接的符号绑定过程。
- “ libs ” 显示共享库的査找过程。
- “ versions” 显示符号的版本依赖关系。
- “reloc” 显示重定位过程。
- “symbols” 显示符号表查找过程。
- “statistics” 显示动态链接过程中的各种统计信息。
- “all” 显示以上所有信息。
- “help” 显示上面的各种可选值的帮助信息。

## 6、共享库的创建和安装

#### 1、共享库的创建

“-shared” 表示输出结果是共享库类型的；“-fPIC” 表示使用地址无关代码技产生的输出文件。

#### 2、消除符号信息

我们可以使用一个叫做“strip” 的工具消除共享库或可执行文件的所有符号和调试信息。也可以使用ld的“-s”和“-S”参数，使得链接器生成输出文件时就不产生符号信息。

