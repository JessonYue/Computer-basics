## 									可执行文件的装载与进程

6.1 进程虚拟地址空间

- 程序是一个静态的概念，他是一些预先编译好的指令和数据集合的一个文件。
- 进程是一个动态的概念，它是程序运行时的一个过程。

虚拟地址空间的大小由计算机的硬件平台决定，具体地说是由 CPU 的位数决定，每个程序运行起来后，都是拥有自己独立的虚拟地址空间。

一般来说，C 语言指针大小的位数与虚拟空间的位数相同，如 32 位平台下的指针位 32 位，即 4 字节；64 位平台下的指针位 64 位，即 8 字节。

进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。

“空间” 是否是指虚拟地址空间呢？ 答案是“否”，因为 32 位的 CPU 只能使用 32 位指针， 它的最大寻址范围 是 0 到 4G （0xFFFFFFFF）。而“空间”真正指的是计算机的内存空间。

自从扩展到 36 位 地址线之后，Intel 修改了页映射的方式，是的新的映射方式可以访问到更多物理内存，这种地址的扩展方式被叫做 PAE（Phyical Address Extension）。

6.2 装载的方式

程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全部装入内存中，这样程序就可以顺利运行，这就是最简单的静态装入的办法。

程序运行时我们将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入。动态装入有两种典型的方法：覆盖装入和 页映射。

1、覆盖装入

覆盖装入的方式吧挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序 分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该主流内存何时应该被替换掉。这个辅助模块就是覆盖管理器。

在多个模块情况下，程序员需要手工将模块按照它们之间的调用关系组织成树形结构。

![image-20200626151254958](/Users/liuchang/Library/Application Support/typora-user-images/image-20200626151254958.png)

覆盖管理器需要保证两点：

（1）这个树形结构中从任何一个模块到根节点，叫做调用路径。

（2）禁止跨树调用。

2、页映射

页映射是虚拟存储机制的一部分，它随着虚拟存储的发明而诞生。

页映射不是一下子将所有数据和指令都装入，而是将内存和所有磁盘中的数据和指令按照“页”为单位划分称为若干个页，当需要装载时，将相应的页加载。

而当页映射已经满了时候，在需要映射页的守候一般采用的方式：

先进先出原则：根据最近最少使用原则，将最少使用的页移除掉，将新映射的页映射到队尾。

6.3 从操作系统角度看可执行文件的加载

1、进程的建立

一个进程最关键的特征就是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行伴随着一个新的进程的创建。

程序被形式的三个步骤：

（1）建立一个独立的虚拟地址空间

（2）读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系

（3）将 CPU 的指令寄存器设置成可执行文件的入口地址，启动程序

在第一步中，并不是设置页的映射关系，而是为页分配一个页目录，从而创建一个需要映射的数据结构，并不是真正意义上的创建空间。

在第二步中，首先当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后根据错误中将该“缺页”从磁盘中读取到内存中，在设置“缺页”的虚拟页和物理页的映射关系。

在第三步中，操作系统通过设置 CPU 的指令寄存器将控制权交给进程。

2、页错误

由前文可以知道操作系统知识通过可执行文件的头部信息建立可执行文件和建成虚拟内存之间建立映射关系，而当执行指令时，发现执行页是一个空页，于是就认为这是一个页错误。

6.4 进程虚存空间分布

1、ELF文件链接视图和执行视图

ELF 可执行文件引入了一个叫做 “Segment”，一个“Segment” 包含一个或多个属性类似的 “Section”。

将段进行合并在一起看作一个“Segment”，在装载的时候可以将它们看作一个整体一起映射，这样在虚存空间中只会产生一个VMA，从而减少页的数量，达到节省内存空间。

“Segment” 实际上就是从装载角度重新划分了 ELF 的各个段，链接器会尽量把相同权限属性的段分配在同一空间。

从“Section”的角度来看 ELF 文件就是链接视图，从“Segment”的角度来看及时执行视图。

2、堆和栈

堆 VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。

栈 VMA，管钱可读写、不可知性；无映像文件，匿名，可向下扩展。

3、堆的最大申请数量

一般城通中使用 malloc（）函数进行地址空间申请

通过一下代码可以查看：

![image-20200626162958822](/Users/liuchang/Library/Application Support/typora-user-images/image-20200626162958822.png)

6.5 Linux 内核装载 ELF 过程简介

（1）调用fork（）系统调用创建一个新的进程

（2）调用 execve（）系统调用执行指定的 ELF文件

（3）bash 进程继续返回等待新启动的进程结束

（4）继续等待用户输入命令

execve（）调用入口 sys_execve（），之后调用 do_execve（）。do_execve()首先会查找被执行的文件，如果找到文件，则会读取文件的前128个字节。为什么要这么做呢？因为Linux支持的可执行文件不知 ELF 一种，还是其他脚本程序。do_execve（） 读取文件的前128个字节的目的时判断文件格式。

读取了 do_execve（）之后调用 search_binary_handle（）去搜索和匹配合适的可执行文件装载处理过程。

ELF 装载过程步骤：

1、检查ELF 可执行文件格式的有效性，比如魔数、程序头表中段的数量。

2、寻找动态链接的“.interp”段。

3、根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射。

4、初始化 ELF 进程环境。

5、将系统调用的返回地址修改成 ELF 可执行文件的入口点。

6.6 小结

了解了操作系统如何为成代码、数据、堆、栈在进程地址空间中分配。

了解了覆盖装入和页映射。

了解了虚拟空间地址的限制。

还有 没搞明白 这里面说的对齐是咋对齐的，先略过。