## 													内存

### 1、程序的内存布局

- 栈：栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节的大小。
- 堆：是用来容纳应用程序动态分配内存区域，当程序是用 malloc 或者 new 分配内存时，得到的内存来自堆里。堆通常存在于栈的下方（低地址方向），在某些时候，堆也可能没有固定统一的存储区域，堆一般比栈要大很多，可以有几十只几百兆字节的容量。
- 可执行文件影响：这里存储着可执行文件在内存里的映像，有装载器在装载时将可执行文件的内存读取或映射到这里。
- 保留区：并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。

### 2、栈与调用管理

#### 1、什么是栈

栈是现代计算机程序里面最为重要的概念之一，在一般情况下，用户可以将数据压入栈中，也可以将已经压入栈中的数据弹出，先入栈的数据后出栈。

栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧或是活动记录。

堆栈帧一般包括几个方面的内容：

1. 函数的返回地址和参数
2. 临时变量：包括函数的非晶态局部变量以及编译器自动生成的其他临时变量
3. 保存的上下文：包括函数调用前后需要保持不变的寄存器

#### 2、调用惯例

- 函数参数的传递顺序和方式：函数参数的传递有很多种方式.最常见的一种是通过栈传递。函数的调用方将参数压入 栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方 将参数压栈的顺序:是从左至右，还是从右至左。有些调用惯例还允许使用寄存器传递参数， 以提高性能。
- 栈的维护方式：在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以 使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函 数本身来完成。
- 名字修饰的策略：为了链接的时候对调用惯例进行区分，调用管理要对函数本身的名字进行修饰。不N的 调用惯例有不同的名字修饰策略。

![image-20200630171817106](/Users/liuchang/Library/Application Support/typora-user-images/image-20200630171817106.png)

### 3、堆与内存管理

#### 1、什么是堆

堆是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分。在这片空间里，程序可 以请求 •块连续内存，并自由地使用，这块内存在程序主动放弃之前都会一直保持有效。

malloc如何实现申请空间

程序向操作系统申请一块适当大小的堆空间，然后程序自己管理这块空间，管理着堆空间分配的往往是程序的运行库。

#### 2、堆分配算法

1、空闲链表(Free List)的方法实际上就是把堆屮各个空闲的块按照链表的方式连接起来， 当用户消求一块空间时，可以遍历整个列表，直到找到合适人小的块并且将它拆分；当用户 释放空间时将它合并到空闲链表中。

2、位图(Bitmap〉，其 核心思想是将整个堆划分为大量的块(block), 每个块的大小相同。当用户请求内存的时候， 总是分配整数个块的空间给用户，第一个块我们称为己分配区域的头(Head), 其余的称为己 分配区域的主体(Body)。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只 有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。

位图实现方式的优点：

1、速度快；

2、稳定性好；

3、便于管理；

位图实现方式的缺点：

1、容易产生碎片

2、命中率降低，浪费部分空间

3、对象池对象池的思路很简申.，如果每一次分配的空间大小都一样，那么就可以按照这个每次请 求分配的大小作为一个单位，把整个堆空间划分为人量的小块，每次请求的时候只需要找到 一个小块就可以了。对象池的管理方法可以采用空闲链表，也可以采用位图 与它们的区别仅仅在于它假定 了每次请求的都是一个固定的大小，因此实现起来很容易。由于每次总是只请求一个单位的内存 ，因此请求得到满足的速度非常快， 无须査找一个足够大的空间。