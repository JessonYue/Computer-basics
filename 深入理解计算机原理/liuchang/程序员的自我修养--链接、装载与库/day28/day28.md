## 									动态链接（第二部分）

1、动态链接的步骤和实现

动态链接的步骤基本分为3步：1、启动动态链接器 2、装载需要共享的对象 3、重定位和初始化

（1）动态链接器自举

动态链接器特性：

1、动态链接器本身不可以依赖于其他任何共享对象

2、动态链接本身所需要的全局和静态变量的重定位工作由自身完成

通过上面特性可以了解到，动态链接器保证不使用任何系统库、运行库，并且在启动时有一段非常精巧的代码可以完成自身重定向的工作，这种限制条件完成启动代码被称为自举。

自举代码首先会找到它自己的 GOT ，而 GOT 的第一个入口保存的就是 “.dynamic” 段的偏移地址，由此找到了动态链接器本身的 “.dynamic”段。根据段中信息自举代码可以获取动态链接器本身的重定位表和符号表，从而的到动态链接本身的重定位入口，从而达到重定位。

当自举过程中链接器本身的函数也是不能调用的，这是因为使用 PIC 模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式（GOT/PLT），所以在GOT/PLT 没有被重定位之前，自举代码是不能使用全局变量或者函数的。

（2）装载共享对象

完成自举后，动态链接器将可以执行的文件和链接器本身的符号表都合并到一个符号表中，被称为全局符号表。

这种一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称为共享对象全局符号介入(Global Symbol Interpose).

当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加 入的符号被忽略。

（3） 重定位和初始化

链接器开始重新遍历可执行文件和每个共享对象的重定位表， 将它们的 GOT/PLT 中的每个需要重定位的位置进行修正。

当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都 己经装载并且链接完成了，将进程的控制权转交给程序的入 口并且开始执行。

（4）Linux 动态链接器实现

对于静态链接的可执行文件来说，程序的入口就是 ELF 文件头里面的 e_entry 指定的入口;对于动态链接的可执行文件来说，如果这时候把控制权交给 e_entry 指定的入口地址，那么肯定是不行的，因为可执行文件所依赖的共亨库还没有被装 载，也没有进行动态链接。所以对于动态链接的可执行文件，内核会分析它的动态链接器地 址(在 “.interp” 段)，将动态链接器映射至进程地址空间，然后把控制权交给动态链接器。

动态链接器本身必须是PIC的吗?
 是不是 PIC 对于动态链接器来说并不关键，动态链接器可以是 PIC 的也可以不是，但往 往使用 PIC 会更加简单一些。一方面，如果不是 PIC 的话，会使得代码段无法共享，浪 费内存:另一方面也会使 ld.so 本身初始化更加复杂，因为自举时还需要对代码段进行重定位。实际上的ld linux.so.2 是 PIC 的。

2 显示运行时链接

支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接( Explicit Run-time Linking), 有时候也叫做运行时加载。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。

主要的区别是共享对象是由动态链接器在程序启动之前负责装载和链 接的，这一系列步骤都由动态连接器自动完成，对于程序本身是透明的；而动态库的装载则 是通过一系列由动态链接器提供的 API, 具体地讲共有 4 个函数:打开动态库(dlopen)、 查找符号(dlsym)、错误处理(dlerror) 以及关闭动态库(dlclose)，程序可以通过这几个 API 对动态库进行操作。

（1）dlopen（）

dlopenO 函数用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程， 它的 C 原型定义为:

void * dlopen{const char *filename, int flag);

第二个参数 flag 表示函数符号的解析方式，常量 RTLD LAZY 表示使用延迟绑定，当 函数第一次被用到时才进行绑定，即 PLT 机制:而 RTLD NOW 表示 模块被加载时即完 成所有的函数绑定工作，如果有任何未定义的符号引用的绑定 T 作没法完成 那么 dlopen（）就返回错误。上向的两种绑定方式必须选其一。另外还有一个常量 RTLD GLOBAL 可以跟 上面的两者中任意一个一起使用(通过常量的“或” 操作)，它表示将被加载的模块的全局 符号合并到进程的全局符号表中，使得以后加载的模块可以使用这些符号。

（2）dlsym（）

dlsym 函数基本上是运行时装载的核心部分，我们可以通过这个函数找到所需要的符 号。它的定义如下:

void dlsym{void *handle, char *symbol);

（3）dlerror（）

每次我们调用 dlopen()、dlsymO或 dlcloseO以后，我们都可以调用 dlerrorO函数来判断 上一次调用是否成功。

（4）dlclose（）

dlcloseO的作用跟 dlopenO刚好相反，它的作用是将一个己经加载的模块卸载。