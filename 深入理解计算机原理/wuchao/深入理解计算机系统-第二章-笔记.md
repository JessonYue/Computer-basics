## 第二章

## 信息表示和处理

* 内存地址

  内存中的每一个字节都由一个唯一的数字来标识，称为它的地址。字节（8位）是最小的可寻址的内存单位。

* 指针

  指针包含值和类型。

  值代表某个对象的地址，类型表示对象的类型。

* 字长（word size）

  指针数据的标称大小（norminal size），决定的是虚拟地址空间的最大大小。

  将程序称为“32位程序”或“64位程序”取决于是如何编译的，而不是运行的机器类型。

  int32_t 和 int64_t 不依赖编译器和机器的设置，固定长度为4字节和8字节

* 声明指针

  T *P 表示指针变量P，指向一个类型为T的对象。

* 寻址和字节顺序

  对象的地址为所使用的字节中最小的地址。

  排列一个对象的字节有两个规则：

  1. 大端法：最高有效字节在最前面的方式。
  2. 小端法：最低有效字节在最前面的方式。

  * 大小端问题

    1. 网络传输，发送端的字节顺序和接受端的字节顺序相反，那么接收端收到的数据是反序的。因此网络应用程序必须遵守已建立的关于字节顺序的规则
    2. 小端字节序和人类正常书写阅读的顺序相反，因此在阅读时需要注意。

  * 为什么会有小端规则？

    跟CPU厂商实现方式有关。

* 运算符

  * 移位运算，应该保持移位量小于待移位值的位数。

    做法是：位移量 mod 待位移值得位数

* 整数表示

   * 补码编码

     常用来表示有符号数。最高有效位为负权重（negative weight）。表示的值计算方式是：最高位的值*负权重+其他位表示的值（位的值 * 位的权重）

     例如1111-> -1*2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 4 + 2 + 1 = -1

  * 有符号数的其他表示方法：

    1. 反码

       除了最高有效位的权重是-(2^(w-1)-1)，其他跟补码是一样的。

       例如：1111->-1*(2^3-1)+ 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 0

    2. 原码

       最高位是符号位，用来决定生下的位应该取正权还是负权。

  * 有符号数和无符号数之间转换

    位值不变，改变了解释这些位的方式。

    T2U（补码转无符号数）
    $$
    满足TMin_{w}\leqslant x\leqslant TMax_{w} 的x
    有
    $$

    $$
    T2U_{w}(x)=x+2^{w},x<0
    $$

    $$
    T2U_{w}(x)=x,x\geqslant 0
    $$

    U2T（无符号数转补码）
    $$
    满足0\leqslant u\leqslant UMax_{w}的u有
    $$

    $$
    U2T_{w}(u) = u,u\leqslant TMax_{w}
    $$

    $$
    U2T_{w}(u) = u-2^{w},u> TMax_{w}
    $$

  * 无符号数和有符号数运算

    C语言会隐式的将有符号参数强制类型转换为无符号数，并假设这两个数是非负的，来执行这个运算。

    问题：C语言中TMin32 要写成-2147483647-1，而不是-2147483648，为什么？

    当编译器遇到一个数要形成-X时，首先确定数据类型和X的值，然后对其求反，而2147483648这个值用int来表示的话太大了，超过了有符号数的最大值（2147483647）。所以编译器会确定一个数据类型来合适地表示这个值。在不同的语言版本下，结果不同。

    在ISO C90 版本下，编译器会找到unsigned类型来表示这个值，再求反（根据公式2^w-x,x>0）就会得到2147483648的无符号值，这显然是不对的。

    在ISO C99 版本下，编译器会找到long long类型来表示这个值。然后再求反，就会得到有符号值-2147483648。

    为了一定能得到正确的值，所以选择-2147483647-1来表示TMin32。

    参考：

    http://csapp.cs.cmu.edu/public/waside/waside-tmin.pdf

  * 扩展一个数字的位表示

    从一个较小的数据类型转换到一个较大的数据类型

    * 无符号数

      零扩展：开头添加0

    * 补码（有符号）数

      符号扩展：开头添加最高有效位（符号位）的值

  * 截断一个数字的位表示

    丢弃高位

    * 无符号数

      k表示截取的位数
      $$
      x^{'}=x mod 2^{k}
      $$

    * 有符号数
      $$
      x^{'}=U2T_{k}(x mod 2^{k})
      $$

    

  * 整数运算

    * 无符号数

      * 加法
        $$
        x+_{w}^{u}\textrm{y} = x+y,x+y<2^{w}(正常)
        $$

        $$
        x+_{w}^{u}\textrm{y} = x+y-2^{w},2^{w}\leqslant x+y< 2^{w+1}(溢出)
        $$

        

      * 加法逆操作（求反）
        $$
        -_{w}^{u}\textrm{x} = x,x=0
        $$

        $$
        -_{w}^{u}\textrm{x} = 2^{w}-x,x> 0
        $$

      * 乘法

        可能需要2w位来表示，但是只取低w位表示的值
        $$
        x*_{w}^{u}\textrm{y} = (x\cdot y)mod2^{w}
        $$

        * 乘以常量

          因为乘法耗时较长。编译器可以用移位和加法或减法运算的组合代替乘以常数的乘法。

          形式A：（x<<n)+(x<<(n-1))+...+(x<<m)

          形式B：（x<<(n+1) ) - (x<<m)

      * 除以2的幂

        可以用逻辑右移来实现，结果向0舍入。
        $$
        x>>k = \left \lfloor x/2^{k} \right \rfloor
        $$
        

    * 补码（有符号数）

       * 加法
         $$
         x+_{w}^{t}\textrm{y} = x+y,-2^{w-1}\leq x+y<2^{w-1}(正常)
         $$

         $$
         x+_{w}^{t}\textrm{y} = x+y-2^{w},2^{w-1}\leq x+y(正溢出)
         $$

         $$
         x+_{w}^{t}\textrm{y} = x+y+2^{w},x+y<-2^{w-1}(负溢出)
         $$

         

       * 加法逆操作（求非）
         $$
         -_{w}^{t}\textrm{x} = TMin_{w},x=TMin_{w}
         $$

         $$
         -_{w}^{t}\textrm{x} = -x,x>TMin_{w}
         $$

         * 位级补码的非

           1. -x=~x+1(对每一位求补，然后+1)

           2. 假设k是最右边的1的位置，对k左边所有位求反

              例如：1100(-4)->0100(4)

      * 乘法
        $$
        x*_{w}^{u}\textrm{y} = U2T_{w}((x\cdot y)mod2^{w})
        $$

        * 乘以常量（同无符号数）

      * 除以2的幂

        为了保证负数仍为负数，所以要执行算数右移。当x<0时，不加处理的算数右移会产生向下舍入的错误可以这样处理：

        (x < 0?x+(1 << k) - 1:x)>>k

    * 无符号数和补码乘法的位级等价性

      即位表示相同的x和y，他们作为无符号数做乘法运算，和作为补码做乘法运算，得到的值的低位的位表示是相同的。 

    * 整数运算实际上是一种模运算（mod）形式，因为数字的有限字长限制了可能的值得取值范围，结果运算可能溢出。

  * 浮点数

    * 二进制表示

      例如：101.11 表示 1*2^2+ 0 * 2^1 + 1*2^0 + 1 * 2^-1 + 1* 2^-2 = 5又3/4

      只能表示x*2^y的数 ，其他值只能近似表示，增加2进制表示的长度可以提高精度。

    * IEEE浮点表示
      $$
      V=(-1)^{s}*M*2^{E}
      $$
      s为符号位，s=1为负数，s=0为正数。

      将浮点数划分为3个阶段来编码

      1. 一个单独s编码符号s
      2. k位的阶码字段exp=ek-1...e1e0 编码阶码E
      3. n位小数字段frac=fn-1...f1f0编码位数M（编码结果依赖E）

      * exp值的三种情况：

        1. 规格化的值，即exp不全为0也不全为1。

           E = e(ek-1...e1e0)-(2^(k-1) -1)

           M = 1+f

        2. 非规格化的值，即exp全为0

           E = 1 - 2^(k-1) -1)

           M = f

           可以表示0，和那些非常接近0的值。

        3. 特殊值，exp全为1

           frac 全为0时表示无穷，s=1负无穷，s=0正无穷。

           frac 非0时，结果值为NaN（一些运算结果不能是实数或者无穷），例如
           $$
           \sqrt{-1}
           $$

      * 舍入

        表示方法限制了浮点数的范围和精度，舍入运算是找到最接近的匹配值，可以用期望的浮点形式表示出来。

      * 浮点运算

        浮点加法不具有结合性。

        浮点加法满足单调性，无符号或补码加法不满足。

        浮点乘法不具有结合性，具有单调性。无符号或补码乘法不具有。

      * int、float、double之间转换

        int->float 不会溢出、可能被舍入

        int（float）-> double 能够保留更精确的值

        double -> float 可能溢出成正无穷和负无穷，还可能被舍入

        float(double) -> int 值向零舍入，还可能会溢出。

* 总结

  主要介绍整数的表示，无符号数、有符号数以及整数的运算。

  这些操作中可能产生一些问题：

  1. 有符号数的不对称性，在表示它的最小值（TMin32）时需要注意，否则可能会得不到想要的值。
  2. 由于数据大小是有限的，运算可能会产生溢出。可能会得到一个和正确值相差甚远的一个值。
  3. 无符号数和有符号数一起执行运算，会把有符号数隐式转换成无符号数，在关系运算时，导致结果可能会不直观。

  乘法运算的除法运算的技巧

  由于乘除法运算耗时较长。可以通过移位和加减法来代替部分值的运算。

  

