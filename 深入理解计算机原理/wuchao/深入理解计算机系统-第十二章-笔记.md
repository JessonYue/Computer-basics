## 第十二章

## 并发编程

### 程序级并发

* 进程

  每个逻辑控制流都是一个线程，由内核来调度和维护。多个逻辑控制流间通信，需要用进程间通信技术（IPC），因为每个进程拥有独立的虚拟地址空间。

  * 进程并发的优劣
    1. 不共享地址空间，不会发生一个进程的虚拟内存被另一个进程覆盖的情况。
    2. 需要显式的IPC来通信，使用起来困难并且开销很高。
    3. 进程控制靠内核来调度，涉及到用户态到内核态的相互切换，开销很高。

* IO多路复用

  应用程序在一个进程的上下文中显式地调度自己的逻辑控制流。所有的流共享一个地址空间。控制流可以模型化为状态机。逻辑流的推进就是状态机的转换。

  * 状态机

    就是一组状态、输入事件、转移。转移指的是将输入状态和输入事件映射到一个输出状态。

  * IO多路复用的优劣

    1. 相比基于进程的设计可以让程序员更多的对程序的行为进行控制。
    2. 流的数据共享更方便，因为所有的流都能访问同一个进程的全部地址空间。
    3. 性能优于基于进程实现，因为不需要进程上下文切换来调度。
    4. 缺点是编码复杂，不能充分利用多核处理器的性能。

* 线程

  基于线程的并行是上述两种方式的结合体。单一进程上下文中的逻辑流，由内核进行调度，共享同一个虚拟地址空间，例如地址空间代码、数据、堆、共享库、打开的文件。

  线程是运行在进程上下文中的逻辑流。每个线程都有其独立的线程上下文(Thread context)，包括一个唯一的整数线程 Thread ID、栈、栈指针、程序计数器、通用目的寄存器和 条件码。

   * 可结合的线程和分离的线程

     默认情况下，线程创建为可结合的。

     * 可结合线程

       能够被其他线程回收和杀死，在被其他线程回收杀死之前，它自身的资源是不会回收的。为了避免内存泄露，需要显式的将其回收，或者被分离(调用pthread_detach)。

     * 分离的线程

       不能被其他线程回收和杀死，内存资源在它终止时系统自动回收。

  * **线程内存模型**

    寄存器的值和栈空间是线程独享的，而虚拟内存总是共享的。

    * 变量映射到内存

      全局变量即函数外声明的变量和本地静态变量即函数内声明static的变量都在虚拟内存中只存在一个实例，每个对等的线程都共享这个实例。

      局部变量即函数内没有声明static的变量，每个线程的栈都包含它自己的所有本地自动变量的实例。

    * 同步

      共享变量的方便，同时也引入了同步错误。即多线程共享同一个变量，执行，得到的结果是错误的。

      * 信号量实现同步

        基本思想是将每个共享变量(或者一组相关的共享变量)与一个信号量s(初始为1)联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来。在一个互斥锁上执行 P 操作称为对互斥锁加锁。类似地，执行 V 操作称为对互斥锁解锁。对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。在访问共享变量的操作之前加锁，在访问之后解锁，只有获得互斥锁的线程才能访问到共享变量，这样就让每个线程对共享变量的操作是互斥的，这样就保证了结果的正确性。

        同步操作P和V的开销很大，所以要尽可能的避免。

  * 线程安全

    一个函数被称为线程安全的，是指被多个并发线程反复调用时，会一直产生正确的结果。

    * 线程不安全举例：
      1. 不保护共享变量的函数。可以通过加互斥锁来解决。
      2. 包含跨越多个线程的状态的函数。可以重写函数，让其不使用共享变量。
      3. 返回指向静态变量的指针的函数。可以通过加互斥锁来解决。
      4. 调用线程不安全函数的函数。如果该函数属于1和3，可以通过加锁来解决。

  * 可重入性

    可重入函数：当它们被多个线程调用时，不会引 用任何共享数据。所有函数的集合被划分成不 相交的线程安全和线程不安全函数集合。可重入函数集合是线程安全函数的一个真子集。

    * 显示可重入

      函数参数都是传值传递的(即没有指针)，并且所有的数据引用都是本地的自动栈变量(即没有引用静态或全局变量)。

    * 隐式可重入

      函数参数是引用传递，但是调用着非常小心的传递非共享引用，那么这个函数就是隐式可重入的。

  * 竞争

    当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点 时，就会发生竞争(race)。即依赖线程的执行顺序。是否得到 正确的答案依赖于内核是如何调度线程的执行的。

  * 死锁

    引入信号量导致一组线程被阻塞了，等待一个永远也不会为真的条件。

    例如：两个信号量的禁止区域重叠，重叠的禁止区域引起了一组称为死锁区域(deadlock region)的状态。当某个线程进入这个区域，由于禁止区域阻塞了每个合法方向上的进展，那么这个线程将不会有任何进展，因为它在等待一个永远都不可能执行的V操作。

    解决办法：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序 获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

  

  

  

  