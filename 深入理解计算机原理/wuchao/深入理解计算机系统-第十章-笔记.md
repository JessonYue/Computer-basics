## 第十章

## 系统级IO

### Unix IO

所有的 I/O设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I/O。

 * 基本操作

   1. 打开文件。

      一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O设备。

      * 描述符

        内核接受程序打开文件的请求，返回一个小的非负整数，这个称为**描述符**。它在后续对此文件的所有操 作中标识这个文件。应用程序记住这个描述符，就可以找到这个对应的文件对它进行相应操作。

        创建的每个进程开始时都有三个打开的文件:标准输入(描述符为 0)、标准

        输出(描述符为 1)和标 准错误(描述符为 2)。

   2. 改 变当前的文件位置。

      即改变这个文件从文件开头起始的字节偏移量。

   3. 读写文件

      一个读操作就是从文件复制n>0 个字节到内存，从当前文件位置k开始，然后将文件位置k增加到k+n。给定一个大小为 m 字节的文件，当时执行读操作>=m会触发一个称为EOF的条件，即文件到尾了。写操作就是从内存复制 k>0 个字节到一个文件，从当前文件位置是 开始，然后更新k。

   4. 关闭文件

      应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响 应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。

* 文件类型

  1. 普通文件

     包含任意数据，通常分为二进制文件和文本文件。文本文件是只含有 ASCII 或 Unicode 字符的普通文件。

  2. 目录

     包含其他文件的文件，包含一组链接(link)，其中每个链接都将一个 文件名 (filename)映射到一个文件，这个文件可能是另一个目录。

  3. 套接字socket

     用来与另一个进程进行跨网络通信的文件。

* 共享文件

  * 描述打开文件的三个相关数据结构

    1. 描述符表

       每个进程都有它独立的描述符表，它的表项是由进程 打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。

    2. 文件表

       打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个表项包括当前的文件位置、引用计数 (reference count)(即当前指向该表项的描述符表项数)，以及一个指向 v-node 表中 对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。只有引用计数为0时，内核才会删除这个文件表表项。

    3. v-node表

       所有的进程共享。每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。即文件的访问权限，文件大小、文件类型等。

  * 共享

    多个描述符也可以通过不同的文件表表项来引用同一个文件。

    <img src="/Users/wuchao/Library/Application Support/typora-user-images/image-20200620213321347.png" alt="image-20200620213321347" style="zoom:40%;" />

### 标准IO库 和 RIO 库的选择

* 只要有可能就使用标准IO库，更加简便和完整。
* 不要使用scanf 和 rio_readlineb 来读取文本，这两个函数是读取二进制文件的。
* 对于网络套接字的IO用RIO库。因为网络文件和标准IO有一些不兼容的限制。

