## 第三章

## 程序的机器级表示

### 程序的编码过程及运行需要的硬件抽象

* 程序编码过程

  1. C预处理器扩展源代码，将#include 指定的文件插入，扩展#define 声明的宏。
  2. 编译器将源代码处理生成汇编代码。
  3. 汇编器将汇编代码转化成二进制目标代码文件。
  4. 链接器将目标代码文件和实现库函数（如printf）的代码合并。生成可执行二进制代码文件。

* 处理器状态

  1. 程序计数器（PC）。存放要执行的下一条指令在内存中的地址。
  2. 整数寄存器文件。16个命名位置，每个存储64位的值。存储地址或整数数据。指令可以单独访问每一个寄存器低一个字节（8位），低一个字（16位），低双字（32位），或一整个寄存器。
  3. 条件码寄存器。保存最近执行的算术或逻辑指令的状态信息。实现控制或数据流中的条件变化
  4. 向量寄存器。存放整数或浮点数。

* 程序内存

  包含可执行机器代码、操作系统需要的一些信息，用来管理过程调用、返回的运行时栈、用户分配的内存块。

  程序内存用虚拟内存来寻址。

  操作系统负责管理虚拟内存地址空间，将虚拟地址翻译成物理地址。

* C程序中插入汇编代码

  1. 用汇编代码编写完整的函数，放到一个独立的汇编代码文件中，然后用汇编器和链接器，把它和C书写的代码合并起来。
  2. 利用GCC的内联汇编（inline assembly）特性，在编译的时候，用伪ASM指令，在C代码中包含汇编代码。

### 指令

* 操作数指示符

  一般一条指令后面可以跟一个或者多个操作数。操作数指示出操作需要用到的源数据，或放置结果的地方。

  1. 立即数，即常量

  2. 寄存器的值

  3. 内存引用

     根据计算出来的地址，来访问某个内存位置，M[Addr]表示内存中Addr地址开始的b字节值的引用。

     多种寻址方式：

     1. 绝对寻址，即M[内存地址值]
     2. 间接寻址，即M[寄存器的值]，先找到指定寄存器，取出该寄存器的值，然后再寻址内存。在此基础上可以加上偏移量或乘以比例或加上别的寄存器的值。

* 数据传送指令

  将一个数据从源位置复制到目标位置。

  以MOV为例，它有两个操作数，源操作数指定的一个值是立即数，存在寄存器或者内存中。目标操作数指定的是寄存器或内存地址。

  x86-64加了一条限制，即将内存中的一个值复制到另外一个内存位置需要两条指令，第一条指令将源数据加载到寄存器，第二条指令将寄存器的值写入到目标位置。

* 指针和间接引用

  指针其实就是内存地址，间接引用是将地址放在寄存器中，然后通过寄存器间接访问内存。

* 程序栈

  程序栈存在内存当中，栈向内存地址小的方向增长，也就是说，栈顶元素是栈中内存地址最小的元素。

  栈指针%rsp寄存器存放的是栈顶元素的地址。

  入栈操作：

  1. 栈指针减去数据大小，即将栈指针%rsp寄存器中存放的内存地址减去数据大小，即指向栈顶元素地址减8的内存地址。
  2. 然后将寄存器中的值，存放到栈指针中存放的地址，这个元素就变成栈顶了。

  出栈操作：

  1. 将程序栈顶元素的值复制到寄存器
  2. 栈指针%rsp的值加上数据大小，即栈指针指向原先栈顶地址加上数据大小的内存地址。

* lea指令(load effective address)

  这个指令用来加载**有效地址**。目的操作数必须是一个寄存器。

  对于一些寄存器中存储的是内存地址，这个指令就体现出加载有效地址的作用。它没有将操作数所指向的内存的值读入，而是直接将地址写入到目标操作数。

  对于一些寄存器中存储的是数值，那么这条指令可以起到算术运算的作用。

* 移位操作

  移位量的编码范围可以达到255。

* 支持全128位乘积

  imul 单操作数 指令，要求一个参数必须在%rax寄存器中，另一个作为源操作数给出。乘积会存放在%rdx(高64位)和%rax(低64位)

#### 条件跳转

* 有两种方式：
  1.  条件控制转移，即当条件满足时，走一条路径，不满足时走另一条路径。
  2. 条件数据传送，计算一个条件操作的两种结果，然后再根据条件是否满足，选取其中一个。

##### 条件控制跳转

 * 流程
   1. 条件表达式的指令（算术、逻辑、比较、测试）设置条件码的值。
   2. 跳转指令根据条件码（或组合）来决定是否跳转到目的地址的指令位置，从这个位置继续执行程序。

###### 条件码

​	除了lea指令，其他的指令都会设置条件码。

 * 作用
   1. 根据条件码的某种组合来设置一个字节的值为0、1、2（如SET指令）
   2. 条件跳转
   3. 条件传送数据

###### 跳转指令

* 根据目标指令的地址跳转到该位置，让程序从该位置继续执行。

 * 目标编码

   1. PC相对

      目标指令地址和后面一条指令的地址的差作为编码。通过将跳转指令的目标编码加上下一条指令的地址，就得到了目标指令的地址。

      这样做的好处是：1.指令代码很简洁。2.由于是相对地址，不受内存地址改变的影响。

   2. 绝对地址

      直接根据给定的地址确定目标。

##### 条件控制跳转和条件数据传送对比

  * 条件控制跳转伴随着处理器的分支预测逻辑。因为处理器会通过流水线来获得高性能，事先确定要执行的指令序列，让流水线中充满指令。在遇到条件（即分支）时，便会通过分支预测来猜测跳转指令是否会执行，并将它放到流水线中。但是，如果预测错误，处理器会丢弃跳转指令后所有指令已做的工作，重新从正确的位置开始执行，导致性能下降。称为条件预测惩罚。所以依赖条件预测的结果，条件控制跳转的性能可能会不如条件数据传送。

    疑问：条件预测惩罚是否意味着需要寄存器或内存的值的进行回滚，所以才会导致性能下降？

  * 条件数据传送是会计算两个条件表达式的代码序列的值，然后根据条件码的值，决定选择哪个值作为最终值。不是所有的条件表达式都适合条件数据传送，例如条件表达式中任何一个代码序列如果会导致错误条件或副作用。或两个条件表达式的计算需要大量的时间。

*  条件数据传送作为条件控制跳转的替代策略，更符合处理器的运行方式。但是使用场景受限。

##### 联合的作用

	* 一个联合的大小等于其中最大字段的大小

	* 如果一个数据结构中两个字段使用是互斥的，将这两个字段声明为联合的一部分，减小分配空间。
	* 用来访问不同数据类型的位模式。

##### 数据对齐

	* 对齐的是数据的地址。
	* 保证数据对齐能提高处理器效率。假设没有进行数据对齐，处理器读取一个数据类型大小的数据，则可能只读到一半，另一半在下一个数据块中。就需要访问多次内存，降低了效率。

​	



​	







