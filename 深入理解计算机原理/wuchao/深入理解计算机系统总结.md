### 概述

计算机系统由硬件和软件组成，共同工作来完成程序的运行，从而完成某些功能。理解计算机是如何工作的，我们的程序是如何运行的，最直接的目的，就是提升程序的运行效率。

#### 抽象

抽象作为一种分析问题和事物的方法。总结出他们的特性、行为、功能，可能创造出一个实际不存在的概念，但它可以帮我们更好的理解事物的具体是怎么工作，也方便我们记忆。

例如：处理器的抽象->指令集架构，存储设备的抽象(内存、io设备)->虚拟内存，io设备的抽象->文件，程序的抽象->进程。

#### 计算机做什么事

 * 运行程序，通过分析程序的是怎么运行及运行时计算机各个部分是怎么变化的，就可以知道计算机的工作原理了。

 * 程序由什么组成：指令 + 数据

* 细化一下的工作

  * 处理器处理指令

    处理器体系结构相关

  * 从存储设备取数据，写入数据到存储设备

    io设备、存储器、虚拟内存相关

  * 管理程序

    进程、逻辑流、异常流相关

* 程序的表示

  程序代码和机器代码。

  为什么分为两种形式呢？直接用统一的形式不行么？是为了效率，机器代码为了执行的效率，处理器不用管具体的业务是什么，只用管取指令，执行指令，写数据即可。高级语言是为了我们能看得懂，提高编写程序的效率。将我们的程序代码翻译为机器代码的过程就是编译系统干的事。

#### 程序的表示

​		程序运行前会从源代码由编译过程转变到机器代码。为什么分为两种形式呢？直接用统一的形式不行么？是为了效率，机器代码为了执行的效率，处理器不用管具体的业务是什么，只用管取指令，执行指令，写数据即可。高级语言是为了我们能看得懂，提高编写程序的效率。

	* 编译

​	源程序经过编译会先生成为可重定向的目标文件，然后再经过链接过程到最终的可执行目标文件。	

​	编译会经过词法分析，语法分析，语义分析，生成汇编代码，汇编代码即是机器代码的文本形式。汇编代码经过汇编器会生成可重定位的目标文件。之所以叫可重定位，是因为要交给链接器，进行重定位过程，将代码链接到一起。

 * 链接

   链接即是将各种代码和数据片段收集并组合成为一个单一文件的过程。它包含两个非常重要的过程：符号解析和重定位。

   * 符号解析

     一个符号对应一个变量或者是函数。符号解析的过程即是把符号的引用和符号的定义关联起来。可以说符号的定义和符号的引用是分开的。引用到的符号才需要和定义关联起来。

   * 重定位

     代码当中使用的数据和指令，最终要使用的话，需要知道他们的确切地址，那么就需要将这些符号引用指向正确的地址，这个修正地址的过程就叫重定位。

   * 动态链接

     在程序运行或加载时，再将目标模块加载到内存中，然后将其和程序链接起来。这里有一个概念，与位置无关代码，即可被加载而无需重定位的代码段。

     与位置无关的代码如何解决引用指向地址的问题呢？

     * 数据引用

       利用数据段和代码段的相对距离是不变的特性。在数据段开始的地方生成全局偏移量表(GOT)。在加载时，动态链接器通过重定位GOT中的每个条目，生成目标的绝对地址。

     * 过程引用

       通过延迟绑定技术，GOT和过程链接表(PLT)来协作。

   * 静态链接和动态链接的对比

      * 静态链接生成的代码维护起来麻烦，如果目标文件做了变动，就需要重新链接。
      * 相同的目标文件被链接到多个程序中，造成内存资源的浪费。
     * 动态链接的高灵活性，是以牺牲性能为代价的。数据和过程的引用需要根据GOT相对寻址。因此比静态链接耗费更久的时间。

#### 程序的执行

​	程序的执行则涉及到CPU指令的处理，就离不开CPU体系结构，涉及到数据的存取，就离不来存储的结构，虚拟内存的使用。

 * CPU 指令的处理过程

   根据PC的值从内存中取出指令字节。将取出的指令字节中寄存器指示符代表的寄存器中的操作数。算数或逻辑运算。从内存读取数据或写入数据到内存。将结果写回到寄存器。将PC设置为下一条指令的地址。

*  CPU的流水线设计

   细化指令的处理阶段，将多个指令的处理阶段重叠，引入流水线寄存器，阶段的执行结果在流水线寄存器保存，不同指令的不同阶段的操作可以在同一时间进行。这样就加大了单位时间内指令的处理量。

*  存储结构

   存储器层次结构是从处理器到网络，越靠近cpu的存储器层次越高，读写速度更快，存储容量小，造价更高。高层次的存储器作为低层次存储器的高速缓存。类似一个金字塔的结构。

   * 局部性的概念

     程序更倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。即指离处理器更近的存储器中的数据更频繁的被使用到，这意味着更倾向于从存储层次高的存储器中读写数据。这种倾向的目的即是让处理器的处理效率更高。

*  虚拟内存

   为了更好的管理内存，引入一个抽象的概念，虚拟内存。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件共同完成的。目的是为了：1. 将主存视为磁盘的高速缓存，主存只保留活动区域，主存和磁盘来回传送数据，更高效的访问内存。2.为每个进程提供独立的地址空间，使其不被破坏。3. 简化内存管理

   * 内存映射

     将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容。即使对象被映射到 了多个共享区域，物理内存中也只需要存放对象的一个副本。这样就节省了内存。

   * 动态的内存分配

     程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数 据结构的大小。动态内存分配是在一个叫堆(heap)的内存区域上进行的。

#### 程序间的交互

 * 进程

   处理器执行进程A的某个指令，然后再去执行进程B的某个指令，所有程序的指令就这样交替的执行着。进程是运行程序的抽象，让我们以为我们的程序是在独占处理器和存储设备。这种抽象概念助于我们分析程序的交互。

* 进程的切换

  进程的切换即伴随着进程上下文的切换，用户模式到内核模式的改变，上下文保存着进程的状态。例如寄存器状态、用户栈、内核栈和各种内核数据结构等。

* 异常

  我的理解异常就是一种通信的方式。传递这某种信息，希望这种信息被相应的接受和处理。

  内核和进程间通信可以通过异常(中断、系统调用)，程序之间也可以通过异常通信(发送信号)。

* 并发

  并发可看做是一种操作系统内核用来运行多个应用程序的机制。

  * 进程并发

    每个逻辑控制流都是一个线程，由内核来调度和维护。多个逻辑控制流间通信，需要用进程间通信技术（IPC），因为每个进程拥有独立的虚拟地址空间。

  * IO多路复用并发

    应用程序在一个进程的上下文中显式地调度自己的逻辑控制流。所有的流共享一个地址空间。控制流可以模型化为状态机。逻辑流的推进就是状态机的转换。

  * 线程并发

    线程单一进程上下文中的逻辑流，由内核进行调度，共享同一个虚拟地址空间，例如地址空间代码、数据、堆、共享库、打开的文件。线程并发可以说是进程并发和IO的结合体。

    * 内存模型

      寄存器的值和栈空间是线程独享的，而虚拟内存总是共享的。全局变量每个对等的线程都共享这个变量的实例。局部变量每个线程私有。

    * 同步

      共享变量的方便，但多线程共享同一个变量，执行，得到的结果可能是错误的。这个时候就需要同步处理。例如用信号量实现互斥同步，即实现了有一个锁，拿到锁的线程才能访问到变量，访问完变量之后释放锁，这样其他线程就可以访问变量了。

      引入同步会带来额外的问题，例如死锁，即被锁阻塞的线程，等待锁的释放去获得锁，但是这个锁永远也释放不了。给定所有互斥操作一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

    * 线程安全

      线程操作的问题引申出来线程安全的概念，一个函数被称为线程安全的，是指被多个并发线程反复调用时，会一直产生正确的结果。达到线程安全的手段可以是互斥锁或不引用共享变量。

    





​	













