**现代系统通过使控制流发生突变来对这些情况作出反应，一般而言，这些突变成为异常控制流**

**异常控制流发生在计算机系统的各个层次**
- 在硬件层，硬件检测到的时间会触发控制突然转移到异常处理程序。
- 在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。
- 在应用曾 哟个进程发送信号到另一个进程，而接受者会将控制突然转移到他的一个信号处理程序。


## 异常

**异常就是控制流中的突变，用来响应处理器状态中的某些变化。**

任何情况下，当处理器监测到有事件发生时，就会通过一张佳偶哦异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这列时间的操作系统子程序，异常处理器。
- 处理程序将控制返回给当前指令，即当事件发生时正在执行的指令
- 处理程序将控制返回给I next，如果没有发生异常将会执行的下一条指令
- 处理程序终止被中断的程序
### 异常处理

系统中可能的每种类型的异常都分配了一个位置的非负数的异常号（处理器分配，操作系统分配）

**异常类似于过程调用，但是有一些重要的不同之处**

- 过程调用是，在跳转到处理器程序之前，处理器将返回地址压入栈中，然而根基异常的类型，返回地址要么是当前指令，要么是下一条指令。
- 处理器也会那一些额外的处理器状态压倒栈里，当前处理程序返回时，重新开始执行被中断的程序回需要这些状态
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中
- 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都可以完全访问。


### 异常的类别


类别| 原因|同步/异步|返回行为
---|---|---|---|---
中断 | 来自I/O的设备信号|同步|总是返回到下一条指令
陷阱 | 有意的异常|同步|总是返回到下一条指令
故障|潜在的可恢复的错误|同步|可能返回到当前指令
终止|不可恢复的错误|同步|不会返回

## 进程

进程提供给应用程序的关键抽象
- 一个独立的逻辑控制流，提供了程序独占了处理器的假象
- 一个私有的地址空间，提供了应用程序独占了内存系统的假象

### 逻辑控制流
程序计数器值的序列叫做逻辑控制流
### 并发流


- 一个逻辑流的执行在时间上与另一个流重叠称为并发流，这两个流并发运行。

- 多个流并发的之心的现象叫做并发。
- 一个进程和其他进程轮流运行的盖脸为多任务
- 一个进程执行它的控制柳的一部分的每一个时间段叫做时间片

### 私有地址空间

每个进程为每个程序提供它自己的私有地址空间，和这个空间的某个地址相关联的那个内存字节是不能被其他进程读写的，这个地址是私有的。
### 用户模式和内核模式


### 上下文切换

操作系统使用一种称为上下文切换的较高形式的异常控制流来实现多任务。

内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态：
- 目的寄存器
- 浮点寄存器
- 程序计数器
- 用户栈
- 状态寄存器
- 内核栈
- 各种数据结构

## 系统调用错误处理

## 进程控制

每一个进程都有唯一一个正数进程ID
- getpid 获取进程id
- getppid 获取父进程id


### 创建和终止进程

从程序员的角度来看 进程总是处于下面三个状态
- 运行 在CPU执行，或者等待被执行且最终会被调用
- 停止 进程的执行被挂起，且不会被调度。当收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU时，进程就会停止，接收到SIGCONT信号，再次开始运行
- 终止 进程永远停止了
  -  收到一个终止信号
  -  从主程序返回
  -  调用exit函数


**新创建的子进程几乎单不完全与父进程相同**。
- 子进程得到和父进程用户级虚拟地址空间相同的一个副本，包括代码和数据段 堆 共享库以及用户栈
- 获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程中打开的任何文件

**fork函数调用一个返回两次**
- 在父进程中返回，返回子进程ID
- 在子进程中返回，返回0

**并发执行**

- 父进程和子进程是并发运行的独立进程

**相同但是独立的地址空间**

**共享文件**
### 回收子进程

当一个进程终止时，内核并不是立即把它从系统中清除，相反进程被保持一种已终止的状态中，知道被父进程回收

**如果一个父进程终止了，init进程会去回收**


#### waitpid

一个进程可以通过waitpid函数来等待它的子进程终止或停止。


### 加载并运行程序

**execve函数在当前进程的下文中加载并运行一个新程序**


```
int execve(const char *filename,const char *argv[],const char *envp[])

如果成功不返回，如果失败 返回-1.
```
execve 函数加载并运行可执行目标文件


## 信号

一个信号就像一条消息，他通知进程刺痛中发生的一个某种类型的事件，它允许进程和内核中断其他进程。

### 发送信号

Unix系统提供了大量向进程发送信号的机制，所有的这些机制都是基于进程组这个概念

- 进程组

  - 默认的一个子进程和父进程同属于一个进程组
  - getpgrp 获取进程组ID
  - setpgid 设置进程组


- 用/bin/kill/程序发送信号
- 从键盘发送信号
- 用kill函数发送信号
- 用alarm函数发送信号


### 接收信号

每个信号都有一个预定义的默认行为
- 进程终止
- 进程终止并转储内存
- 进程停止知道被SIGCONT信号重启
- 进程忽略该信号

### 阻塞和解阻塞信号

**Linux提供了隐式和显式的机制**

- 隐式阻塞机制：内核弄人阻塞任何当前处理程序正在处理信号类型的待处理信号
   
- 显示阻塞机制：应用程序可以使用sigprocmask函数和他的辅助函数，明确地阻塞和接触阻塞选定信号


## 非本地跳转

C语言提供了一种用户级异常控制流形式，称为非本地跳转，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。