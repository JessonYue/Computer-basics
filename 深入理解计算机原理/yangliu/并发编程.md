## 基于进程的并发编程
- 每个客户端由独立子进程处理
  - 必须回收僵尸进程，来避免严重的内存泄露
- 不同进程之间不共享数据
- 父进程和子进程都有 listenfd 和 connfd，所以在父进程中需要关闭 connfd，在子进程中需要关闭 listenfd
  - 内核会保存每个 socket 的引用计数，在 fork 之后 refcnt(connfd) = 2，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零

## 基于I/O多路复用的并发编程

使用select函数，要求内核挂起进程，只有在一个或多个IO事件发生后，才将控制返回给应用程序。

## 基于线程的并发编程
- 和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。

- 每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈，但是会共享所有的代码、数据以及内核上下文。
## 多线程程序中的共享变量
## 用信号量同步线程
## 使用线程提高并行性