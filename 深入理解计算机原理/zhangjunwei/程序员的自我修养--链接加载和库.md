### 第一章

- 二元信号量（**Binary** **Semaphore** ) 

  > 是最简单的一种锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号罱置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。

- 多元信号量简称信号量（**Semaphore**)

  > 允许多个线程并发访问的资源。一个初始值为 **N** 的信号量允许 **N** 个线程并发访问。线程访问资源的时候首先获取信号量

  - 将信号量的值减 1 
  - 如果信号景的值小于 0, 则进入等待状态，否则继续执行。
  - 访问完资源之后，线程释放信号量，进行如下操作：
    - 将信号量的值加 1。
    - 如果信号量的值小于 1, 唤醒一个等待中的线程。

- 互斥量（**Mutex**)和二元信号量
  - 资源仅同时允许一个线程访问，但和信号量不同的是，信号最在整个系统中可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后可以由另一个线程释放。而互斥量则要求哪个线程获取了互斥暈，哪个线程就要负责释放这个锁，其他线程释放互斥量是无效的。

- 临界区（**Critical** **Section**) 是比互斥量更加严格的同步手段。
  - 把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区和互斥量与信号量的区别在与互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号**M**,另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他的进程无法获取该锁。除此之外. 临界区具有和互斥量相同的性质。
- 读写锁（**Read-Write** **Lock**) 
  - 适用场景对于读取频繁，而仅仅偶尔写入的情况
  - 于同一个锁，读写锁有两种获取方式，共享的（**Shared**)或独占的（**Exclusive** )
- 条件变量（**Condition** **Variable** ) 作为一种同步手段，作用类似于一个栅栏

### 第三章

使用 file 命令来查看相应的文件格式

```shell
//*.o 为可重定位文件
file ./bash 
./bash: Mach-O 64-bit executable x86_64
file native-lib.cpp.o 
native-lib.cpp.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), with debug_info, not stripped
file libnative-lib.so 
libnative-lib.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[sha1]=8e0c203c8f85ef2b45bc4444639b53a64f6465f2, stripped
```

#### 目标文件是什么样的