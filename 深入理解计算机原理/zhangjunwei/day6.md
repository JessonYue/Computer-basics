#### 第七章

预处理器---> 编译器---> 汇编器 ---> 链接器

> 链接 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

##### 链接器

链接器的两个主要任务

- 符号解析
  - 将目标文件中的每个全局符号都绑定到一个唯一的定义
- 重定位
  - 确定每个符号的最终内存地址，并修改对那些目标的引用

> 静态链接器  是由像 GCC 这样的编译驱动程序调用的

链接可执行于：

- 编译时  源代码被翻译成机器代码（二进制文件）-- 由静态编译器完成
- 加载时  程序被加载器加载到内存并执行 --- 由动态链接器完成
- 运行时  由应用程序来执行 --- 由动态链接器完成

连接器如何使用静态库来解析引用

被依赖的文件 库要 置于 引用文件或库的 后面 （即先引用后定义）

##### 动态链接共享库

> 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的代码，节约宝贵的内存资源

位置无关代码（Position-Independent Code, PIC）

- 现代系统以这样一种方式编译共享模块的代码片段，使得可以把它们加载到内存的任何位置而无需链接器修改。无限多个进程可以共享一个共享代码段的单一副本。
- GCC  使用-fpic选项 指示 GNU 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。

- 共享库（共享目标文件）是一个目标模块
  - 在运行时由动态链接器链接和加载
  - 隐含地在调用程序被加载和开始执行时
  - 根据需要在程序调用`dlopen`库中的函数时
- 动态链接  由动态链接器执行的。  在运行时或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。

##### 加载器

> 将可执行文件的内容映射到内存，并运行这个程序。

##### 库打桩机制

> 允许用户截获对共享库函数的调用，取而代之执行自己的代码。

- 目标函数
- 包装函数  原型与目标函数完全一样

打桩可以发生在

- 编译时 -- 需要能够访问源代码
- 链接时 -- 需要能够访问程序的可重定位对象文件
- 当程序被加载时
- 运行时 -- 需要能够访问可执行目标文件 
  - 基于动态链接器的 LD_PRELOAD环境变量

打桩应用场景

- 追踪某个特殊库函数的调用次数
- 验证和追踪库函数的输入输出值
- 替换库函数的实现