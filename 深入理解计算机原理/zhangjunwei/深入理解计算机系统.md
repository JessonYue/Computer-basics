![](img/%E5%9B%BE1-18.png)



强制类型转换不会改变真实的指针，只是告诉编译器以新的数据类型来看待被指向的数据。

### 第三章

- 程序计数器 PC  -->  %rip
  - 将要执行的下一条指令在内存中的地址
- 整数寄存器文件包含16个命名的位置，分别存储64位的值。存储地址（C 语言的指针）、整数数据、记录某些重要程序状态、保存临时数据（过程的参数、局部变量、函数返回值）
- 条件码寄存器  保存最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化。比如用来实现 if和 while 语句。
- 一组向量窥阴器  可以存放一个或多个整数或浮点数值。

```c
//mstore.c
long mult2(long, long );
void multstore(long x,long y, long *dest){
    long t = mult2(x,y);
    *dest = t;
}
```

```c
//main.c
#include <stdio.h>
void multstore(long x, long y, long *dest);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 ---> %ld\n",d);
    return 0;
}
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

gcc -Og -o prog main.c mstore.c  生成 prog 可执行文件

 objdump -d prog  反汇编

```asm
prog:	file format Mach-O 64-bit x86-64

Disassembly of section __TEXT,__text:
__text:
100000f10:	55 	pushq	%rbp
100000f11:	48 89 e5 	movq	%rsp, %rbp
100000f14:	48 83 ec 10 	subq	$16, %rsp
100000f18:	48 8d 55 f8 	leaq	-8(%rbp), %rdx
100000f1c:	bf 02 00 00 00 	movl	$2, %edi
100000f21:	be 03 00 00 00 	movl	$3, %esi
100000f26:	e8 35 00 00 00 	callq	53 <_multstore>
100000f2b:	48 8b 75 f8 	movq	-8(%rbp), %rsi
100000f2f:	48 8d 3d 64 00 00 00 	leaq	100(%rip), %rdi
100000f36:	31 c0 	xorl	%eax, %eax
100000f38:	e8 3b 00 00 00 	callq	59 <dyld_stub_binder+0x100000f78>
100000f3d:	31 c0 	xorl	%eax, %eax
100000f3f:	48 83 c4 10 	addq	$16, %rsp
100000f43:	5d 	popq	%rbp
100000f44:	c3 	retq
100000f45:	66 2e 0f 1f 84 00 00 00 00 00 	nopw	%cs:(%rax,%rax)
100000f4f:	90 	nop
100000f50:	55 	pushq	%rbp
100000f51:	48 89 e5 	movq	%rsp, %rbp
100000f54:	48 89 f8 	movq	%rdi, %rax
100000f57:	48 0f af c6 	imulq	%rsi, %rax
100000f5b:	5d 	popq	%rbp
100000f5c:	c3 	retq
100000f5d:	90 	nop
100000f5e:	90 	nop
100000f5f:	90 	nop
100000f60:	55 	pushq	%rbp
100000f61:	48 89 e5 	movq	%rsp, %rbp
100000f64:	53 	pushq	%rbx
100000f65:	50 	pushq	%rax
100000f66:	48 89 d3 	movq	%rdx, %rbx
100000f69:	e8 e2 ff ff ff 	callq	-30 <_mult2>
100000f6e:	48 89 03 	movq	%rax, (%rbx)
100000f71:	48 83 c4 08 	addq	$8, %rsp
100000f75:	5b 	popq	%rbx
100000f76:	5d 	popq	%rbp
100000f77:	c3 	retq

_main:
100000f10:	55 	pushq	%rbp
100000f11:	48 89 e5 	movq	%rsp, %rbp
100000f14:	48 83 ec 10 	subq	$16, %rsp
100000f18:	48 8d 55 f8 	leaq	-8(%rbp), %rdx
100000f1c:	bf 02 00 00 00 	movl	$2, %edi
100000f21:	be 03 00 00 00 	movl	$3, %esi
100000f26:	e8 35 00 00 00 	callq	53 <_multstore>
100000f2b:	48 8b 75 f8 	movq	-8(%rbp), %rsi
100000f2f:	48 8d 3d 64 00 00 00 	leaq	100(%rip), %rdi
100000f36:	31 c0 	xorl	%eax, %eax
100000f38:	e8 3b 00 00 00 	callq	59 <dyld_stub_binder+0x100000f78>
100000f3d:	31 c0 	xorl	%eax, %eax
100000f3f:	48 83 c4 10 	addq	$16, %rsp
100000f43:	5d 	popq	%rbp
100000f44:	c3 	retq
100000f45:	66 2e 0f 1f 84 00 00 00 00 00 	nopw	%cs:(%rax,%rax)
100000f4f:	90 	nop

_mult2:
100000f50:	55 	pushq	%rbp
100000f51:	48 89 e5 	movq	%rsp, %rbp
100000f54:	48 89 f8 	movq	%rdi, %rax
100000f57:	48 0f af c6 	imulq	%rsi, %rax
100000f5b:	5d 	popq	%rbp
100000f5c:	c3 	retq
100000f5d:	90 	nop
100000f5e:	90 	nop
100000f5f:	90 	nop

_multstore:
100000f60:	55 	pushq	%rbp
100000f61:	48 89 e5 	movq	%rsp, %rbp
100000f64:	53 	pushq	%rbx
100000f65:	50 	pushq	%rax
100000f66:	48 89 d3 	movq	%rdx, %rbx
100000f69:	e8 e2 ff ff ff 	callq	-30 <_mult2>
100000f6e:	48 89 03 	movq	%rax, (%rbx)
100000f71:	48 83 c4 08 	addq	$8, %rsp
100000f75:	5b 	popq	%rbx
100000f76:	5d 	popq	%rbp
100000f77:	c3 	retq
Disassembly of section __TEXT,__stubs:
__stubs:
100000f78:	ff 25 82 10 00 00 	jmpq	*4226(%rip)
Disassembly of section __TEXT,__stub_helper:
__stub_helper:
100000f80:	4c 8d 1d 81 10 00 00 	leaq	4225(%rip), %r11
100000f87:	41 53 	pushq	%r11
100000f89:	ff 25 71 00 00 00 	jmpq	*113(%rip)
100000f8f:	90 	nop
100000f90:	68 00 00 00 00 	pushq	$0
100000f95:	e9 e6 ff ff ff 	jmp	-26 <__stub_helper>
```

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小（字节） |
| :----: | -------------- | :----------: | ------------ |
|  char  | 字节           |      b       | 1            |
| short  | 字             |      w       | 2            |
|  int   | 双字           |      l       | 4            |
|  long  | 四字           |      q       | 8            |
| char*  | 四字           |      q       | 8            |
| float  | 单精度         |      s       | 4            |
| double | 双精度         |      l       | 8            |

#### 通用目的寄存器

CPU 包含16个64位值的通用目的寄存器

每个寄存器 可以分别存放字节（8位）、字（16位）、双字（32位)、四字（64位）  

![](img/%E5%9B%BE3-2.png)

#### 3.4.1操作指示符

![](img/%E5%9B%BE3-3.png)

> 这里的知识涉及到汇编，而汇编往往和硬件很有关系，比如X86或者ARM的指令是不一样的。这张图我们需要理解几个概念：  1.汇编中出现的数据有立即数（**$52、$0x11等**）、寄存器里面的数据。【上图是用Ea来表示任意寄存器a,用引用 R[Ea]来表示它的值。】存储器里面的数据（可以理解很大的字节数组）。  2.比如最后1行的存储器 Imm（r,r,s）,我们可以这样解读  Imm 是立即偏移数、Eb 是基址寄存器、Ei 是变址寄存器、s 是比例因子，必须是 1、2、4或8  那么在汇编中 我们可以看到2(%esp,%eax,4)这个操作数的意思是：地址为2+%esp+4*%eax的存储器区域的值。 所以你应该明白这张表的意思 表达的就是在底层最为重要的offset。也就是指针偏移，这张表对应的是X86的汇编格式，针对ARM是不一样的，具体可以查ARM的汇编指令。暂时了解这个概念就可以了，ARM指令我们暂时不做逆向，可以不要花太多精力

数据传送  源数据的位数 <= 目的位置的容量位数

- MOVZ 零扩展  用0来填充
- MOVS 符号扩展  有源数据的最高位进行填充

##### 入栈 出栈

栈的大小是有限的   栈底 --> 栈顶 地址是减小的

入栈%rsp（栈指针值减8  存放一个指针需要8个字节）

出栈%rsp栈指针值加8）

![](img/%E5%9B%BE3-10.png)



leaq  为 movq 的变形

```
比如 %rdx 的值为 x
leaq7(%rdx,%rdx,4), %rax  == 4*x+x+7存储到%rax
```



C 语言中数组 malloc alloca 等 缺少边界

检查机制  容易造成缓冲区溢出  黑客可以此为突破口入侵系统 

程序离不开地址  地址指引指令的执行 （数据的存储行为也是指令）

黑客可以通过地址执行自己想的操作。

### 第五章优化程序性能

1. 选择适当的算法和数据结构
2. 处理运算量特别大的计算，采用并性充分利用多核 CPU
3. 消除不必要的内存引用（如在循环中操作外部传入的指针），函数调用（不要在循环判断中调用函数）。用三目运算符（？：）替代 if-else



程序中空间局部性的好的情况下  时间局部性不一定好。时间局部性好的程序空间局部性不一定好。要看应用场景来采取相应的策略，以空间换时间或者以时间换空间。

用高速缓存命中率和不命中率来量化局部性的概念

### 第七章

预处理器---> 编译器---> 汇编器 ---> 链接器

> 链接 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

#### 链接器

链接器的两个主要任务

- 符号解析
  - 将目标文件中的每个全局符号都绑定到一个唯一的定义
- 重定位
  - 确定每个符号的最终内存地址，并修改对那些目标的引用

> 静态链接器  是由像 GCC 这样的编译驱动程序调用的

链接可执行于：

- 编译时  源代码被翻译成机器代码（二进制文件）-- 由静态编译器完成
- 加载时  程序被加载器加载到内存并执行 --- 由动态链接器完成
- 运行时  由应用程序来执行 --- 由动态链接器完成

连接器如何使用静态库来解析引用

被依赖的文件 库要 置于 引用文件或库的 后面 （即先引用后定义）

#### 动态链接共享库

> 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的代码，节约宝贵的内存资源

位置无关代码（Position-Independent Code, PIC）

- 现代系统以这样一种方式编译共享模块的代码片段，使得可以把它们加载到内存的任何位置而无需链接器修改。无限多个进程可以共享一个共享代码段的单一副本。
- GCC  使用-fpic选项 指示 GNU 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。

- 共享库（共享目标文件）是一个目标模块
  - 在运行时由动态链接器链接和加载
  - 隐含地在调用程序被加载和开始执行时
  - 根据需要在程序调用`dlopen`库中的函数时
- 动态链接  由动态链接器执行的。  在运行时或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。

#### 加载器

> 将可执行文件的内容映射到内存，并运行这个程序。

#### 库打桩机制

> 允许用户截获对共享库函数的调用，取而代之执行自己的代码。

- 目标函数
- 包装函数  原型与目标函数完全一样

打桩可以发生在

- 编译时 -- 需要能够访问源代码
- 链接时 -- 需要能够访问程序的可重定位对象文件
- 当程序被加载时
- 运行时 -- 需要能够访问可执行目标文件 
  - 基于动态链接器的 LD_PRELOAD环境变量

打桩应用场景

- 追踪某个特殊库函数的调用次数
- 验证和追踪库函数的输入输出值
- 替换库函数的实现

#####

### 第八章异常控制流

> 异常控制流(ECF Exceptional Control Flow)发生在计算系统的各个层次（==硬件层和软件层==），是计算机系统中提供并发的基本机制。

#### 控制流

> a~k~是相应指令I~k~的地址。a~k~到a~k+1~的过渡叫控制转移
>
> a~0~，a~1~，a~2~，a~3~....a~n~这样的序列叫控制流

- 程序计数器（PC）中存储的值a~k~（下一条指令I~k~的地址）的改变
  - I~k~和I~k+1~在内存是相邻的  称为平滑流
  - I~k~和I~k+1~在内存不是相邻的  称为平滑流的突变
    - 跳转、调用、返回

#### 异常

> 控制流中的突变，用来响应处理器状态中的某些变化 。
>
> 在处理器中状态被编码为不同的位和信号。状态变化称为事件。

##### 异常处理

- 异常号 为非负整数  
  - 处理器的设计者分配的
    - 被零除、缺页、内存访问违例、断点、算术运算溢出
  - 操作系统内核（操作系统常驻内存的部分）的设计者分配的
    - 系统调用、来自外部的 I/O 设备的信号

##### 硬件层

###### 异常分类

- 中断
  - 外部 I/O 设备设置了处理器的中断管脚时，中断会异步地发生。
- 故障  同步发生
  - 控制返回到故障指令后面的那条指令。
  - 故障处理程序会重新启动故障指令（==？==）
- 终止  同步发生
  - 从不将控制返回给被中断的流
- 陷阱
  - 应用程序进行系统调用的入口，换句话来说就应用程序调用系统服务的入口。（应用程序到系统代码的受控入口点）
    - 例如 向磁盘读写数据，从网络读取数据，创建一个新进程，终止当前进程都是应用程序通过调用系统服务来完成的。

##### 操作系统层

> 内核用 ECF提供进程的的基本概念
>
> 在操作系统和应用程序之间的接口处（系统调用）应用程序可以创建子进程，等待它们的子进程停止或终止，运行新的程序，以及捕获来自其他进程的信号。
>
> ECF 是实现并发的基本机制。

进程提供给应用两个重要的抽象

- 逻辑控制流
  - 提供给每个程序一个假象，好像它是独自的使用处理器
- 私有地址空间
  - 提供给每个程序一个假象，好像它是独占主存



#### 8.5信号

pending位向量

POSIX.1定义了数据类型sigset_t来表示或保存多个信号——信号集（signal set），信号掩码就存放在这些信号集中。POSIX定义了下列5个处理信号集的函数。

- int sigemptyset(sigset_t *set) 
  - 初始化由set指向的信号集，清除其中所有信号，即设置所有信号掩码的阻塞标志

- int sigfillset(sigset_t *set) 
  - 初始化由set指向的信号集，使其包括所有信号，即清除所有信号掩码的阻塞标志

- int sigaddset(sigset_t *set, int signo) 
  - 将一个特定信号signo添加到set指向的信号集中，可用于增加个别信号阻塞

- int sigdelset(sigset_t *set, int signo) 
  - 从set指向的信号集中删除一个特定信号signo，可用于删除个别信号阻塞
- int sigismember(const sigset_t *set, int signo)
  -  检查某个信号是否在set指向的信号集中，可确定特定的信号是否在掩码中被标志为阻塞。

- sigprocmask()
  - 来检测和更改其当前的信号掩码，以便告诉内核不允许触发该信号集中的信号。



