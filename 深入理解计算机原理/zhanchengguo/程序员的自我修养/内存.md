#### 内存

 - 10.1、程序的内存布局

   	- 应用程序可以直接使用32位的地址进行寻址，这 称为平坦的内存模型。在平坦的内存模型中，整个内存是一个统一的地址空间，可以使用32位指针访问任意内存位置
    - 应用程序使用的内存空间的默认区域：
      	1. 内核空间
       	2. 栈
       	3. 保留区
       	4. 共享库
       	5. 堆 ： 容纳应用程序动态分配的内存区域
       	6. 可读可写文件
       	7. 只读文件

 - 10.2、栈与调用惯例

   	- 栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈），也可以将已经压入栈中的数据弹出（出栈），但栈这个容器必须遵循一条规则：先入栈的数据后出栈（FIFO）
   	- 在经典的操作系统里，栈总是向下增长的（栈顶在底部）
    - 栈保存了一个函数调用所需要的维护信息，称为堆栈帧或者活动记录，包括：
      	1. 函数的返回地址和参数
       	2. 临时变量
       	3. 保存的上下文
   - 活动记录存在ebp和esp寄存器划定范围。esp寄存器始终指向栈顶，ebp寄存器指向活动记录的一个固定位置
   - 函数调用方和被调用方对于函数如何调用须要有一个明确的约定，只有双方都遵守同样的约定，函数才能被正确的调用，这样的约定称为调用惯例。规定包括：
     	1. 函数参数的传递顺序和方式（通过栈传递或者通过寄存器传递）
      	2. 栈的维护方式
      	3. 名字修饰的策略
   - C语言中存在多个调用惯例，默认的调用惯例是cdecl，内容为参数传递：从右至左的顺序压参入栈；出栈方：函数调用方；名字修饰：函数名称前加1个下划线

- 10.3、堆与内存管理

  - 堆是一块巨大的内存空间，占据整个虚拟空间的绝大部份
  - 进程的地址空间中，除了可执行文件，共享库，栈之外，剩余的未分配的空间都可以被用来做堆空间
  - Linux系统的进程堆管理提供两种堆空间的分配方式（两个系统调用）
    	1. brk()系统调用：设置进程数据段的结束地址，可以扩大或者缩小数据段
     	2. mmap()：向操作系统申请一段虚拟地址空间，当它不将地址空间映射到某个文件时，称为匿名空间，可以作为堆空间
  - malloc最大的申请空间大约是2GB不到
  - 堆分配算法：如何管理一大块连续的内存空间，能够按照需求分配、释放其中的空间
  - 简单的堆分配算法：
    	1. 空闲链表：把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，遍历整个列表，直到找到合适大小的块并且将它拆分：当用户释放空间时将它合并到空闲链表中
     	2. 位图：将整个堆分为大量的块，每个块大小相同，每个块只有头/主体/空闲三种状态
         	- 仅需两位数即可表示一个块（11表示H 头；10表示B  主体；00表示F 空闲）
         	- 优点：1、速度快；2、稳定性好；3、块不需要额外信息，易于管理
         	- 缺点：1、分配内存的时候容易产生碎片；2、如果堆很大或者设定的块很小，那么位图很大，失去cache的命中率高的优势，浪费一定的空间
     	3. 对象池

  

