#### 系统级I/O

- 输入/输出（I/O）是在主存和外部设备之间复制数据的过程。输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备
- 学习Unix I/O
  	1. 了解Unix I/O将帮助你理解其他的系统概念
   	2. 有时你处理使用Unix I/O以外别无选择
- 将设备优雅地映射位文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，使得所有的输入和输出都能以一种统一且一致的方式来执行：
  	1. 打开文件
   	2. Linux shell 创建的每个进程开始都有三个打开的文件：标准输入、标准输出、标准错误
   	3. 改变当前的文件位置
   	4. 读写文件
   	5. 关闭文件
- 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫描述符，它在后续对此文件的所有操作中标识这个文件
- 每个Linux文件都有一个类型（type）表明它在系统中的角色：
  	1. 普通文件包含任意数据
   	2. 目录是包含一组链接的文件，每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录
   	3. 套接字是用来与另一个进程进行跨网络通信的文件
- 目录层次结构中的位置用路径名来指定，路径分为：
  	1. 绝对路径名：以一个反斜杠开始，表示从根节点开始的路径
   	2. 相对路径名：以文件名开始，表示当前工作目录开始的路径
- 进程通过调用open函数来打开一个已存在的文件或者创建一个新文件
- 在某些情况下，read和write传送的字节比应用程序要求的少。这些不足值不表示有错误，原因：
  	1. 读时遇到EOF
   	2. 从终端读文本行
   	3. 读和写网络套接字
- RIO包（健壮的I/O包）：自动处理传送不足值的问题，RIO包提供了方便、健壮和高效的I/O。包含两类不同的函数：
  	1. 无缓冲的输入输出函数：直接在内存和文件之间传递数据，无应用级缓冲
   	2. 带缓冲的输入函数：允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内
- 应用程序通过调用stat和fstat函数，检索到关于文件的信息（文件的元数据）
- stat数据结构中，只关心st_size，st_mode
  	1. st_size成员包含文件的字节数大小
   	2. st_mode成员则编码了文件的访问许可位：1、S_ISREG(m) 是普通文件？2、S_ISDIR(m) 是目录文件吗？3、S_ISSOCK(m) 是网络套接字吗
- opendir以路径名为参数，返回指向目录流的指针
 - readdir返回都是指向流dirp中下一个目录项的指针，没有更多项返回NULL
 - closedir关闭流并释放其所有资源
 - 内核用三个相关的数据结构来表示打开的文件
   	1. 描述符表    --- 每个进程一张表
    	2. 文件表     ---- 所有进程共享
    	3. v-nod表    ---- 所有进程共享
- I/O重定向
- 标准I/O：C语言定义了一组高级输入输出函数，为程序员提供了Unix I/O的较高级替代。函数有fopen和fclose、fread和fwrite、fgets和fputs、scanf和printf
- I/O函数使用的基本指导原则：
  	1. G1: 只要有可能就使用标准I/O
   	2. G2: 不要使用scanf或者rio_readlineb来读二机制文件
   	3. G3: 对网络套接字的I/O使用RIO函数
- 标准I/O流，从某种意义上而言是全双工的，因为程序能够在同一个流上执行输入和输出。限制：
  	1. 跟在输出函数之后的输入函数
   	2. 跟在输入函数之后的输出函数



#### 总结：

1、Unix I/O模型的系统级函数，允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O的重定向。

2、应用程序使用RIO包，来自动处理不足值

3、内核三个相关的数据结构来表示打开的文件

4、Unix I/O、标准 I/O和RIO之间的关系