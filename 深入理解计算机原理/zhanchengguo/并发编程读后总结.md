#### 并发编程

 - 逻辑控制流在时间上重叠称为并发

 - 应用级并发用处：

   	1. 访问慢速I/O设备
    	2. 与人交互
    	3. 通过推迟工作以降低延迟
    	4. 服务多个网络客户端
    	5. 在多核机器上进行并发计算

 - 使用应用级并发的应用程序称为并发程序。现代操作系统提供三种基本的构造并发程序的方法：

   	1. 进程
    	2. I/O多路复用
    	3. 线程

- 12.1、基于进程的并发编程的优劣：

  	1. 优点：父子进程间使用共享文件表，不共享用户地址空间，进程有独立的地址空间
   	2. 劣势：独立的地址空间使得进程间共享状态信息变得困难，需要显示的IPC(进程间通信)机制；比较慢，进程控制和IPC的开销高

- 12.2、基于I/O多路复用的并发编程

  	- I/O多路复用技术的基本思路是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序
  	- select函数处理类型为fd_set的集合，也叫做描述符集合
  	- 一个状态机就是一组状态、输入事件和转移，其中转移是将状态和输入事件映射到状态
   - 优劣：
     	1. 优点：1、比基于进程的设计给了程序员更多的对程序的行为的控制；2、运行在单一进程的上下文中，因此每个逻辑流都能访问该进程的全部地址空间，使得流之间共享数据变得容易
      	2. 劣势：编码复杂

- 12.3、基于线程的并发编程  -- 是前两种方法的混合

  	- 线程就是运行在进程上下文中的逻辑流。每个线程都有自己的上下文，包括一个唯一的整数ID（Thread ID）。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间
  	- 每个进程开始生命周期都是单一线程，这个线程称为主线程。主线程和其他线程的区别仅在于它总是进程中第一个运行的线程
  	- 创建线程：通过调用pthread_create函数创建其他线程
  	- 终止线程：1、当顶层的线程例程返回时，线程会隐式地终止；2、通过调用pthread_exit函数，线程会显式的终止；3、某个对等线程调用Linux的exit函数，该函数终止进程以及该进程相关的线程；4、另一个对等线程通过以当前线程ID作为参数调用pthread_cancel函数来终止当前线程
  	- 回收已终止线程的资源：线程通过pthread_join函数等待其他线程终止，将线程例程返回的通用（void *）指针赋值为thread_return指向的位置，然后挥手回收已终止线程占用的所有内存资源
  	- 线程时可结合或者分离的：可结合线程能被其他线程回收和杀死，分离线程不能被其他线程回收和杀死，它的内存资源在它终止时由系统释放。默认情况下，线程被创建程可结合的，为避免内存泄露，每个可结合线程都应该被其他线程显式地收回，要么通过调用pthread_detach函数被分离
  	- 初始化线程：pthread_once函数允许你初始化和线程例程相关的状态

- 12.4、多线程程序中的共享变量

  	- 线程内存模型：线程间寄存器是从不共享的儿虚拟内存总是共享的
   - 将变量映射到内存：多线程的C程序根据它们的存储类型被映射到虚拟内存：
     	1. 全局变量：定义在函数之外的变量
      	2. 本地自动变量：定义在函数内部但没有static属性的变量
      	3. 本地静态变量：定义在函数内部并有static属性的变量
   - 共享变量：当且仅当它的一个实例被一个以上的线程引用，则是共享的

- 12.5、信号量同步线程

  		- 信号量是一种特殊类型的变量，用于解决同步不同执行线程问题的方法。提供两种操作：P和V
    		- 共享变量的互斥访问：将每个共享变量和一个信号量联系起来，然后用P和V操作来将相应的临界区包围起来
      		- 保护共享变量的信号量称为二元信号量，也称为互斥锁。P操作称为对互斥锁加锁，V操作称为对互斥锁解锁
        		- 信号量提供互斥外，还可以调度共享资源

- 12.6、使用线程提高并行性

  	- 所有程序的集合划分为不相交的顺序程序集合和并发程序集合，其中并行程序集合是并发程序集合的真子集

- 12.7、其他并发问题

   - 线程安全 -- 函数分为线程安全函数、线程不安全函数。线程不安全函数分类：
     	- 第1类：不保护共享变量的函数
     	- 第2类：保持跨越多个调用的状态的函数
     	- 第3类：返回指向静态变量的指针的函数
     	- 第4类：调用线程不安全函数的函数
  	- 可重入性：所有的函数集合被划分为不相交的线程安全函数集合和线程不安全函数集合。其中可重入函数集合是线程安全函数集合的真子集
  	- 在线程化的程序中使用已存在的库函数
  	- 竞争
   - 死锁：一组线程被阻塞，等待一个永远也不会为真的条件
     	- 互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的

  

  #### 总结

  1、并发的含义和并发程序的用处

  2、三种基本的构造并发程序的机制以及各自的优劣

  3、理解信号量提供对共享数据的互斥访问，以及对共享资源的调度

  4、并发引起的一些困难问题
