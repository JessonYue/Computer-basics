#### 链接

- 链接将各种代码和数据片段手机起来并组合成一个单一文件的过程，这个文件可被加载到（复制）内存并执行
- 链接可执行于编译时（源代码被翻译成机器代码时）、加载时（程序被加载器加载到内存并执行时）、运行时
- 7.1、编译器驱动程序：用户在需要时调用语言预处理器、编译器、汇编器和链接器
- C预处理器(main.c -> main.i) -> 编译器（main.i -> mian.s）-> 汇编器（main.s -> main.o）-> 链接器（main.o -> prog）
- 7.2、静态链接器：以一组可重定位的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出
  	1. 符号解析
   	2. 重定位
- 链接器的基本事实：目标文件纯粹是字节块的集合
- 7.3、目标文件：
  	1. 可重定位目标文件
   	2. 可执行目标文件
   	3. 共享目标文件
- 7.4、可重定位目标文件：典型格式：ELF文件
  		1. ELT头：16字节的序列，描述生成该文件的系统的字的大小和字节顺序
    		2. .text：已编译程序的机器代码
    		3. .rodata：只读数据
    		4. .data：已初始化的全局和静态C变量
    		5. .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量
    		6. .symtab：一个符号表
    		7. .rel.text：一个.text节中位置的列表
    		8. .rel.data：被模块引用或定义的所有全局变量的重定位信息
    		9. .debug：一个调试符号表
    		10. .line：原始C源程序的行号和.text节中机器指令之间的映射
    		11. .strtab：一个字符串表
    		12. 节头部表
- 7.5、符号和符号表
  	1. 在链接器的上下文中有三种不同的符号：1、由模块m定义并能被其他模块引用的全局符号；2、由其他模块定义并被模块m引用的全局符号；3、只被模块m定义和引用的局部符号
   	2. 三个特殊的伪节，在节头部表中是没有条目的：1、ABS代表不该被重定位的符号；2、UNDEF代表为定义的符号，也就是在目标模块中引用，但是却在其他地方定义的符号；3、COMMON表示还未被分配位置的未初始化的数据目标
- 7.6、符号解析
  	1. Linux链接器处理多重定义的符号名：1、不允许有多个同名的强符号；2、如果有一个强符号和多个弱符号同名，则选择强符号；3、如果有多个弱符号同名，则任意选择一个
   	2. 静态库（x x x.a）：将所有相关的目标模块打包成一个单独的文件。
- 7.7、重定位：
  	     1. 重定位节和符号定义
     	     2. 重定位节中的符号引用
- 两种基本的重定位类型：
  	1. R_X86_64_PC32：重定位一个使用32位PC相对地址的引用
   	2. R_X86_64_32：重定位一个使用32位绝对地址的引用
- 7.8、可执行目标文件
- 7.9、加载可执行目标文件：linux> ./prog
  		1. 加载：将程序复制到内存并运行的过程
    		2. 内核：操作系统驻留在内存的部分
- 7.10、动态链接共享库
  	1. 静态库解决大量相关函数对应用程序可用的问题
   	2. 静态库缺点：需要定期维护和更新
   	3. 共享库（共享目标） 是一个目标模块，在运行或加载时，可用加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程称为动态链接。linux下是.so  windows下是.dll
   	4. 位置无关代码：可以加载而无需重新定位的代码
- 7.12、库打桩机制：允许你截获对共享函数对调用，取而代之执行自己的代码。打桩可以发生在编译时、链接是或者当程序被加载和执行的运行时
  	1. 编译时打桩需要能够访问程序的源代码
   	2. 链接时打桩需要能够访问程序的可重定位对象文件
   	3. 运行时打桩需要访问可执行目标文件



#### 总结

1、了解链接器的分类

2、不同链接器的执行时机

3、链接器处理文件的3种不同的形式

4、静态链接器和动态链接器的优缺点

5、通过库打桩机制来插入自己的逻辑

