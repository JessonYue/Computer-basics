深入理解计算机系统-读书笔记

## 第1天 - 2020.06.01

个人觉得这本书第一章是对本书知识地图的梳理，一个引导建立对本书完整概念的一章，比较重要，阅读的细一些，会仔细理解比较重要的概念，阅读进度较慢，阅读到 1.8 系统之间利用网络通信。

### 第一章：计算机系统漫游

> 本章前言，了解到1个信息点：C编程语言经典教材[61]
> 后续有时间可以查阅一下。

#### 1.1 信息就是位 + 上下文

* 8位 构成 1字节

* 字节构成字，字在不同操作系统上表示大小不同

* ASCII 编码很重要，其他非英文编码的包含，应该有指的是 UTF8

* 理解 hello.c 这种源文件，在计算存储中的表示方式

  > 字符 -> ASCII -> 数字 -> 二进制

* 初步揭示了Linux系统中一些都是数据文件

* 重要概念：数字在机器中的表示方式，是对真值的近似值，会有坑

#### 1.2 程序被其他程序翻译成不同的的格式

* 将源码翻译成可执行文件的 `四个阶段程序` 及对应的 `四个过程`
  * 预处理器(cpp)   
    * hello.c(源文本) -> hello.i(插入依赖库源码的源文本)
  * 编译器（ccl）
    * hello.i -> hello.s（汇编代码-文本格式）
  * 汇编器（as）
    * hello.s -> hello.o （可重定位目标程序 - 二进制了）
  * 链接器（ld）
    * hello.o & printf.o(依赖库) -> hello （整hello.o和依赖库）
    * 最终完成的可执行文件就是 hello

#### 1.3 了解编译系统如何工作大有益处

理解编译系统如何工作的，可以帮助达成以下目标：

* 优化程序性能

* 理解链接时出现的错误

  > 这个在NDK编译中很有帮助

* 避免安全漏洞

#### 1.4 处理器读并解释存储在内存中的指令

* 可执行程序的二进制被载入到内存中，从而执行指令

##### 1.4.1 系统的硬件组成

* 总线

  * 贯穿系统全局的管道，用于跟各部分交互传输数据，大交通动脉

* I/O设备

  * 系统中几乎所有配件设备都可以归纳为I/O设备
  * I/O设备的类型可以分为 控制器和适配器
    * 控制器是主板或者鼠标这类自带芯片的设备
    * 适配器是插在主板插槽上的辅助设备

* 主存

  * 应该指的就是内存（第6章会介绍存储技术）

* 处理器（CPU）

  * 重要概念：`寄存器` 和 `程序计数器(PC)`

    * PC 指向的永远是当前内存中要执行的指令，这个很重要 

  * 系统基于CPU层面的执行模型

    * 就是不断执行计数器（PC）指向地址上的程序
    * 更新程序计数器就操纵了执行执行，这个由`指令集架构决定`

  * CPU的关联硬件

    * 主存

    * 寄存器文件

    * 算数/逻辑单元（ALU）

      > 用来进行寄存器的加减逻辑运算操作
      >
      > 计算新的数据和地址值，配合刷新PC，控制程序执行

    * CPU可能做的操作

      > 加载、存储、操作、跳转
      >
      > 这些都是为了配合PC控制程序执行

  * 两个概念区分

    * 指令集架构 - 针对机器代码指令的效果
    * 微体系结构 - 指处理器的实现

    > 指令集架构在同一架构下，指令的效果应该是相同的
    >
    > 微体系结构上处理器的实现，可能各有差异
    >
    > 理解一下，应该就是 Intel和AMD同样指令集下，可以让程序跑出相同的目标效果，但是处理器实现上却可能存在差异。

##### 1.4.2 运行 hello 程序

介绍执行程序的流程中，通过总线连接CPU、内存、IO设备的整个关系。

#### 1.5 高速缓存至关重要

由于 寄存器、内存的速度差异巨大，而寄存器贵，内存便宜，那么中间的高速缓存就很有必要了。

> 例如，或许可以理解 I7 ，I5 每一代的 二级缓存，三级缓存的意义了

#### 1.6 存储设备形成层次结构

概念上跟Android中的三级缓存意义差不多，只不过增加了硬件方面的 寄存器和 L1 ，L2 高速缓存，实现的目的和原理是基本一致的。

#### 1.7 操作系统管理硬件

> 一个很重要的概念：操作系统为应用程序屏蔽了硬件的差异。
>
> 让应用程序的开发可以更简单，大部分程序开发是面向操作系统的。

##### 1.7.1 进程

* 重要概念：进程是抽象出来的让程序貌似独占资源的虚拟概念。

  > 进程的抽象出来，让程序貌似独占资源，大大简化了面向编程人员的复杂性。
  > 进程是计算机科学中最重要和最成功的概念之一。

* 重要概念：上下文

  * 为了CPU可以执行多个进程程序，操作系统设计了上下文

  * 每个进程程序对应一个上下文，操作系统通过切换上下文，来切换程序对CPU资源的使用。

  * 而上下文的切换是由操作系统内核来管理的

    > 内核不是一个独立的进程。
    >
    > 它是系统管理全部进程所用代码和数据结构的集合。

* 上下文概念的通用性

  > 关于上下文这个概念，在编程中普遍存在。
  >
  > Android中的Context，Kotlin协程中的 Dispatch.IO ，这些上下文的概念是普适性的，原理上都是一致的，都是为了保存环境信息，切换执行再恢复执行，需要用到保存的上下文信息。

##### 1.7.2 线程

多线程的开销比多进程小，多线程可以容易的共享进程数据，多线程共享一个进程的上下文，多线程可以提高性能。

> 进程 -> 多线程 -> 协程，都是为了尽可能减少开销

##### 1.7.3 虚拟内存

虚拟内存也是一个抽象概念，给进程一个假象，好像每个进程都独占的使用内存。

* 重要概念：每个进程看到的内存是一致的，称为 `虚拟地址空间`

* 虚拟地址空间的构成

  * 程序代码和数据

  * 堆（动态分配大小）

  * 共享库

  * 栈（动态分配大小）

  * 内核虚拟内存

    > 地址空间顶部区域为内核保留，不允许应用程序来读写这个区域。

* 上述介绍地址空间的构成，是从 程序代码 -> 内核虚拟内存地址是递增的。

##### 1.7.4 文件

Linux系统中几乎一切都可以表示为文件。所有的操作都是统一的 Unix I/O 来通过读写文件实现。这个机制精简却很强大。

## 第2天 - 2020.06.02

#### 1.8 系统之间利用网络通信

文件就是字节序列。网络也是一种特殊的IO设备，可以直接在计算机之间进行数据传递。抛开实现上的细节，从IO概念上看，网络这种IO设备运作原理上跟其他IO设备是一致的，都是对文件字节序列的读写传输。

#### 1.9 重要主题

系统是硬件和软件互相交织的集合体，共同协作达到运行应用程序的目的。

##### 1.9.1 Amdahl 定律

吉恩·阿姆达尔定律 ， 很重要，可以用来指导进行性能优化。

* 理解过程

  > Told = 100; // 原始性能花费时间
  > a = 0.2; // 部分原占比 a*Told=20
  > k = 200% = 2.0; // 性能的提升 1.0 ，那么 a / k * Told = 0.2 / 2 * 100 = 10  
  >
  > 推导出：(a*Told) / k = (0.2 * 100) / 2.0 = 20 / 2 = 10
  >
  > 验证 Tnew = (1-a)*Told + (a*Told)/k = Told*[(1-a) + a/k]
  >
  >  Tnew = (1-0.2)*100 + (0.2*100)/2.0 = 80 + 10 = 90
  >       = 100*[(1-0.2)+0.2/2.0] = 100 * [0.8+0.1] = 90
  >
  > 加速比公式：S = Told/Tnew 
  > 代入 求Told 和 Tnew 的公式可得： S =  1/(1-a) + a/k
  >
  > 验证计算加速比 S = 1 / (1-0.2) + 0.2/2.0 =  1/0.8 + 0.1 = 5/4 + 0.1 =  1.25 + 0.1 = 1.35
  >
  > 1/[(1-0.2) + 0.2/2] = 1 / [0.8+0.1] = 1/0.9 = 1.11 
  >
  > 这里面综合考虑了对部分的加速，作用于整个系统中的效果。
  >
  > 计算 Told 和 Tnew 的计算公式，应用的 a 和 k 都是相对于部分的。k 的性能提升比例，指的是相对于部分的 a 的比例。计算对系统的加速比是计算部分的这个加速，应用于整个系统上，加速效果是多少。
  >
  >
  > 这里会出现一个现象：虽然我们对系统的一个主要部分做出了重大改进，但是获得系统加速比却可能明显小于这部分的加速比。
  > 举例子，设 系统某个部分初始耗时比例为 60% (a=0.6) ，其部分的加速比因子为 3 (k=3) 。则我们可以获得的整个系统的加速比为 1/[0.4+0.6/3] = 1.67 倍。
  > 这个例子表明了上面的现象，虽然对主要部分做出来重大改进，但是系统获得的加速比却明显小于这部分的加速比。
  >
  > Gene Amdahl（吉恩·阿姆达尔）定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
  >
  > 关于理解相对性能的比例概念有两种方式。
  > 推荐方式：Told/Tnew .
  > 其中Told 为原始系统所需时间，Tnew 为修改后系统所需时间。如果有所改进，则比值应大于1。用后缀 "X" 来表示比例，因此，"2.2X" 读作“2.2倍”。
  >
  > ---------
  >
  > 1.9.1 - Exercise - 1.1
  >
  > 1.9.1 - Exercise - 1.2
  > S = 1 / ((1-a)+a/k)
  >
  > 1.67X = 1 / (1-0.6 + 0.6/k)
  >
  > 1.67 = 1/ (0.4+0.6/k)
  >
  > 0.4+0.6/k = 1/1.67 = 1/(5/3) = 3/5 = 0.6
  >
  > 0.6/k = 0.2
  > k = 0.6/0.2 = 3

##### 1.9.2 并发和并行

* 三个主要层次

  * 线程级并发

    > 多核处理器促进了线程级并发

  * 指令级并行

    > 以 8086 为最简单的理解结构。
    >
    > 在第5章中会重点介绍这部分内容

  * 单指令、多数据并行

    > 在最低层次上，将一条指令产生多个可以并行执行的操作。
    >
    > 这种操作成为 单指令、多数据。SIMD并行。
    >
    > 目的都是为了提高CPU的处理效率。

##### 1.9.3 计算机系统中抽象的重要性

四个重要的抽象概念：

* 文件
  * 对I/O设备的抽象
* 虚拟内存
  * 对程序存储器的抽象（包含文件I/O设备和主存）
* 进程
  * 对一个正在的运行程序的抽象（包含处理器、主存和I/O设备）
  * 1.7 也有相关概念介绍
* 虚拟机
  * 对整个计算机的抽象（包含 操作系统、处理器、程序）
  * 主要目的是为了让计算机能够运行为不同操作系统设计的程序

##### 1.10 小结

三个基本抽象重要，重复一下：

（1）文件是对I/O设备的抽象

（2）虚拟内存是对主存和磁盘的抽象

（3）进程是对处理器、主存和I/O设备的抽象

> 网络是一种特殊的I/O设备，提供了计算机系统之间的通信手段。



### 第二章：信息的表示和处理

> 使用二进制作为计算机进制是因为它非常易于用电路表示，并且简单可靠。

* 三种最重要的数字表示
  * 无符号（unsigned）编码
    * 基于传统的二进制表示法
    * 表示大于或等于零的数字
  * 补码（two's-complement）编码
    * 表示有符号整数的最常见的方式
    * 有符号整数就是可以为正或者为负的数字
  * 浮点数（floating-point) 编码
    * 表示实数的科学计数法的2为基数的版本

> 计算机表示法用有限数量的位来对一个数字编码
>
> 因此会可能出现溢出，了解这些知识可以避免一些安全漏洞

> 各种编码基本定义、属性、位级表示、算数运算属性。

* GCC指定不同的C语言版本进行编译

![image-20200603231218929](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200603231218929.png)

#### 2.1 信息手册

> 大多数计算机使用 8位 一个字节，作为最小可寻址的内存单位。
>
> 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
>
> 内存的每个字节都由一个唯一的数字来标识，称为内存地址。
>
> 所有可能的地址的集合就称为 虚拟地址空间。

> 虚拟地址空间只是一个展现给机器级程序的概念，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组（第9章有讲解）。



##### 2.1.1 十六进制表示法

> 一个字节可以用两个十六进制来表示。
> 解释：
> 一个字节有8位   0000 0000 ，表示为16进制就是 0x00。
> 从另一个角度，16 = 2^4 ，也就是可以用四个2进制表示一个十六进制。

* 十六进制解释

![image-20200604000357644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000357644.png)

* 十六进制和二进制的转换

![image-20200604000547479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000547479.png)

* 练习题 2.1

  > A:
  > 0x 3 9 A 7 F B
  > 0011 1001 1010 0111 1111 1011
  >
  > B:
  > 1100 1001 0111 1011
  > 8421 8421 8421 8421
  > 8+4  8+1  4+2+1 8+2+1
  > C    9    7     B
  >
  > C:
  > 0x D  5  E  4  C
  >
  > 1101 0101 1110 0100 1100 
  >
  > D:
  >
  > 0010 0110 1110  0111  1011  0101
  > 8421 8421 8421  8421  8421  8421
  > 2    4+2  8+4+2 4+2+1 8+2+1 4+1
  > 2    6    E     7     B     5

* 十六进制和十进制换算方法

![image-20200604003019854](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604003019854.png)

> 以上列举的是转换的计算方法，实际应用中直接用计算器算

* 练习题 2.4

  > A:
  > 0x 803c 
  > +
  > 0x    8
  > 8044
  > B:
  > 0x 503c
  > -
  > 0x   40
  > 4EEc
  > C:
  > 0x 503c
  >
  > + 64
  >   50A0
  >   D:
  >   0x 50ea
  >   -
  >   0x 503c
  >     AE
  >
  >   A B C D E F
  >   10 11 12 13 14 15

##### 2.1.2 字数据大小

![image-20200604233606380](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604233606380.png)

   32位系统最大支持内存，2^32 byte  = 4GB 

* 位（bit） -> 比特

  >  计算机内部存储的最小单位。表示二进制位。
  >
  >  11010100 是一个8位二进制。

* 字节（byte）-> 拜特 / B

  > 字节是计算机数据处理的基本单位。
  >
  > 8位 构成 1字节 => 8bit = 1byte

* 字（word）

  > 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。
  > 一个字通常由一个或多个字节构成。
  >
  > 例如，
  > ​	    286微机的字由2个字节组成，它的字长为16；
  > ​        486微机的字由4个字节组成，它的字长为32；
  > 计算机的字长决定了其CPU一次操作处理实际位数是多少，由此可见计算机的字长越大，其性能越优越。

  * 字长概念的解释

    > 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位，16 位，32 位数据，但是处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
    >
    > 其实，CPU 指令集众多，各种例外是难免的。比如，8088 处理 16 位操作数的时候，只要不涉及主内存（只是立即数或者寄存器）就不花费额外周期，否则花费额外周期。所以称为准 16 位。再比如，如今的支持 SSE 指令集的 CPU，所称的字长从历史角度考虑，根本就没把 SSE 这种单指令多数据的情况算进去。
    >
    > 而且，字长还经常会从地址总线宽度，数据总线宽度这类概念借用过来。总之，说 64-bit CPU，32-bit CPU 的时候，明白自己指什么就好，不必拘泥于字长这个概念。
    >
    > 引用描述地址：https://www.zhihu.com/question/20536161



##### 2.1.3 寻址和字节顺序

大部分程序对象是跨越多字节的。那么对理解这个对象的存储需要理解两个重要概念。

两个重要规则概念：

* 对象的地址是什么

  * 多字节对象被存储为连续的字节序列

  * 对象地址为所使用的字节中最小的地址。

    > 假设，一个类型为 int 的变量 x 的地址为 0x100 ，也就是说，地址表达式 &x 的值为 0x100.
    >
    > 那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的 0x100、0x101、0x102和0x103位置。

* 内存中如何排列这些字节

  * 大端法、小端法
  * 大部分Intel和手机用小端法

![image-20200605000645086](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605000645086.png)



概念：

> 设 变量 x 类型为 int , 位于地址 0x100 处, 它的十六进制为 0x01234567.
>
> 注意：在字 0x01234567 中
>
> * 高位字节的十六进制为 0x01
> * 低位字节的十六进制为 0x67

* 大端法
  * 最高有效字节在最前面的方式，成为大端法
* 小端法
  * 最低有效字节在最前面的方式，称为小端法

![image-20200605003613984](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605003613984.png)

关于字节顺序的大端法和小端法需要注意的事项：

* 在大端法和小端法的两种类型机器间传递数据时，需要注意可能会出现接收方字节成反序的问题。
* 避免这类问题的方法是，网络应用程序的代码必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部的表示转换成网络标准，而接收方机器则将网络标准转换成它的内部表示。（第11章中会讲转换例子）

反汇编器概念：

> 反汇编器是一种确定可执行程序文件【所表示的指令序列】的工具。
>
> 第3章将学习这部分内容。

![image-20200605004405153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605004405153.png)



![image-20200605005917616](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605005917616.png)

* C中特殊转换指针类型的方法

  > typedef unsigned char *byte_pointer



* 弄明白 Clion 在Windows 和 Linux 上的配置

  * Windows上模仿Linux专属组件
    * MinGW
      * Minimalist GNU for Windows
      * 用于开发原生（32位）Windows应用的开发环境。
      * 主要提供了针对win32应用的GCC、GNU binutils 等工具。 
      * MinGW能替代cl编译不包含MFC，以WinSDK为主的应用。
      * MinGW被CodeBlocks，DevC++等选为Windows版本的默认编辑器
      * 据上一条可以理解，为什么可以依靠安装DevC++来配置Windows的C开发环境。
    * Cygwin
      * RedHat 项目，提供运行于Windows平台的类Unix环境。
        * 以GUN工具为代码
        * 提供一套抽象的dll，将Posix调用转换成Windows的API
    * msys
      * 提供一个较小的类Unix环境
    * mingw-w64
      * MinGW-w64是新一代MinGW
      * 支持更多API
      * 支持64位应用开发

* 验证代码

  ```c
  #include <stdio.h>
  
  typedef unsigned char *byte_pointer;
  
  void show_bytes(byte_pointer start,size_t len){
      size_t i;
      for(i = 0; i < len; i++){
          printf(" %.2x",start[i]);
      }
      printf("\n");
  }
  
  void show_int(int x){
      show_bytes((byte_pointer) &x,sizeof(int));
  }
  
  void show_float(float x){
      show_bytes((byte_pointer) &x,sizeof(float));
  }
  
  void show_pointer(void *x){
      show_bytes((byte_pointer) &x,sizeof(void *));
  }
  
  void test_show_bytes(int val){
      int ival = val;
      float fval = (float )ival;
      int *pval = &ival;
      show_int(ival);
      show_float(fval);
      show_pointer(pval);
  }
  
  int main() {
      test_show_bytes(12345);
      return 0;
  }
  
  ```

  > windows x64 系统输出 :
  >
  > 39 30 00 00
  > 00 e4 40 46
  > 0c fe 61 00 00 00 00 00



* 相关思考

```
同样123456编码， 整型内存字节表示为：0x00003039 ，浮点数表示为 0x4640E400

00003039
0000000000000000001 1000000111001
4640E400
010001100           1000000111001     0000000000

将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列(1000000111001)

这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。


思考：从二进制 0101011000 这些数学表示，反推转换成 十六进制，十进制，都是没有疑问的。

但是从输入层二进制推，就出现了疑惑，为什么Java里的byte输入是10进制？例如 byte[] keys = {60,61}

但继续思考这个同样的123456值，分别用整数型和浮点型转换为十六进制后，在内存字节上表示不同，但是又有13位是相同的二进制，

 ** 那么可以推测整数型123456的内存字节 0x00003039 和 浮点型的内存字节 0x4640E400 表示的是相同的值内容，

 ** 但是由于类型不同，附加了一些相关属性，所以导致123456的浮点型的内存字节多了一些符号表示。
 
 ** 标记此处，待后面验证

 [Java的byte数组的不同写法](https://blog.csdn.net/LVXIANGAN/article/details/41294989)
 [Java中Byte数组与十六进制字符串相互转换原理](https://cloud.tencent.com/developer/article/1385802)


数学符号大全：
https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8
```



##### 2.1.4 表示字符串

* 编码验证

  ```c
  void test_char(){
      const char *s = "abcdef";
      show_bytes((byte_pointer)s,strlen(s));
  }
  int main() {
      test_show_bytes(12345);
      test_char();
      return 0;
  }
  ```

  输出结果：

  >  39 30 00 00
  >  00 e4 40 46
  >  0c fe 61 00 00 00 00 00
  >  61 62 63 64 65 66  // abcdef 的ASCII码

* 相关编码集 ASCII、Unicode

* 编码考虑的事情

  * 能够包含大多数字符
  * 在包含大多数字符的情况下，如何保证合理占用字节空间
  * 路哥提供的哈夫曼编码压缩方法，可以合理处理这个问题

##### 2.1.5 表示代码

> 不同的机器类型使用不同的且不兼容的指令和编码方式，即使完全一样的进程，运行在不同操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。



##### 2.1.6 布尔代数运算

![image-20200606184319815](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606184319815.png)

* 布尔运算〜

  * 对应于逻辑运算 NOT

    > 当 P 不是真的时候，我们就说"T3 是真的，反之亦然。相应地，当 P 等于 0 时，〜P 等于1, 反之亦然。

* 布尔运算&

  * 对应于逻辑运算AND

    > 当P和Q都为真时，为真

* 布尔运算符 |

  * 对应逻辑运算 OR

    > 当 p=1 或者 q=1 时，p|q等于1.

* 布尔运算 ^

  * 对应逻辑运算异或

    > 当P 或者Q 为真但不同时为真时，成立。
    >
    > 当 p = 1 且 q = 0，或者 p=0 且 q=1时，p^q等于1



> 这一小节对应逻辑符号的描述，帮助理解了以前上的一门课，逻辑课，用来进行逻辑推理的公式，原来就是用计算机的数学逻辑来表示的！



* 重点概念：位向量

  > 位向量就是固定长度为 w ，由 0 和 1 组成的串。
  >
  > 位向量运算，可以定义成参数的每个对应元素之间的运算。

* 练习题 2.9 增进理解Android中对颜色的处理

* ![img](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/20160422211037563.gif)

* 练习题 2.10 帮助理解自定义View的重要环节 onMeasure 测量

  * 测量模式和测量值的存储和解析

  > //对应11000000000000000000000000000000;总共32位，前两位是1
  > int MODE_MASK  = 0xc0000000;
  >
  > //提取模式
  > public static int getMode(int measureSpec) {
  >  return (measureSpec & MODE_MASK);
  > }
  > //提取数值
  > public static int getSize(int measureSpec) {
  >  return (measureSpec & ~MODE_MASK);
  > }

​       练习题回答：

       ```

*x = a, *y = b

*y = *x ^ *y = a ^ b
*x = *x ^ *y = a ^ (a ^ b) = 0 ^ b = b 
*y = *x ^ *y = (0 ^ b) ^ ( a ^ b) = b ^ (a ^ b) = a 
       ```



* 练习题 2.11

  * 练习题回答

    ```
    A.
    end : first = k ; last = k
    B.
    此时 a[frist] = a[last]
    基于 ^ 的原理，a^a = 0; 所以，此时为0。
    C.
    跳过这个不替换。方法是 让for循环的条件排除 frist = last。也就是 将 first <= last 改为 first < last.
    ```



##### 2.1.7 C语言中的位级运算

![image-20200607135724336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607135724336.png)

* 从上图可以看出，根据 0xFF 的二进制是 [1111 1111] ，可以推出重要结论:

  * 当 `0x41 & 0xFF`  时，转换为二进制位运算，可以得到的是 `0x41` 本身。

    >​    0x41        0100  0001
    >&  0xFF        1111  1111
    >=  0X41        0100   0001

  * 当`0x41 & 0x00` 时，转换为二进制位运算，可以得到`0x41`被消减为0。

    >​    0x41        0100  0001
    >&  0x00       0000  0000
    >=  0x00        0000   0000

    这说明，可以用 数值 x 与 `0xFF` 或者 `0x00` 来进行位运算，来消减不想要的位，保留想要的位。

    再配合 `& | ~ ^` 这些布尔代数逻辑运算符，就可以进行各种位操作了。

![image-20200606183953489](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606183953489.png)



* 练习题 2.12

  * A 

    ```
    这个很简单，按照 x & 0xFF = x ，的二进制位运算推导出来
    x=0x87654321
    x & 0xFF = 0x87654321 = 0x000000FF & 0x87654321 = 0x0000021 
    ```

  * B

    ```
    B.
    
     0x  87 65 43 21   -> ‭ 1000 0111‬   ‭0110 0101‬    0100 0011‬   ‭0010 0001‬ 
     
    ^
    
    ~0x  00 00 00 FF    -> 0000 0000   0000 0000    0000 0000   1111 1111   
         FF FF FF 00    -> 1111 1111   1111 1111    1111 1111   0000 0000   
    
     0x  78 9A BC 21    -> 0111 1000   1001 1010    1011 1100   0010 0001  
     
     > 涉及到的知识点：1字节=8位，2^4 = 16 , 也就是4位存放1个16进制，1字节=8位=2个16进制.
     > 以这种存储方式，把数据全部转换为二进制进行运算，就得出了位运算。
    ```

  * C

    ```
     0x 87654321 & ~0xFF | 0xFF
     ->标准答案：
     0x 87654321 |0xFF 
     -> 原因：
     在二进制层面，任何位 | 0xFF 都是 0|1=1，所以会全是1，也就是 x|F=F
    ```

    ![image-20200607152653648](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607152653648.png)



##### 2.1.8 C语言中的逻辑运算符

![image-20200608223146297](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223146297.png)

按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

##### 2.1.9 C语言中的移位运算

![image-20200608223428838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223428838.png)

> 几乎所有的编译器、机器组合都对有符号数使用算术右移，且许多程序员也假设机器会使用这种右移。另一方面，对无符号数，右移必须是逻辑的。
>
> 与C相比，Java对于如何进行右移有明确的定义。表达式 x>>k 会将 x 算术右移 k 个位置，而  x>>>k 会对 x 做逻辑右移。

![image-20200608223838205](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223838205.png)



#### 2.2 整数表示

![image-20200609231804178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231804178.png)

##### 2.2.1 整型数据类型

![image-20200609231848641](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231848641.png)

> C 和 C++ 都支持有符号（默认）和无符号数。Java只支持有符号数。

##### 2.2.2 无符号数的编码

![image-20200609232141626](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232141626.png)

![image-20200609232221336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232221336.png)

##### 2.2.3 补码编码

![image-20200609232301739](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232301739.png)

![image-20200609232321093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232321093.png)

![image-20200609232350969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232350969.png)

![image-20200609232420691](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232420691.png)

##### * 2.2.4 有符号数和无符号数之间的转换

重要概念：对于有符号数和无符号数之间的转换，是用不同的解释方式去解释二进制位，但是本质上的二进制位并没有改变，只是改变了解读的方式，所以解读成了不同的数值。

![image-20200609233037797](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233037797.png)

##### 2.2.5 C 语言中的有符号数与无符号数

> 几乎所有的机器使用补码。通常，大多数数字都默认为是有符号的。
>
> C语言中，当声明一个像 12345 或者 0x1A2B 这样的常量时，默认是有符号的。
>
> 要创建一个无符号常量，必须加上后缀字符“U”或者"u"，
>
> 例如：12345U 或者 0x1A2Bu.

![image-20200609233503663](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233503663.png)

##### * 2.2.6 扩展一个数字的位表示

![image-20200609234051890](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234051890.png)



##### * 2.2.7 截断数字

![image-20200609234645555](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234645555.png)

![image-20200609234656316](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234656316.png)

![image-20200609234709178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234709178.png)

##### 2.2.8 关于有符号数与无符号数的建议

> 略过

#### 2.3 整数运算

##### 2.3.1 无符号加法

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610224725270.png" alt="image-20200610224725270" style="zoom:50%;" />

##### * 2.3.2 补码加法

对于补码加法，必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。

![image-20200610232418089](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610232418089.png)



##### * 2.3.2 补码的非

##### * 2.3.4 无符号乘法

##### * 2.3.5 补码乘法

##### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或者更多的周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数银子的乘法。首先，会考虑乘以2的幂的情况，然后再概括成乘以任意常数。

![image-20200610233126232](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610233126232.png)

> 注意,无论是无符号运算还是补码运算,乘以2的幂都可能会导致溢出。结果表明,
> 即使溢出的时候,我们通过移位得到的结果也是一样的。
>
> 例如 将4位模式[1011] (数值为11)左移两位得到[101100] (数值为44)。将这个值截断为4位得到[1100] (数值为12=44mod16)。

##### * 2.3.7 除以2的幂

大多数机器上，整数的除法要比乘法更慢，需要30个或者更多的时钟周期。

除以2的幂也可以用移位运算来实现，只不过用的是右移，而不是左移。

无符号数分别使用逻辑移位和算术移位来达到目的。

##### 2.3.8 关于整数运算的最后思考

计算机执行的 "整数" 运算实际上是一种模运算形式。表述数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种既能表示负数，也能表示正数的灵活方法，同时使用了与执行无符号运算相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。

#### 2.4 浮点数

重要概念：

![image-20200610235012367](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235012367.png)

##### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。

十进制表示法使用如下形式表示：

![image-20200610235621184](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235621184.png)

![image-20200610235828093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235828093.png)

十进制表示法不能准确表达 1/3 , 5/7 这样的数。因为它只能精确表示那些可以被写成  x X 2^y 的数。其他的值，只能被近似的表示。

![image-20200611000145943](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000145943.png)

##### 2.4.2 IEEE 浮点表示

![image-20200611000633695](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000633695.png)

![image-20200611001020700](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611001020700.png)

##### 2.4.3 数字示例

![image-20200611003809100](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003809100.png)

![image-20200611003905149](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003905149.png)

* 注意的点：

![image-20200611003950473](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003950473.png)

* 一些重要的单精度和双精度浮点数的表示和数字值：

![image-20200611004333652](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004333652.png)

##### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点数运算只能近似地表示实数运算。因此，对于值 x , 我们一般想用一种系统的方法，能够找到 "最接近的"匹配值 x' ，它可以用期望的浮点数形式表示出来。

这就是舍入（rounding）运算的任务。

一个关键的问题是在两个可能的值中间确定舍入方向。

> 例如,如果我有1.50美元,想把它舍入到最接近的美元数,应该是1美元还是2美元呢?
>
> 一种可选择的方法是维持实际数字的下界和上界。

![image-20200611004755578](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004755578.png)

* 舍入的方法

![image-20200611005845993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611005845993.png)

* 舍入方式的分析：

![image-20200611010008694](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010008694.png)

##### 2.4.5 浮点运算

![image-20200611010511900](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010511900.png)

##### 2.4.6 C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数据类型：float 和 double 。

在支持 IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。

另外，这类机器使用向偶舍入的舍入方式。

> 但是，因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍人方式或者得到诸如一0、十∞、一∞或者№aN之类的特殊值。
>
> 大多数系统提供include(‘.h’)文件和读取这些特征的过程库,但是细节随系统不同而不同。

例如,当程序文件中出现下列句子时,GNU编译器GCC会定义程序常数 INFINTTY(表示+∞)和NAN(表示NaN):

```c
#define _GNU_SOURCE 1
#include <math.h>
```

##### 浮点数小结

```
① 浮点数的表示，受制于计算机的二进制方式，只能表示 x X 2^t 的数值。其他的值只能被近似的表示。

② IEEE 的浮点数表示方法，将浮点数分为 三个部分：

  <1> 符号（sign）
  <2> 尾数（significand） -> n 位的编码数 M ，表示二进制小数
  <3> 阶码（exponent）    -> k 位的编码数 E ，表示负浮点数的加权。2 的 E次幂（可能是负数）。
  
  以上这种分为三部分的表示方式，能更接近的精度的表示小数。
  
③ 以上的表示方法依然限制了浮点数的范围和精度，因此再找 '最接近的' 匹配值，使用 舍入 方法。

  > 舍入的方法，有好几种，但是面对唯一需要决策的 1.5 这种中间数值的舍入，偏向于向偶舍入。
  
  > 即，1.5 和 2.5 都舍入为 2 。这是一种最常见的策略，更容易表示。
```

#### 2.5 小结

计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C语言的设计可以包含多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。

大多数机器对于`整数使用补码编码`，而对`浮点数使用 IEEE 标准754 编码`。

`在位级上理解这些编码，并且理解算术运算的数学特性`，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

![image-20200611012004885](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012004885.png)

* 要注意的点：

![image-20200611012050830](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012050830.png)

### 第3章 程序的机器级表示

计算机执行`机器代码`，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。

GCC C 语言编译器以及`汇编代码`的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用 `汇编器` 和 `链接器` ，根据汇编代码生成可执行的机器代码。

#### 3.1 历史观点

#### 3.2 程序编码

![image-20200612000317416](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612000317416.png)

##### 3.2.1 机器级代码（原理）

重要的两种抽象概念：

* 第一种是由 `指令集体系结构或指令集架构` 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

  > 大多数 ISA ，包括 x86-64 ，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。
  >
  > 处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

* 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

  > 存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。
  >
  > 第9章会讲到。

![image-20200612001116141](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001116141.png)

虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。

> C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
>
> 即使是对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

![image-20200612001722618](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001722618.png)

##### 3.2.2 代码示例（原理）

![image-20200612002330761](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612002330761.png)

* 调试 mstore.o

  ![image-20200612004851388](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612004851388.png)

  > gdb 调试上述程序的方式。
  >
  > ① gdb mstore.o   // 开始调试可执行文件
  >
  > ② x/14xb multstore // 告诉GDB显示从函数 multstore 所处地址开始的 14 个进制格式表示的字节。 
  >
  > 其他命令：quit // 退出gdb调试

  调试结果:

  ```shell
  (gdb) x/14xb multstore
  0x0 <multstore>:        0x53    0x48    0x83    0xec    0x20    0x4c    0x89    0xc3
  0x8 <multstore+8>:      0xba    0x02    0x00    0x00    0x00    0xe8
  (gdb) quit
  ```

* [gdb调试参考资料](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)

* 反汇编器(disassembler)

  ![image-20200612005425280](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612005425280.png)

​     使用 objdump 实际反汇编的结果：

```shell
//windows下执行
// mstore.o 大小：758
objdump.exe -d mstore.o

mstore.o:     file format pe-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 83 ec 20             sub    $0x20,%rsp
   5:   4c 89 c3                mov    %r8,%rbx
   8:   ba 02 00 00 00          mov    $0x2,%edx
   d:   e8 00 00 00 00          callq  12 <multstore+0x12>
  12:   89 03                   mov    %eax,(%rbx)
  14:   48 83 c4 20             add    $0x20,%rsp
  18:   5b                      pop    %rbx
  19:   c3                      retq
  1a:   90                      nop
  1b:   90                      nop
  1c:   90                      nop
  1d:   90                      nop
  1e:   90                      nop
  1f:   90                      nop
```

其中一些关于机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。

* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。

  > 例如，只有指令 pushq %rbx 是以字节值 53 开头的。

* 反汇编只是给予机器代码文件中的字节序列来确定汇编代码。

  > 它不需要访问程序的源代码或者汇编代码。

* 反汇编其使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。

  > 在我们的示例种，它省略了很多指令结尾的 `q` 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编其给 call 和 ret 指令加了 `q` 后缀，同样，省略这些后缀也没有问题。

![image-20200613124456938](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613124456938.png)

 然后，用以下方法生成可执行文件 prog:

```shell
linux > gcc -Og -o prog main.c mstore.c
```

![image-20200613143527397](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613143527397.png)

> 在当前 windows10 机器上测试，变成了 47083 个字节。这说明在不同机器上，生成的字节是不一样的。虽然通过编译器，可以保证执行的结果是一致的，但是二进制产生了差异，这就是不同操作系统和硬件的翻译有区别。编译器处理了这一层差异。

上面讲的抽取出的这段代码与 mstore.c 反汇编产生的代码几乎完全一样。

几点细微的区别如下：

* 第一个主要的区别是 左边列出的地址不同 —— 链接器将这段代码的地址移到了一段不同的地址范围中。

* 第二个不同之处在于链接器填上了 callq 指令调用函数 mult2 需要使用的地址（上面抽取出的反汇编代码第4行）。

  链接器的任务之一就是 `为函数调用找到匹配的【函数的可执行代码的位置】` 。

* 最后一个区别是多了两行代码（第8和第9行）。

  这两条指令对程序没有影响，因为它们出现在返回指令后面（第7行）。插入这些指令是为了使函数代码变为16字节，使得就存储器性能而言，能更好的放置下一个代码块。

  > 这里表达的意思应该是，存储器更适宜于存取机器/系统指定的固定长度的地址，这里16字节为一个长度单位去存取数据是最快的，在不同机器、系统环境下这个适宜的长度单位应该也会发生变化。

##### 3.2.3 关于格式的注解

GCC 产生的汇编代码对于我们来说有点难读。一方面，它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。

例如，假设我们用如下命令生成文件 mstore.s ：

![image-20200613145002462](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145002462.png)

所有以 "." 开头的行都是知道汇编器和链接器工作的伪指令，我们通常可以忽略这些行。

另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

![image-20200613145227519](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145227519.png)

通常我们只会给出与讨论内容相关的代码行。每一行左边都有编号供引用，右边是注释，简单描述指令的效果以及它与原始C语言代码中的计算操作的关系。

这是一种汇编语言程序员写代码的风格。

#### 3.3 数据格式

![image-20200613145740644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145740644.png)

如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

> 例如，数据传送指令有四个变种：moveb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。
>
> 后缀 '1' 用来表示 4 字节整数 和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

#### 3.4 访问信息

一个 x86-64 的中央处理单元(CPU) 包含一组16个存储64位值的`通用目的寄存器`。

![image-20200613150242935](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150242935.png)

![image-20200613150313874](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150313874.png)

有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

> 在  `3.7 - 过程` 章节中描述过程的实现时，会讲述这些惯例。   

##### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

> 源数据值可以以常数形式给出，或是从寄存器或内存中读出。
>
> 结果可以存放在寄存器或内存中。

因此操作数被分为三种类型：

* 立即数(immediate)

  > 表示常数值。
  >
  > ATT格式的汇编代码种，立即数用 $ 来表示（参考的描述，不准确）

* 寄存器(register)

  > 表示某个寄存器的内容。
  >
  > 用 r 表示寄存器（参考的描述，不准确）

* 内存引用(Mb[Addr])

  > 根据计算出来的地址(通常称为`有效地址`)访问某个内存位置。
  >
  > 用 M 表示内存引用（参考的描述，不准确）

![image-20200613151316013](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151316013.png)

##### 3.4.2 数据传送指令

最频繁使用的指令，是将数据从一个位置复制到另一个位置。

操作数表示的通用性，使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

>  把许多不同的指令划分成 `指令类` ，
> 每一类中的指令执行相同的操作，只不过操作数大小不同。

![image-20200613151753993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151753993.png)

![image-20200613152029123](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152029123.png)

![image-20200613152234259](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152234259.png)

##### 3.4.3 数据传送示例

![image-20200613152505439](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152505439.png)

这段汇编代码有亮点值得注意：

① C 语言中的 "指针" 就是地址。

> 间接引用指针就是将该指针放在一个寄存器中，然后在内存中使用这个寄存器。

② 像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。

> 访问寄存器比访问内存要快的多。

##### 3.4.4 压入和弹出数据

![image-20200613153526387](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153526387.png)

![image-20200613153602838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153602838.png)

> 栈在内存中的某个地方，所以压栈是：减少寄存器的值，将数据存放到内存中。

#### 3.5 算数和逻辑操作

![image-20200613154411994](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613154411994.png)

操作分类分类：

* 加载有效地址
* 一元操作
* 二元操作
* 移位

> 二元操作有两个操作数，一元操作有一个操作数

##### 3.5.1 加载有效地址

`加载有效地址(load effective address)` 指令 `leaq` 实际上是 movq 的指令变形。

它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。

> 它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![image-20200613155417025](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613155417025.png)

这二个指令的效果是将 `S的地址` 写入到 `寄存器D` 。

根本没有引用内存，只是操作的地址。

![image-20200613160045168](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613160045168.png)

##### 3.5.2 一元和二元操作

`这里的分组，都是指 图3-10 中的分组。`

第二组中的操作是一元操作，只有一个操作数，既是源又是目的。

> 这个操作数可以是一个寄存器，也可以是一个内存地址。

第三组是二元操作，其中，第二个操作数既是源又是目的。

> 注意1：源操作数是第一个，目的操作数是第二个。
>
> 第一个操作数可以是立即数、寄存器或是内存地址。
>
> 第二个操作数可以是寄存器或是内存地址。
>
> 注意2：当第二个操作数是内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

##### 3.5.3 移位操作

![image-20200613161003390](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161003390.png)

##### 3.5.4 讨论

图3-10 所示的大多数指令，既可以用于无符号运算，也可以用于补码运算。

>  只有右移操作要求区分有符号和无符号。
>
> 这个特性是补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

![image-20200613161435121](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161435121.png)

##### 3.5.5 特殊的算数操作

![image-20200613162933114](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613162933114.png)

#### 3.6 控制

到目前位置，我们只考虑了 `直线代码行为` ，也就是指令一条接接着一条顺序的执行。

C 语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。

机器代码提供两种基本的低级机制来实现有条件的行为：

① 测试数据值

② 然后根据测试的结果来改变控制流或数据流。

与数据相关的控制流是实现有条件行为更一般和更常见的方法。

> 通常 C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。
>
> 用 jump 指令，可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。
>
> 编译器必须产生构建在这种低级机制基础上的指令序列，来实现C语言的控制结构。

##### 3.6.1 条件码

除了整数寄存器，CPU还维护着一组单个位的 `条件码(condition code) 寄存器` ，它们描述了最近的算术或逻辑操作的属性。

可以检测这些寄存器来执行条件分支指令。

最常用的条件码有：

* CF : 进位标志

  > 最近的操作使最高位产生了进位。
  >
  > 可用来检查无符号操作的溢出。

* ZF : 零标志

  > 最近的操作得出的结果为0。

* SF : 符号标志

  > 最近操作得到的结果为负数。

* OF : 溢出标志

  > 最近的操作导致一个补码溢出 —— 正溢出负溢出。

![image-20200613164720092](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164720092.png)

##### 3.6.2 访问条件码

条件码通常不会直接读取，通常的使用方法有三种：

① 可以根据条件码的某种组合，将一个字节设置为 0 或者 1

② 可以条件跳转到程序的某个其他的部分

③ 可以有条件地传输数据

![image-20200613164933457](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164933457.png)

##### 3.6.3 跳转指令

正常执行的情况下，指令按照它们出现的顺序一条一条地执行。

`跳转` 指令会导致执行切换到程序中一个全新的位置。

在汇编代码中，这些跳转的目的地通常用一个符号(label) 指明。

![image-20200613165142534](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165142534.png)

##### 3.6.4 跳转指令的编码

虽然我们不关心及前期代码格式的细节，但是理解跳转指令的目标如何编码，这对`研究链接(第7章)`非常重要。

此外，它也能帮助理解反汇编器的输出。

>  在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。
>
> 第一种编码：
> 跳转指令有几种不同的编码，但是最常用的都是 `PC相对的(PC-relative)` 。
> 也就是说，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2或4个字节。
>
> 第二种编码：
> 这种编码方式是，给出"绝对"地址，用4个字节直接指定目标。
>
> 以上两种方式编码用哪种，取决于汇编器和链接器会选择适当的跳转目的编码。

![image-20200613165918872](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165918872.png)

##### 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

(另一种方式在 3.6.6节有讲，有些条件可以用数据的条件转移实现，而不是用控制的条件转移来实现。)

##### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用 `控制的条件转移`。

> 当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。
>
> 这种机制简单而通用，但是在现代处理器上，它可能非常低效。

一种替代的策略是使用 `数据的条件转移`。

> 这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。
>
> 只有在一些受限制的情况中，这种策略才可行。
>
> 但是如果可行，就可以用一条简单的 条件传送 指令来实现它。条件传送指令更符合现代处理器的性能特性。

```
为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码（如图 3-16 中
那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第 4
章和第 5 章中看到的，处理器通过使用流水线（pipelining)来获得高性能
```

##### 3.6.7 循环

`汇编中没有循环指令存在，可以用条件测试和跳转组合起来实现循环的效果。`

* 思考
  * 前提：如何翻译成汇编主要取决于汇编器
  * 问题：
    * 那么不同语言的不同汇编器产生的汇编是不同的，二进制是否相同？
      * 汇编不同，二进制也应该不同
        * 那么执行的时候，不同汇编器产生的二进制，如何执行起来的？

##### 3.6.8 switch 语句

![image-20200613171429054](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613171429054.png)

#### 3.7 过程（重要）

过程是软件中一种很重要的抽象。

> 它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。
>
> 然后，可以在程序中不同的地方调用这个函数。
>
> 设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

不同编程语言中，过程的形式多样，主要的有以下几种：

* 函数(function)
* 方法(method)
* 子例程(subroutine)
* 处理函数(handler)

但是它们都有一些共性。要提供对过程的机器级支持，必须要处理许多不同的属性。

为了方便讨论，`假设 过程P 调用 过程Q ， Q 执行后返回到 P `，这些动作至少包含以下共性之一：

* 传递控制

  > 在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。

* 传递数据

  > P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。

* 分配和释放内存

  > 在开始时，Q 可能需要为局部变量分配控件，而在返回前，又必须释放这些存储空间。

##### 3.7.1 运行时栈

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。

> 在 过程P 调用 过程Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。
>
> 当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
> 另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。
> 因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
>
> 当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

![image-20200613173457689](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173457689.png)

大多数过程的栈帧都是定长的，在过程开始就分配好了。

但是，有些过程需要变长的帧，这个问题会在 `3.10.5` 节中讨论。

> 通过寄存器 ，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。
>
> 思考：这是不是意味着，超过 6 个参数，会导致性能下降？

![image-20200613173920746](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173920746.png)

> 思考：这里的6个参数寄存器性能限制，是对C语言来讲的，那么基于JVM的Java，是否也是相同的限制？

##### 3.7.2 转移控制

将控制从 函数P 转移到 函数Q 只需要简单地把程序计数器(PC) 设置为 函数Q 代码的起始位置。

不过，当稍后从 Q 返回时，处理器必须记录好它需要继续 函数P 执行的代码位置。

> 在 x86-64 机器中，这个信息是用指令 `call Q`  调用过程Q 来记录的。
>
> 该指令会把 地址A 压入栈中，并将 PC 设置为 函数Q 的起始地址。
>
> 压入的 地址A  被称为返回地址，是 `紧跟在 call 指令后面的那条指令的地址` 。
>
> 对应的 `指令ret` 会从栈中弹出 地址A ，并把 PC 设置为 A 。

> 自己组织语言解释：
>
>  `call指令` 会先把 "执行完call后的下一条指令地址 A" 压入栈中，并将 PC 设置为 "要call的Q函数地址" 。这样，当 Q函数 执行完，调用 `ret指令` 时，会从栈中弹出 "执行完call后的下一条指令地址 A" ，并将 PC 设置为 地址A ， 从而继续执行 call指令之前的程序顺序。

思考：逆向中的找 call ，其实要关注两点：① call ② ret 

> call 指令保存了执行call之后的下一条指令地址，
>
> ret 指令从栈中弹出了要继续执行的 下一条指令地址。

![image-20200613180018825](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613180018825.png)

> 图3-3 出现在 3.4.1 节。

##### 3.7.3 数据传送

当调用一个过程时，除了要 `把控制传递给它` 并在过程 `返回时再传递回来` 之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。

x86-64 中，大部分过程间的数据传送是通过寄存器实现的。

> 例如，我们已经看到无数的函数示例，参数在寄存器％rdi、％rsi 和其他寄存器中传递。
>
> 当过程 **P** 调用过程 **Q** 时，**P** 的代码必须首先把参数复制到适当的寄存器中。
>
> 类似地，当 **Q** 返回到 **P** 时，**P** 的代码可以访问寄存器 %rax 中的返回值。

![image-20200613181206520](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613181206520.png)

> 思考：在 windows 中是否也有这种规则，根据寄存器的名字，可以推断出是第几个参数？

![image-20200613181558831](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613181558831.png)

> 图3-25 出现在 3.7.1 节

##### 3.7.4 栈上的局部存储

到目前为止，看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。

不过，有些时候，局部数据必须存放在内存中，常见的情况包括：

* 寄存器不足够存放所有的本地数据

* 对一个局部变量使用地址运算符 '&' ，因此必须为它产生一个地址。

  > 思考：这也就是说，当使用地址运算符 '&' 时，即使这个数据没有在内存中，是在寄存器中，那么也要把它放入内存中，产生一个内存地址？

* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

  > 在描述数组和结构分配时，会讨论这个问题

一般来说，过程通过减小栈指针在栈上分配空间。

分配的结果作为栈帧的一部分，标号为 "局部变量" ，在图 3-25 中有展示。

> 图3-25 出现在 3.7.1

##### 3.7.5 寄存器中的局部存储空间

`寄存器组是唯一被所有过程共享的资源` 。

虽然在给定时刻，只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值。

> 为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循。

思考：寄存器是CPU资源，也就是说符合 x86-64 结构CPU的操作系统（例如linux、mac、windows），都需要遵循相同的寄存器规则？

![image-20200613183957646](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613183957646.png)

##### 3.7.6 递归过程

前面已经描述的寄存器和栈的惯例使得 x86-64 能够递归的调用它们自身。

每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。

此外，栈的原则很自然的就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

![image-20200613185311956](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613185311956.png)

![image-20200613185327077](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613185327077.png)

从这个例子中，我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。

如果需要，它还可以提供局部变量的存储。`栈分配和释放的规则` 很自然地就与 `函数调用-返回的顺序` 匹配。这种实现函数调用和返回的方法，甚至对更复杂的情况也适用，包括相互递归调用（例如，过程 P 调用 Q ，Q 再调用 P）。

> 思考，理解递归，只需要入手三个步骤：
>
> ① 入参规则（一般有规律）
>
> ② 拿掉递归的功能逻辑
>
> ③ 从递归最底层倒推两步，最多三步，就可以理解了
>
> 看懂拿掉递归的功能逻辑，再把有规律的入参一一带入，就很容易理清楚逻辑了。

 ```
用以上理解递归的思路去分析 图3-35 a) :
① 入参规则（一般有规律）
rfact(n-1) 决定了入参的规则，那么，假如起始 n = 9 , 
整个递归过程中，n = 9,8,7,6,5,4,3,2,1 
② 拿掉递归的功能逻辑
保证 n 为 1 后，依次 n * rfact(n-1)。
③ 从递归最底层倒推两步，最多三步
2*rfact(2-1) => 2*1   //n=2时，最底层的一步
3*rfact(3-2) => 3*2*1 //n=3时，倒数第二步

推到出来，很清晰明了。
 ```

#### 3.8 数组分配和访问

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。

C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。

C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。

在机器代码中，这些指针会被翻译成地址计算。

> 这说明，C语言的指针运算天然对机器级代码友好。性能高。

> 拓展说说明：优化编译器非常善于简化数组索引所使用的地址计算。不过这使得C代码和它到机器代码的翻译之间的对应关系有些难以理解。

##### 3.8.1 基本原则

![image-20200613192452991](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613192452991.png) 

![image-20200613233801960](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613233801960.png)

> x86-64 的内存引用指令可以用简化数组访问。

##### 3.8.2 指针运算

C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。

![image-20200613234640361](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613234640361.png)

但操作数操作符 '&' 和 '*' 可以产生指针和间接引用指针。

* & : 直接产生指针地址，即时值在寄存器中，也会压入内存栈中，产生一个内存地址。
* '*' : 间接引用指针，指地址上的内容值，想要使用指针地址时，还是需要使用 & 。

![image-20200613235047082](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235047082.png)

* 拓展

  ![image-20200613235156131](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235156131.png)



##### 3.8.3 嵌套的数组

当创建数组的数组时，数组分配和引用的一般原则也是成立的。

![image-20200613235629907](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235629907.png)

##### 3.8.4 定长数组

C 语言编译器能优化定长多维数组上的操作代码。

![image-20200613235825365](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235825365.png)

##### 3.8.5 变长数组

历史上，C 语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。

程序员需要变长数组时，不得不用 `malloc` 或 `calloc` 这样的函数为这些数组分配存储空间。 

* 拓展资料

> 函数malloc()和calloc()都可以用来动态分配内存空间,但两者稍有区别。 
>
> malloc()函数有一个参数,即要分配的内存空间的大小: 
>
> void *malloc(size_t size); 
>
> calloc()函数有两个参数,分别为元素的数目和每个元素的大小,这两个参数的乘积就是要分配的内存空间的大小。 
>
> void *calloc(size_t numElements,size_t sizeOfElement); 
>
> 如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的首地址。 
>
> 函数malloc()和函数calloc()的主要区别是前者不能初始化所分配的内存空间,而后者能。如果由malloc()函数分配的内存空间原来没有 被使用过，则其中的每一位可能都是0;反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。也就是说，使用malloc()函数的程序开 始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。 
>
> 函数calloc()会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那麽这些元素将保证会被初始 化为0;如果你是为指针类型的元素分配内存,那麽这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零。 
>
> **realloc函数**
> 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。
> 函数的原型是extern void *realloc(void *mem_address, unsigned int newsize)；
>
> 参考地址资料：
>
> [ C语言中malloc()和calloc()c函数用法 ](https://www.cnblogs.com/stevenwuzheng/p/5484986.html)
>
> [C语言中malloc，calloc，realloc等动态分配内存函数特点详解](https://blog.csdn.net/MarcoAsensio/article/details/85937002)

![image-20200614000745988](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614000745988.png)

* 动态的变长数组的优缺点

![image-20200614001017395](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001017395.png)

![image-20200614001220886](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001220886.png)

![image-20200614001236596](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001236596.png)

#### 3.9 异质的数据结构

C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：

* 结构(structure)

  > 用关键字 `struct` 来声明，将多个对象集合到一个单位中。

* 联合(union)

  > 用关键字 `union` 来声明，允许用几种不同的类型来引用一个对象。



##### 3.9.1 结构

C 语言的  `struct` 声明创建一个数据类型，将可能不同的类型的对象聚合到一个对象中。

用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。

编译器维护关于每个结构类型的信息，指示每个字段 (field) 的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

![image-20200614002434161](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002434161.png)

##### 3.9.2 联合

联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

![image-20200614002612170](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002612170.png)

![image-20200614002932167](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002932167.png)

##### 3.9.3 数据对齐（有用）

许多计算机系统对基本数据类型的合法地址做出了一些限制。

要求某种类型对象的地址必须是某个值 K (通常是2、4 或 8) 的倍数。这种 `对齐限制` 简化了形成处理器和内存系统之间接口的硬件设计。

> 例如，假设一个处理器总是从内存中取 8 个字节，则地址必须为 8 的倍数。
>
> 如果能够保证将所有的 double 类型数据的地址对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了。
>
> 否则，可能需要执行两次内存访问，因为对象可能被分别放在两个 8 字节内存块中。

**对齐的优势，终于理解了**。

无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。

对齐的原则是：任何 K 字节的基本对象的地址必须是 K 的倍数。

可以看到这条原则会得到如下对齐：

![image-20200614003836562](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614003836562.png)

* 结构的对齐

  对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。

  > 也就是说结构的 K 是取它 `包含对象的k` 的最小公倍数。

  ![image-20200614004345354](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004345354.png)

  > 从上图可以看出，
  >
  > 偏移量：指的也就是对起始地址的偏移长度。

  编译器结构的末尾可能需要一些填充，这样数据结构中的每个元素都会满足它的对齐要求。

  例如，考虑下面这个结构声明：

  ![image-20200614004600173](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004600173.png)

* 总的来说，结构的对齐，从起始地址、到包含对象的地址、到结尾地址都应该满足 `包含对象的k 的最小公倍数`。

![image-20200614004941465](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004941465.png)

#### 3.10 在机器级程序中将控制与数据结合起来

![image-20200614005302486](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614005302486.png)

##### 3.10.1 理解指针（重要）

![image-20200614010135287](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010135287.png)

![image-20200614010145018](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010145018.png)

* 函数指针的重点介绍

![image-20200614010410665](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010410665.png)

##### 3.10.2 应用：使用 GDB 调试器

GUN 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。

有了 GDB ，可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。

![image-20200614022956679](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614022956679.png)

![image-20200614023300513](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023300513.png)

 ##### 3.10.3 内存越界引用和缓冲区溢出(安全相关)

我们已经看到，C 对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。

这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。

当程序使用这个被破坏的状态，试图重新加载寄存器或执行 `ret指令` 时，就会出现很严重的错误。

一种特别常见的状态破坏成为 `缓冲区溢出(buffer overflow)` 。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。

下面这个程序示例说明了这个问题：

![image-20200614023841780](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023841780.png)

![image-20200614023919807](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023919807.png)

![image-20200614024027711](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024027711.png)

##### 3.10.4 对抗缓冲区溢出攻击

对抗缓冲区溢出攻击的方式：

* 栈随机化

  ![image-20200614024356852](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024356852.png)

![image-20200614024501712](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024501712.png)

* 栈破坏检测

  ![image-20200614024726737](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024726737.png)

* 限制可执行代码区域

  ![image-20200614024949243](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024949243.png)

##### 3.10.5 支持变长栈帧

 到目前未知，我们已经检查了各种函数的机器级代码，但它们有一个共同点，即编译器能够预先确定需要为栈帧分配多少空间。

但是有些函数，需要的局部存储是变长的。

> 例如当函数调用 alloca 时就会发生这种情况。alloca 是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

实现变长栈帧的过程，需要理解数组和对齐。

![image-20200614025501247](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614025501247.png)

![image-20200614025904516](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614025904516.png)

> 思考：变长栈帧，也是先保存变量值和相关需保存的环境值，然后在栈顶开辟空间，但是，根据前面描述的理论，栈顶的地址是越来越小的，那么这样去开辟空间，是否就会遇到栈顶预留地址不够开辟的情况？例如当前栈顶是 0x100 ，但是需要再开辟 多余0x100 个偏移的空间，栈顶地址不够用了？

#### 3.11 浮点代码

处理器的 `浮点体系结构` 包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

* 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。

* 对浮点数据操作的指令。

* 向函数传递浮点数参数和从函数返回浮点数结果的规则。

* 函数调用过程中保存寄存器的规则

  > 例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

  ![image-20200614030946586](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614030946586.png)

这里的原理讲述是基于 AVX2 ，即 AVX 的第二个版本。它是在 2013 年 Core i7 Haswell 处理器中引入的（切实身边贴切的Haswell处理器，不再是讲古董了！）。

* 需要注意的点

  ![image-20200614031420925](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614031420925.png)

![image-20200614121727899](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614121727899.png)

##### 3.11.1 浮点传送和转换操作

重要概念：

* 向量指令

  > 向量指令的基本操作对象是向量。即，有序排列的一组数。
  >
  > 若指令为向量操作，则由指令确定向量操作数的地址（主存储器起始地址或向量寄存器号），并直接或隐含地指定如增量、向量长度等其他向量参数。
  >
  > 向量指令规定处理机按同一操作处理向量中的所有分量，可有效地提高计算机的运算速度。

* 标量指令

  > 不具备向量处理功能，只能对单个量即标量进行操作的指令，称为标量指令。

计算机指令系统的种类划分：

![image-20200614173825132](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614173825132.png)

[参考资料：指令系统-百科]([https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F](https://baike.baidu.com/item/指令系统))

![image-20200614173941497](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614173941497.png)

图 3-46 给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。

**引用内存的指令是`标量质量`** ，意味着它们只对单个而不是一组封装好的数据值进行操作。

数据要么保存在内存中(由表中的`M32`和`M64`指明)，要么保存在 XMM 寄存器中(在表中用X表示)。

>  无论数据对齐与否，这些指令都能正确执行，不过代码优化建议 32 位内存数据满足 4 字节对齐，64位数据满足 8 字节对齐。
>
> 内存引用的指定方式与整数 MOV 指令一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

![image-20200614174452643](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614174452643.png)

##### 3.11.2 过程中的浮点代码

在 x86-64 中，XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。

如图 3-45（图在3.11小节开篇） 所示，可以看到如下规则：

* XMM 寄存器 %xmm0 ~ %xmm7 最多可以传递8个浮点数参数。

  > 按照参数列出的顺序使用这些寄存器。
  >
  > 可以通过栈传递额外的浮点参数。

* 函数使用寄存器 %xmm0 来返回浮点值。

* 所有的 XMM 寄存器都是调用者保存的。

  > 被调用者可以不用保存就覆盖这些寄存器中任意一个。

**当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过 XMM 寄存器传递。**

**也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。**

下面是一些例子：

![image-20200614175412814](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614175412814.png)

> 上面第三个 double f1(float x, double *y , long *z) ，中的 double *y 应该是作为一个指针类型来存放的？否则，作为双精度浮点数 double 类型，应该在 %xmm~%xmm7 中。
>
> 下一小节 3.11.3 中的例子，证明了这一点。

##### 3.11.3 浮点运算操作

![image-20200614175927969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614175927969.png)

![image-20200614180007451](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614180007451.png)

##### 3.11.4 定义和使用浮点常数

> 操作数 中 立即数 的概念，在 3.4.1 小节。立即数值就是常数值。

和整数运算操作不同，AVX 浮点操作不能以 `立即数值` 作为 `操作数`。

相反，编译器必须为所有的常量值分配和初始化空间，然后代码再把这些值从内存读入。

下面从摄氏度到华氏度转换的函数就说明了这个问题：

![image-20200614180828074](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614180828074.png)

##### 3.11.5 在浮点数代码使用位级操作

有时我们会发现 GCC 生成的代码会在 XMM 寄存器上执行位级操作，得到有用的浮点结果。

![image-20200614181225943](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181225943.png)

上图 3-50 展示了一些相关的指令，类似于它们在通用寄存器上对应的操作。

这些操作都作用于封装好的数据，即它们更新整个目的 XMM 寄存器，对两个源寄存器的所有位都实施指定的位级操作。

##### 3.11.6  浮点数比较操作

![image-20200614181752684](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181752684.png)

![image-20200614181809479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181809479.png)

##### 3.11.7 对浮点代码的观察结论

我们可以看到，用 AVX2 为浮点数上的操作产生的机器代码，风格类似于证书上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。

当然，处理不同的数据类型以及对包含`混合数据类型`的`表达式求值`的规则有许多复杂之处，同时，AVX2 代码包括许多比只执行整数运算的函数更加不同的指令和格式。

AVX2 还有能力在封装好的数据上执行并行操作，使计算机执行的更快。

> 编译器开发者致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的可靠方法是使用 GCC 支持的、操纵向量数据的 C 语言扩展。

#### 3.12 小结

![image-20200614182828292](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614182828292.png)

* 通过 C 语言提供的抽象层面下的东西，了解机器级编程。

  > 这一点很重要，这章节的都是基于C语言的GCC编译器的。
  >
  > 这些理论都是相似的，但是非C语言的情况下，具体实现上多少会有些不同。
  >
  > 这里只分析了 C 到 x86-64 的映射，但是大多数内容对其他语言和机器组合来说也是类似的。

* 通过让编译器产生机器级的汇编代码表示，了解了编译器和它的优化能力，以及 `机器`、`数据类型` 和 `指令集`。

  > 第5章，将会编写能有效映射到机器上的程序，会比较重要。
  >
  > 了解本章讲述的编译器特性，会帮助理解第5章。

*  Java的实现方式跟这里完全不同。

  > Java 的目标代码是一种特殊的二进制表示，称为 `Java字节代码`。
  >
  > `Java字节码` 这种代码可以看成是虚拟机的机器级程序。
  >
  > `Java字节码` 的这种虚拟机的机器级程序，并不是直接用硬件实现的，而是用软件解释处理字节码，虚拟的去模拟机器行为。（要理解这种虚拟机器行为的字节码，需要去读JVM的相关书籍？）



### 第4章 处理器体系结构

#### (本章节重要但需后延细读)

> 本章节很重要，但是鉴于现在课程量大，跟当前课程关联不是很密切，先快速阅读即可。

到目前为止，我们看到的计算机系统只限于机器语言程序级。

我们知道处理器必须执行一系列指令，**每条指令执行某个简单操作**，例如两个数相加。

---

指令被编码为由一个或多个字节序列组成的二进制格式。

重要概念：

* `指令集` 体系结构(Instruction-Set Architecture, ISA)

  > 一个处理器支持的 `指令` 和 `指令的字节集编码` 称为它的 `指令集体系结构`。

---

不同的处理器 "家族" ，例如 Intel IA32 和 x86-64 、IBM/Freescale Power 和 ARM 处理器家族，都有不同的 指令集(ISA) 。 

一个程序编译成在一种机器上运行，就不能再另一种机器上运行。

> 这里终于理解了，为什么针对不同的 ARM 芯片处理器机器，要重新编译程序了。

> 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 指令集(ISA) 级别上都保持着兼容。
>
> 一些常见的处理器家族（例如x86-64）中的处理器分别由多个厂商提供。

**因此，`指令集(ISA) ` 在编译器编写者和处理器设计人员之间提供了一个 `概念抽象层` 。**

编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；

而处理器设计者必须建造出执行这些指令的处理器。

![image-20200614193211253](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614193211253.png)

#### 4.1 Y86-64 指令集体系结构

定义一个指令集体系结构（例如 Y86-64）包括：

* 定义各种状态单元
* 指令集和它们的编码
* 一组编程规范
* 异常事件处理

##### 4.1.1 程序员可见状态

![image-20200614194739695](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194739695.png)

##### 4.1.2 Y86-64 指令

![image-20200614194240507](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194240507.png)

![image-20200614194253420](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194253420.png)

![image-20200614194311732](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194311732.png)

##### 4.1.3 指令编码

![image-20200614194411788](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194411788.png)

![image-20200614194421719](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194421719.png)

* 指令集的一个重要性质是 `字节码必须有唯一的解释` 。

  >任意一个字节序列要么是一个唯一的指令序列编码，要么就不是一个合法的字节序列

![image-20200614194633932](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194633932.png)

##### 4.1.4 Y86-64 异常

![image-20200614195122331](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614195122331.png)

> 第 8 章会讲述，如何终止或者调用一个用户自定义的 `信号处理程序(signal handler)`。

##### 4.1.5 Y86-64 程序

略

##### 4.1.6 一些 Y86-64 指令的详情

![image-20200614195303008](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614195303008.png)

  #### 4.2 逻辑设计和硬件控制语言 HCL

**在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。**

大多数现代电路技术都是 `用信号线上的高电压` 或 `低电压` 来 `表示不同的位值`。

在当前的技术中，逻辑1 是用 1.0 伏特左右的高电压表示的，而 逻辑0 是用 0.0 伏特左右的低电压表示的。

要实现一个数字系统需要三个主要的组成部分：

* 计算 `对位进行操作的函数` 的 `组合逻辑`
* 存储 `位` 的 `存储单元`
* 控制存储器单元更新的时钟信号

![image-20200614230407574](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230407574.png)

![image-20200614230503056](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230503056.png)

##### 4.2.1 逻辑门（原理）

逻辑门是数字电路的基本计算单元。

它们产生的输出，等于它们输入位值的某个布尔函数。

![image-20200614230807147](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230807147.png)

##### 4.2.2 组合电路和 HCL 布尔表达式

概念：

* 组合电路(combinational circuits)

  > 将很多的逻辑门组合成一个网，就能构建 计算块(computational block) ，
  >
  > 称为 组合电路

如何构建这些网有几个限制：

* 每个逻辑门的输入必须连接到下述选项之一

  * 一个系统输入（称为主输入）
  * 某个存储器单元的输出
  * 某个逻辑门的输出

* 两个或多个逻辑门的输出不能连接在一起。

  > 否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
  >
  > 大概是因为两个信号输入，大的电压盖过低的电压，产生一个异常的方向差值？

* 这个网必须是无环的。

  > 也就是在网中不能有路径经过一系列的门而形成一个回路，
  >
  > 这样的回路会导致该网络计算的函数有歧义。保证唯一性，解释的准确性、无歧义。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232310608.png" alt="image-20200614232310608" style="zoom:67%;" />

![image-20200614232326069](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232326069.png)

> 这里需要结合 4.2.1 小节中的 图 4-9 来理解

![image-20200614232436133](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232436133.png)

* 多路复用器(multiplexor)

  > 下图 4-11 给出了另一个简单但很有用的组合电路，称为 `多路复用器(multiplexor， 通常称为 "MUX")` 。
  >
  > 多路复用器 根据 `输入控制信号的值`，从一组不同的数据信号中选出一个。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232606254.png" alt="image-20200614232606254" style="zoom:67%;" />

在 上图4-11 这个 `单个位` 的 多路复用器中，两个数据信号是 输入位 a 和 b , 控制信号是输入位 s 。

> 当 s 为 1 时，输出等于 a ；
> 当 s 为 0 时，输出等于 b 。
>
> 在这个电路中，我们可以看出两个 AND 门决定了是否将它们相对应的数据输入传送到  OR 门。
>
> 当 s 为 0 时，上面的 AND 门将传送信号 b（因为这个门的另一个输入是 !s），
> 当 s 为 1 时，下面的 AND 门将传送信号 a 。

接下来，写 上图4-11 的 输出信号 HCL 表达式，使用的就是组合逻辑中相同的操作：

```
bool out = (s && a) || (!s && b);
```

![image-20200614234119286](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614234119286.png)

重要特性：

> 由于 组合电路 是由一系列的逻辑门组成，它的属性是输出会持续的响应输入的变化。
>
> 如果电路的输入变化了，在一定的延迟后，输出也会相应的变化。
>
> 跟硬件中的 赫兹(Hz) 概念是一样的，硬件中的逻辑门都会持续响应，这是特性。 

##### 4.2.3 字级的组合电路和 HCL 整数表达式

通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。

通常，我们设计能对 数据字(word) 进行操作的电路。

有一些位级信号，代表一个整数或一些控制模式。

> 例如，我们的处理器设计将包含有很多字，字的大小范围为 4位到64位，代表整数、地址、指令代码和寄存器标识符。

执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

![image-20200614234806395](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614234806395.png)

##### 4.2.4 集合关系

在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614235603359.png" alt="image-20200614235603359" style="zoom: 67%;" />

下面来看一个简单的例子，假设想从一个两位信号 code 中选择 `高位` 和 `低位` 来为 图4-14 中的四路复用器产生信号 s1 和 s0 , 

如下图所示：

![image-20200614235655234](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614235655234.png)

##### 4.2.5 存储器和时钟（原理）

组合电路从本质上讲，不存储任何信息。

相反，它们知识简单地相应输入信号，产生等于输入的某个函数的输出。

概念：

* 时序电路(sequential circuit)

  > 有状态并且在这个状态上进行计算的系统。

为了产生 `时序电路(sequntial circuit)` ，我们必须引入按位存储信息的设备。

存储设备都是由 同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。

考虑两类存储设备：

* 时钟寄存器（简称寄存器） 

  > 存储单个位或字。
  >
  > 时钟信号控制寄存器加载输入值。

* 随机访问存储器（简称内存）

  > 存储多个字，用地址来选择该读或该写哪个字。

  随机访问存储器的例子包括:
* 处理器的虚拟内存系统
  
    > 硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字。
  
  * 寄存器文件
  
    > 在此，寄存器标识符作为地址。
    >
    > 在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器（%rax~%r14）

注意：

在说到硬件和机器编程时，"寄存器" 这个词是两个有细微差别的事情。

* 在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。

* 在机器级编程中，寄存器代表的是 CPU 中位数不多的可寻址的字，这里的地址是寄存器 ID 。

  > 这些字通常都存在寄存器文件中，虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。
  >
  > 需要避免歧义时，我们会分别称为这两类寄存器为 "硬件寄存器" 和 "程序寄存器"。

![image-20200615001818505](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001818505.png)

![image-20200615001842877](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001842877.png)

![image-20200615001855766](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001855766.png)

#### 4.3 Y86-64 的顺序实现 

> 此章节，待路上阅读，重要的阅读时间，留给跟课程密切相关的章节。



### 第5章 优化程序性能

编写高效程序需要做到以下几点：

* 必须选择一组适当的算法和数据结构

* 必须编写出编译器能够有效优化以转换成搞笑可执行代码的源代码

  > 对于这第二点，理解优化编译器的能力和局限性很重要。
  >
  > 编写程序方式中看上去只是一点小小的变动，都会引起编译器优化方式很大的变化。

程序优化的第一步就是消除不必要的工作，让代码尽可能有效的执行所期望的任务。

这包括消除不必要的函数调用、条件测试和内存引用。

> 这些优化不依赖于目标机器的任何具体属性。

#### 5.1 优化编译器的能力和局限性

现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。

然后，会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。

#### 5.2 表示程序性能

我们引入度量标准 `每元素的周期数(Cycles Per Element,CPE)` ，作为一种表示程序性能并知道我们改进代码的方法。

CPE 这种度量标准帮我我们在更细节的级别上理解迭代程序的循环性能。

>  这样的度量标准对执行重复计算的程序来说，是很适当的。
>
> 例如，处理图像中的像素，或是计算矩阵乘积中的元素。

处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用 `千兆赫兹(GHz)` ，即 十亿周期 每秒来表示。

> 例如，当表明一个系统有 "4GHz" 处理器，这表示处理器时钟运行频率为每秒 4x10^9 个周期。

**每个时钟周期的时间是时钟频率的倒数**。

通常是以纳秒(nanosecond, 1 纳秒= 10^-9 秒) 或皮秒(picosecond, 1 皮秒等于 10^-12秒) 为单位的。

> 例如，一个 4GHz 的时钟其周期为 0.25 纳秒，或者  250 皮秒。
>
> 从程序员的角度来看，用时钟周期来表示度量标准要比用纳秒或皮秒来表示有帮助的多。

用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行的有多快。

![image-20200615163257219](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163257219.png)

![image-20200615163312419](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163312419.png) 

![image-20200615163324787](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163324787.png)

#### 5.3 程序示例

![image-20200615163616354](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163616354.png)

#### 5.4 消除循环的低效率

> 需配合 3.6.7 阅读

略。

#### 5.5 减少过程调用

过程调用会带来开销，妨碍大多数形式的程序优化。

![image-20200615165816804](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615165816804.png)

#### 5.6 消除不必要的内存引用

略。

#### 5.7 理解现代处理器（重要）

到目前为止，我们运用而优化都不依赖于目标机器的任何特性。

这些优化只是简单地降低了过程调用的开销，以及消除了一些重大的"妨碍优化的因素"，这些因素会给优化编译器造成困难。

随着试图进一步提高性能，必须考虑利用处理器 `微体系结构`　的优化，也就是处理器用来执行指令的底层系统设计。

要想充分提高性能，需要仔细分析程序，同时代码的生成也要针对目标处理器进行调整。尽管如此，我们还是能够运用一些基本的优化，在很大一类处理器上产生整体的性能提高。

![image-20200615172221908](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615172221908.png)

对这些微处理器运行的原则有一般性的了解就足够能够理解它们如何实现指令级并行。

我们发现两种下界描述了程序的最大性能：

* 延迟界限

  > 当一系列操作必须按照严格顺序执行时，就会遇到 `延迟界限(latencybound)` ，因为在下一条指令开始前，这条指令必须结束。 
  >
  > 当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制的程序性能。

* 吞吐量界限(throughputbound)

  > 吞吐量界限　刻画了处理功能单元的原始计算能力。
  >
  > 这个接线时程序性能的终极限制。

##### 5.7.1 整体操作(原理)

![image-20200615174146579](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174146579.png)

![image-20200615174207244](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174207244.png)

![image-20200615174355365](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174355365.png)

##### 5.7.2 功能单元的的性能(理解)

重要概念：

* 延迟(latency)

  > 表示完成运算所需要的总时间。

* 发射时间(issue time)

  > 表示两个连续的同类型的运算之间需要的最小时钟周期数。

* 容量(capacity)

  > 表示能够执行该运算的功能单元的数量。

![image-20200615175738747](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615175738747.png)

我们看到，从整数运算到浮点数运算，延迟是增加的。

还可以看到加法和乘法运算的发射时间都为1，意思是说在每个时钟周期，处理器都可以开始一条新的这样的运算。

这种很短的发射时间是通过使用 `流水线` 实现的。

流水线化的功能单元实现为一系列的阶段(stage) ，每个阶段完成一部分的运算。

例如，一个典型的浮点加法器包含三个阶段（所以有三个周期的延迟）:

* 一个阶段处理指数值
* 一个阶段将小数相加
* 一个阶段对结果进行舍入

算数运算可以连续的通过各个阶段，而不用等待一个操作完成后再开始下一个。

只有当要执行的运算是连续的、逻辑上独立的时候，才能利用这种功能。

发射时间为 1 的功能单元被称为 `完全流水线化的(fully pipelined)` :

> 即，每个时钟周期可以开始一个新的运算。
>
> 出现容量大于1的运算是由于有多个功能单元，就如前面所述的参考机一样。

我们还看到，除法器（用于整数和浮点除法，还用来计算浮点平方根）不是完全流水线化的：

>它的发射时间等于它的延迟。
>
>这就意味着在开始一条新运算之前，除法器必须完成整个除法。
>
>我们还看到，对于除法的延迟和发射时间是以范围的形式给出的，因为某些被除数和除数的组合比其他的组合需要更多的步骤。
>
>除法的长延迟和长发射时间使之成为了一个相对开销很大的运算。

表达发射时间的一种更常见的方法是指明这个功能单元的 `最大吞吐量`，定义为发射时间的倒数。

一个完全流水线化的功能单元有最大的吞吐量，每个时钟周期一个运算，而发射时间较大的功能单元的最大吞吐量比较小。

具有多个功能单元可以进一步提高吞吐量。

对一个容量为 C ，发射时间为 I 的操作来说，处理器可能获得的吞吐量为 每时钟周期 C/I 个操作。

> 可能的吞吐量 = 容量(C) / 发射时间(I)

比如，我们的参考机可以每个时钟周期执行两个浮点乘法运算。

我们将看到利用这种能力来提高程序的性能。

![image-20200615235045898](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615235045898.png)

##### 5.7.5 处理器操作的抽象模型

略。

#### 5.8 循环展开

略。

#### 5.9 提供并行性

在此，程序的性能是受运算单元的延迟限制的。

不过，正如我们表明的，执行加法和乘法的功能单元是完全流水线化的，这意味着它们可以每个时钟周期开始一个新操作，并且有些操作可以被多个功能单元执行。

硬件具有以更高速率执行乘法和加法的潜力，但是代码不能利用这种能力，即使使用循环展开也不能，这是因为我们将累积值放在一个单独的变量 acc 中。

在前面的计算完成之前，都不能计算 acc 的新值。

虽然计算 acc 新值的功能单元能够每个时钟周期开始一个新的操作，但是它只会每  L 个周期开始一条新操作，这里 L 是合并操作的延迟。

现在我们要考察打破这种顺序相关，得到比延迟界限更好性能的方法。

> 临时局部变量 acc ：（累积器 accumulator 的简写）

##### 5.9.1 多个累积变量

对于一个可结合可交换的合并运算来说，比如说整数加法或乘法，**我们可以通过将一组合并原酸分割成两个或更多的部分，并在最后合并结果来提高性能**。

![image-20200617233036135](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233036135.png)

##### 5.9.2 重新结合变换(需回顾)

现在来探讨另一种打破顺序相关从而使性能提高到延迟界限之外的方法。

我们看到过做 k X 1 循环展开的 combine5 没有改变合并向量元素形成和或者乘积中执行的操作。

不过，对代码做很小的改动，我们可以从跟不上改变合并执行的方式，也极大地提高程序的性能。

![image-20200617233315829](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233315829.png)

![image-20200617233337386](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233337386.png)

![image-20200617233400618](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233400618.png)

总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。

大多数编译器不会尝试对浮点运算做重新结合，因为这些运算不保证是可结合的。

当前的 GCC 版本会对整数运算执行重新结合，但不是总有好的效果。

通常，我们发现循环展开和并行地累积在多个值中，是提高程序性能的更可靠的方法。

#### 5.10 优化合并代码的结果小结

![image-20200617234100798](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617234100798.png)

> CPE 的解释在 5.2 小节

#### 5.11 一些限制因素

我们已经看到在一个程序的数据流图表示中，关键路径指明了执行该程序所需时间的一个基本的下界。

也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于 T ，那么这个程序至少需要 T 个周期才能执行完。

我们还看到功能单元的吞吐量界限也是程序执行时间的一个下界。

也就是说，假设一个程序一共需要 `N` 个某种运算的计算，而微处理器只有 `C` 个能执行这个操作的功能单元，并且这些单元的发射时间为 `I` 。那么这个程序的执行至少需要 `N* I/C` 个周期。

##### 5.11.1 寄存器溢出

循环并行性的好处受汇编代码描述计算的能力限制。

如果我们的并行度 p 超过了可用的寄存器数量，那么编译器会诉诸 `溢出(spilling)` ，将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。

举个例子，将 combine6 的多累积变量模式扩展到 k = 10 和 k = 20 ，其结果比较如下表示：

![image-20200617235008514](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617235008514.png)

![image-20200617235034429](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617235034429.png)

##### 5.11.2 分支预测和预测错误惩罚

> 与小节 3.6.6 、小节 4.5.7 有关联，必要时返回相应章节看一下。

 