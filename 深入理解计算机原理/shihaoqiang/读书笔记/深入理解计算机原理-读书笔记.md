# 深入理解计算机系统-读书笔记

## 第1天 - 2020.06.01

个人觉得这本书第一章是对本书知识地图的梳理，一个引导建立对本书完整概念的一章，比较重要，阅读的细一些，会仔细理解比较重要的概念，阅读进度较慢，阅读到 1.8 系统之间利用网络通信。

### 第一章：计算机系统漫游

> 本章前言，了解到1个信息点：C编程语言经典教材[61]
> 后续有时间可以查阅一下。

#### 1.1 信息就是位 + 上下文

* 8位 构成 1字节

* 字节构成字，字在不同操作系统上表示大小不同

* ASCII 编码很重要，其他非英文编码的包含，应该有指的是 UTF8

* 理解 hello.c 这种源文件，在计算存储中的表示方式

  > 字符 -> ASCII -> 数字 -> 二进制

* 初步揭示了Linux系统中一些都是数据文件

* 重要概念：数字在机器中的表示方式，是对真值的近似值，会有坑

#### 1.2 程序被其他程序翻译成不同的的格式

* 将源码翻译成可执行文件的 `四个阶段程序` 及对应的 `四个过程`
  * 预处理器(cpp)   
    * hello.c(源文本) -> hello.i(插入依赖库源码的源文本)
  * 编译器（ccl）
    * hello.i -> hello.s（汇编代码-文本格式）
  * 汇编器（as）
    * hello.s -> hello.o （可重定位目标程序 - 二进制了）
  * 链接器（ld）
    * hello.o & printf.o(依赖库) -> hello （整hello.o和依赖库）
    * 最终完成的可执行文件就是 hello

#### 1.3 了解编译系统如何工作大有益处

理解编译系统如何工作的，可以帮助达成以下目标：

* 优化程序性能

* 理解链接时出现的错误

  > 这个在NDK编译中很有帮助

* 避免安全漏洞

#### 1.4 处理器读并解释存储在内存中的指令

* 可执行程序的二进制被载入到内存中，从而执行指令

##### 1.4.1 系统的硬件组成

* 总线

  * 贯穿系统全局的管道，用于跟各部分交互传输数据，大交通动脉

* I/O设备

  * 系统中几乎所有配件设备都可以归纳为I/O设备
  * I/O设备的类型可以分为 控制器和适配器
    * 控制器是主板或者鼠标这类自带芯片的设备
    * 适配器是插在主板插槽上的辅助设备

* 主存

  * 应该指的就是内存（第6章会介绍存储技术）

* 处理器（CPU）

  * 重要概念：`寄存器` 和 `程序计数器(PC)`

    * PC 指向的永远是当前内存中要执行的指令，这个很重要 

  * 系统基于CPU层面的执行模型

    * 就是不断执行计数器（PC）指向地址上的程序
    * 更新程序计数器就操纵了执行执行，这个由`指令集架构决定`

  * CPU的关联硬件

    * 主存

    * 寄存器文件

    * 算数/逻辑单元（ALU）

      > 用来进行寄存器的加减逻辑运算操作
      >
      > 计算新的数据和地址值，配合刷新PC，控制程序执行

    * CPU可能做的操作

      > 加载、存储、操作、跳转
      >
      > 这些都是为了配合PC控制程序执行

  * 两个概念区分

    * 指令集架构 - 针对机器代码指令的效果
    * 微体系结构 - 指处理器的实现

    > 指令集架构在同一架构下，指令的效果应该是相同的
    >
    > 微体系结构上处理器的实现，可能各有差异
    >
    > 理解一下，应该就是 Intel和AMD同样指令集下，可以让程序跑出相同的目标效果，但是处理器实现上却可能存在差异。

##### 1.4.2 运行 hello 程序

介绍执行程序的流程中，通过总线连接CPU、内存、IO设备的整个关系。

#### 1.5 高速缓存至关重要

由于 寄存器、内存的速度差异巨大，而寄存器贵，内存便宜，那么中间的高速缓存就很有必要了。

> 例如，或许可以理解 I7 ，I5 每一代的 二级缓存，三级缓存的意义了

#### 1.6 存储设备形成层次结构

概念上跟Android中的三级缓存意义差不多，只不过增加了硬件方面的 寄存器和 L1 ，L2 高速缓存，实现的目的和原理是基本一致的。

#### 1.7 操作系统管理硬件

> 一个很重要的概念：操作系统为应用程序屏蔽了硬件的差异。
>
> 让应用程序的开发可以更简单，大部分程序开发是面向操作系统的。

##### 1.7.1 进程

* 重要概念：进程是抽象出来的让程序貌似独占资源的虚拟概念。

  > 进程的抽象出来，让程序貌似独占资源，大大简化了面向编程人员的复杂性。
  > 进程是计算机科学中最重要和最成功的概念之一。

* 重要概念：上下文

  * 为了CPU可以执行多个进程程序，操作系统设计了上下文

  * 每个进程程序对应一个上下文，操作系统通过切换上下文，来切换程序对CPU资源的使用。

  * 而上下文的切换是由操作系统内核来管理的

    > 内核不是一个独立的进程。
    >
    > 它是系统管理全部进程所用代码和数据结构的集合。

* 上下文概念的通用性

  > 关于上下文这个概念，在编程中普遍存在。
  >
  > Android中的Context，Kotlin协程中的 Dispatch.IO ，这些上下文的概念是普适性的，原理上都是一致的，都是为了保存环境信息，切换执行再恢复执行，需要用到保存的上下文信息。

##### 1.7.2 线程

多线程的开销比多进程小，多线程可以容易的共享进程数据，多线程共享一个进程的上下文，多线程可以提高性能。

> 进程 -> 多线程 -> 协程，都是为了尽可能减少开销

##### 1.7.3 虚拟内存

虚拟内存也是一个抽象概念，给进程一个假象，好像每个进程都独占的使用内存。

* 重要概念：每个进程看到的内存是一致的，称为 `虚拟地址空间`

* 虚拟地址空间的构成

  * 程序代码和数据

  * 堆（动态分配大小）

  * 共享库

  * 栈（动态分配大小）

  * 内核虚拟内存

    > 地址空间顶部区域为内核保留，不允许应用程序来读写这个区域。

* 上述介绍地址空间的构成，是从 程序代码 -> 内核虚拟内存地址是递增的。

##### 1.7.4 文件

Linux系统中几乎一切都可以表示为文件。所有的操作都是统一的 Unix I/O 来通过读写文件实现。这个机制精简却很强大。

## 第2天 - 2020.06.02

#### 1.8 系统之间利用网络通信

文件就是字节序列。网络也是一种特殊的IO设备，可以直接在计算机之间进行数据传递。抛开实现上的细节，从IO概念上看，网络这种IO设备运作原理上跟其他IO设备是一致的，都是对文件字节序列的读写传输。

#### 1.9 重要主题

系统是硬件和软件互相交织的集合体，共同协作达到运行应用程序的目的。

##### 1.9.1 Amdahl 定律

吉恩·阿姆达尔定律 ， 很重要，可以用来指导进行性能优化。

* 理解过程

  > Told = 100; // 原始性能花费时间
  > a = 0.2; // 部分原占比 a*Told=20
  > k = 200% = 2.0; // 性能的提升 1.0 ，那么 a / k * Told = 0.2 / 2 * 100 = 10  
  >
  > 推导出：(a*Told) / k = (0.2 * 100) / 2.0 = 20 / 2 = 10
  >
  > 验证 Tnew = (1-a)*Told + (a*Told)/k = Told*[(1-a) + a/k]
  >
  >  Tnew = (1-0.2)*100 + (0.2*100)/2.0 = 80 + 10 = 90
  >       = 100*[(1-0.2)+0.2/2.0] = 100 * [0.8+0.1] = 90
  >
  > 加速比公式：S = Told/Tnew 
  > 代入 求Told 和 Tnew 的公式可得： S =  1/(1-a) + a/k
  >
  > 验证计算加速比 S = 1 / (1-0.2) + 0.2/2.0 =  1/0.8 + 0.1 = 5/4 + 0.1 =  1.25 + 0.1 = 1.35
  >
  > 1/[(1-0.2) + 0.2/2] = 1 / [0.8+0.1] = 1/0.9 = 1.11 
  >
  > 这里面综合考虑了对部分的加速，作用于整个系统中的效果。
  >
  > 计算 Told 和 Tnew 的计算公式，应用的 a 和 k 都是相对于部分的。k 的性能提升比例，指的是相对于部分的 a 的比例。计算对系统的加速比是计算部分的这个加速，应用于整个系统上，加速效果是多少。
  >
  >
  > 这里会出现一个现象：虽然我们对系统的一个主要部分做出了重大改进，但是获得系统加速比却可能明显小于这部分的加速比。
  > 举例子，设 系统某个部分初始耗时比例为 60% (a=0.6) ，其部分的加速比因子为 3 (k=3) 。则我们可以获得的整个系统的加速比为 1/[0.4+0.6/3] = 1.67 倍。
  > 这个例子表明了上面的现象，虽然对主要部分做出来重大改进，但是系统获得的加速比却明显小于这部分的加速比。
  >
  > Gene Amdahl（吉恩·阿姆达尔）定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
  >
  > 关于理解相对性能的比例概念有两种方式。
  > 推荐方式：Told/Tnew .
  > 其中Told 为原始系统所需时间，Tnew 为修改后系统所需时间。如果有所改进，则比值应大于1。用后缀 "X" 来表示比例，因此，"2.2X" 读作“2.2倍”。
  >
  > ---------
  >
  > 1.9.1 - Exercise - 1.1
  >
  > 1.9.1 - Exercise - 1.2
  > S = 1 / ((1-a)+a/k)
  >
  > 1.67X = 1 / (1-0.6 + 0.6/k)
  >
  > 1.67 = 1/ (0.4+0.6/k)
  >
  > 0.4+0.6/k = 1/1.67 = 1/(5/3) = 3/5 = 0.6
  >
  > 0.6/k = 0.2
  > k = 0.6/0.2 = 3

##### 1.9.2 并发和并行

* 三个主要层次

  * 线程级并发

    > 多核处理器促进了线程级并发

  * 指令级并行

    > 以 8086 为最简单的理解结构。
    >
    > 在第5章中会重点介绍这部分内容

  * 单指令、多数据并行

    > 在最低层次上，将一条指令产生多个可以并行执行的操作。
    >
    > 这种操作成为 单指令、多数据。SIMD并行。
    >
    > 目的都是为了提高CPU的处理效率。

##### 1.9.3 计算机系统中抽象的重要性

四个重要的抽象概念：

* 文件
  * 对I/O设备的抽象
* 虚拟内存
  * 对程序存储器的抽象（包含文件I/O设备和主存）
* 进程
  * 对一个正在的运行程序的抽象（包含处理器、主存和I/O设备）
  * 1.7 也有相关概念介绍
* 虚拟机
  * 对整个计算机的抽象（包含 操作系统、处理器、程序）
  * 主要目的是为了让计算机能够运行为不同操作系统设计的程序

##### 1.10 小结

三个基本抽象重要，重复一下：

（1）文件是对I/O设备的抽象

（2）虚拟内存是对主存和磁盘的抽象

（3）进程是对处理器、主存和I/O设备的抽象

> 网络是一种特殊的I/O设备，提供了计算机系统之间的通信手段。



### 第二章：信息的表示和处理

> 使用二进制作为计算机进制是因为它非常易于用电路表示，并且简单可靠。

* 三种最重要的数字表示
  * 无符号（unsigned）编码
    * 基于传统的二进制表示法
    * 表示大于或等于零的数字
  * 补码（two's-complement）编码
    * 表示有符号整数的最常见的方式
    * 有符号整数就是可以为正或者为负的数字
  * 浮点数（floating-point) 编码
    * 表示实数的科学计数法的2为基数的版本

> 计算机表示法用有限数量的位来对一个数字编码
>
> 因此会可能出现溢出，了解这些知识可以避免一些安全漏洞

> 各种编码基本定义、属性、位级表示、算数运算属性。

* GCC指定不同的C语言版本进行编译

![image-20200603231218929](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200603231218929.png)

#### 2.1 信息手册

> 大多数计算机使用 8位 一个字节，作为最小可寻址的内存单位。
>
> 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
>
> 内存的每个字节都由一个唯一的数字来标识，称为内存地址。
>
> 所有可能的地址的集合就称为 虚拟地址空间。

> 虚拟地址空间只是一个展现给机器级程序的概念，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组（第9章有讲解）。



##### 2.1.1 十六进制表示法

> 一个字节可以用两个十六进制来表示。
> 解释：
> 一个字节有8位   0000 0000 ，表示为16进制就是 0x00。
> 从另一个角度，16 = 2^4 ，也就是可以用四个2进制表示一个十六进制。

* 十六进制解释

![image-20200604000357644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000357644.png)

* 十六进制和二进制的转换

![image-20200604000547479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000547479.png)

* 练习题 2.1

  > A:
  > 0x 3 9 A 7 F B
  > 0011 1001 1010 0111 1111 1011
  >
  > B:
  > 1100 1001 0111 1011
  > 8421 8421 8421 8421
  > 8+4  8+1  4+2+1 8+2+1
  > C    9    7     B
  >
  > C:
  > 0x D  5  E  4  C
  >
  > 1101 0101 1110 0100 1100 
  >
  > D:
  >
  > 0010 0110 1110  0111  1011  0101
  > 8421 8421 8421  8421  8421  8421
  > 2    4+2  8+4+2 4+2+1 8+2+1 4+1
  > 2    6    E     7     B     5

* 十六进制和十进制换算方法

![image-20200604003019854](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604003019854.png)

> 以上列举的是转换的计算方法，实际应用中直接用计算器算

* 练习题 2.4

  > A:
  > 0x 803c 
  > +
  > 0x    8
  > 8044
  > B:
  > 0x 503c
  > -
  > 0x   40
  > 4EEc
  > C:
  > 0x 503c
  >
  > + 64
  >   50A0
  >   D:
  >   0x 50ea
  >   -
  >   0x 503c
  >     AE
  >
  >   A B C D E F
  >   10 11 12 13 14 15

##### 2.1.2 字数据大小

![image-20200604233606380](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604233606380.png)

   32位系统最大支持内存，2^32 byte  = 4GB 

* 位（bit） -> 比特

  >  计算机内部存储的最小单位。表示二进制位。
  >
  >  11010100 是一个8位二进制。

* 字节（byte）-> 拜特 / B

  > 字节是计算机数据处理的基本单位。
  >
  > 8位 构成 1字节 => 8bit = 1byte

* 字（word）

  > 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。
  > 一个字通常由一个或多个字节构成。
  >
  > 例如，
  > ​	    286微机的字由2个字节组成，它的字长为16；
  > ​        486微机的字由4个字节组成，它的字长为32；
  > 计算机的字长决定了其CPU一次操作处理实际位数是多少，由此可见计算机的字长越大，其性能越优越。

  * 字长概念的解释

    > 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位，16 位，32 位数据，但是处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
    >
    > 其实，CPU 指令集众多，各种例外是难免的。比如，8088 处理 16 位操作数的时候，只要不涉及主内存（只是立即数或者寄存器）就不花费额外周期，否则花费额外周期。所以称为准 16 位。再比如，如今的支持 SSE 指令集的 CPU，所称的字长从历史角度考虑，根本就没把 SSE 这种单指令多数据的情况算进去。
    >
    > 而且，字长还经常会从地址总线宽度，数据总线宽度这类概念借用过来。总之，说 64-bit CPU，32-bit CPU 的时候，明白自己指什么就好，不必拘泥于字长这个概念。
    >
    > 引用描述地址：https://www.zhihu.com/question/20536161



##### 2.1.3 寻址和字节顺序

大部分程序对象是跨越多字节的。那么对理解这个对象的存储需要理解两个重要概念。

两个重要规则概念：

* 对象的地址是什么

  * 多字节对象被存储为连续的字节序列

  * 对象地址为所使用的字节中最小的地址。

    > 假设，一个类型为 int 的变量 x 的地址为 0x100 ，也就是说，地址表达式 &x 的值为 0x100.
    >
    > 那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的 0x100、0x101、0x102和0x103位置。

* 内存中如何排列这些字节

  * 大端法、小端法
  * 大部分Intel和手机用小端法

![image-20200605000645086](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605000645086.png)



概念：

> 设 变量 x 类型为 int , 位于地址 0x100 处, 它的十六进制为 0x01234567.
>
> 注意：在字 0x01234567 中
>
> * 高位字节的十六进制为 0x01
> * 低位字节的十六进制为 0x67

* 大端法
  * 最高有效字节在最前面的方式，成为大端法
* 小端法
  * 最低有效字节在最前面的方式，称为小端法

![image-20200605003613984](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605003613984.png)

关于字节顺序的大端法和小端法需要注意的事项：

* 在大端法和小端法的两种类型机器间传递数据时，需要注意可能会出现接收方字节成反序的问题。
* 避免这类问题的方法是，网络应用程序的代码必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部的表示转换成网络标准，而接收方机器则将网络标准转换成它的内部表示。（第11章中会讲转换例子）

反汇编器概念：

> 反汇编器是一种确定可执行程序文件【所表示的指令序列】的工具。
>
> 第3章将学习这部分内容。

![image-20200605004405153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605004405153.png)



![image-20200605005917616](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605005917616.png)

* C中特殊转换指针类型的方法

  > typedef unsigned char *byte_pointer



* 弄明白 Clion 在Windows 和 Linux 上的配置

  * Windows上模仿Linux专属组件
    * MinGW
      * Minimalist GNU for Windows
      * 用于开发原生（32位）Windows应用的开发环境。
      * 主要提供了针对win32应用的GCC、GNU binutils 等工具。 
      * MinGW能替代cl编译不包含MFC，以WinSDK为主的应用。
      * MinGW被CodeBlocks，DevC++等选为Windows版本的默认编辑器
      * 据上一条可以理解，为什么可以依靠安装DevC++来配置Windows的C开发环境。
    * Cygwin
      * RedHat 项目，提供运行于Windows平台的类Unix环境。
        * 以GUN工具为代码
        * 提供一套抽象的dll，将Posix调用转换成Windows的API
    * msys
      * 提供一个较小的类Unix环境
    * mingw-w64
      * MinGW-w64是新一代MinGW
      * 支持更多API
      * 支持64位应用开发

* 验证代码

  ```c
  #include <stdio.h>
  
  typedef unsigned char *byte_pointer;
  
  void show_bytes(byte_pointer start,size_t len){
      size_t i;
      for(i = 0; i < len; i++){
          printf(" %.2x",start[i]);
      }
      printf("\n");
  }
  
  void show_int(int x){
      show_bytes((byte_pointer) &x,sizeof(int));
  }
  
  void show_float(float x){
      show_bytes((byte_pointer) &x,sizeof(float));
  }
  
  void show_pointer(void *x){
      show_bytes((byte_pointer) &x,sizeof(void *));
  }
  
  void test_show_bytes(int val){
      int ival = val;
      float fval = (float )ival;
      int *pval = &ival;
      show_int(ival);
      show_float(fval);
      show_pointer(pval);
  }
  
  int main() {
      test_show_bytes(12345);
      return 0;
  }
  
  ```

  > windows x64 系统输出 :
  >
  > 39 30 00 00
  > 00 e4 40 46
  > 0c fe 61 00 00 00 00 00



* 相关思考

```
同样123456编码， 整型内存字节表示为：0x00003039 ，浮点数表示为 0x4640E400

00003039
0000000000000000001 1000000111001
4640E400
010001100           1000000111001     0000000000

将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列(1000000111001)

这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。


思考：从二进制 0101011000 这些数学表示，反推转换成 十六进制，十进制，都是没有疑问的。

但是从输入层二进制推，就出现了疑惑，为什么Java里的byte输入是10进制？例如 byte[] keys = {60,61}

但继续思考这个同样的123456值，分别用整数型和浮点型转换为十六进制后，在内存字节上表示不同，但是又有13位是相同的二进制，

 ** 那么可以推测整数型123456的内存字节 0x00003039 和 浮点型的内存字节 0x4640E400 表示的是相同的值内容，

 ** 但是由于类型不同，附加了一些相关属性，所以导致123456的浮点型的内存字节多了一些符号表示。
 
 ** 标记此处，待后面验证

 [Java的byte数组的不同写法](https://blog.csdn.net/LVXIANGAN/article/details/41294989)
 [Java中Byte数组与十六进制字符串相互转换原理](https://cloud.tencent.com/developer/article/1385802)


数学符号大全：
https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8
```



##### 2.1.4 表示字符串

* 编码验证

  ```c
  void test_char(){
      const char *s = "abcdef";
      show_bytes((byte_pointer)s,strlen(s));
  }
  int main() {
      test_show_bytes(12345);
      test_char();
      return 0;
  }
  ```

  输出结果：

  >  39 30 00 00
  >  00 e4 40 46
  >  0c fe 61 00 00 00 00 00
  >  61 62 63 64 65 66  // abcdef 的ASCII码

* 相关编码集 ASCII、Unicode

* 编码考虑的事情

  * 能够包含大多数字符
  * 在包含大多数字符的情况下，如何保证合理占用字节空间
  * 路哥提供的哈夫曼编码压缩方法，可以合理处理这个问题

##### 2.1.5 表示代码

> 不同的机器类型使用不同的且不兼容的指令和编码方式，即使完全一样的进程，运行在不同操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。



##### 2.1.6 布尔代数运算

![image-20200606184319815](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606184319815.png)

* 布尔运算〜

  * 对应于逻辑运算 NOT

    > 当 P 不是真的时候，我们就说"T3 是真的，反之亦然。相应地，当 P 等于 0 时，〜P 等于1, 反之亦然。

* 布尔运算&

  * 对应于逻辑运算AND

    > 当P和Q都为真时，为真

* 布尔运算符 |

  * 对应逻辑运算 OR

    > 当 p=1 或者 q=1 时，p|q等于1.

* 布尔运算 ^

  * 对应逻辑运算异或

    > 当P 或者Q 为真但不同时为真时，成立。
    >
    > 当 p = 1 且 q = 0，或者 p=0 且 q=1时，p^q等于1



> 这一小节对应逻辑符号的描述，帮助理解了以前上的一门课，逻辑课，用来进行逻辑推理的公式，原来就是用计算机的数学逻辑来表示的！



* 重点概念：位向量

  > 位向量就是固定长度为 w ，由 0 和 1 组成的串。
  >
  > 位向量运算，可以定义成参数的每个对应元素之间的运算。

* 练习题 2.9 增进理解Android中对颜色的处理

* ![img](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/20160422211037563.gif)

* 练习题 2.10 帮助理解自定义View的重要环节 onMeasure 测量

  * 测量模式和测量值的存储和解析

  > //对应11000000000000000000000000000000;总共32位，前两位是1
  > int MODE_MASK  = 0xc0000000;
  >
  > //提取模式
  > public static int getMode(int measureSpec) {
  >  return (measureSpec & MODE_MASK);
  > }
  > //提取数值
  > public static int getSize(int measureSpec) {
  >  return (measureSpec & ~MODE_MASK);
  > }

​       练习题回答：

       ```

*x = a, *y = b

*y = *x ^ *y = a ^ b
*x = *x ^ *y = a ^ (a ^ b) = 0 ^ b = b 
*y = *x ^ *y = (0 ^ b) ^ ( a ^ b) = b ^ (a ^ b) = a 
       ```



* 练习题 2.11

  * 练习题回答

    ```
    A.
    end : first = k ; last = k
    B.
    此时 a[frist] = a[last]
    基于 ^ 的原理，a^a = 0; 所以，此时为0。
    C.
    跳过这个不替换。方法是 让for循环的条件排除 frist = last。也就是 将 first <= last 改为 first < last.
    ```



##### 2.1.7 C语言中的位级运算

![image-20200607135724336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607135724336.png)

* 从上图可以看出，根据 0xFF 的二进制是 [1111 1111] ，可以推出重要结论:

  * 当 `0x41 & 0xFF`  时，转换为二进制位运算，可以得到的是 `0x41` 本身。

    >​    0x41        0100  0001
    >&  0xFF        1111  1111
    >=  0X41        0100   0001

  * 当`0x41 & 0x00` 时，转换为二进制位运算，可以得到`0x41`被消减为0。

    >​    0x41        0100  0001
    >&  0x00       0000  0000
    >=  0x00        0000   0000

    这说明，可以用 数值 x 与 `0xFF` 或者 `0x00` 来进行位运算，来消减不想要的位，保留想要的位。

    再配合 `& | ~ ^` 这些布尔代数逻辑运算符，就可以进行各种位操作了。

![image-20200606183953489](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606183953489.png)



* 练习题 2.12

  * A 

    ```
    这个很简单，按照 x & 0xFF = x ，的二进制位运算推导出来
    x=0x87654321
    x & 0xFF = 0x87654321 = 0x000000FF & 0x87654321 = 0x0000021 
    ```

  * B

    ```
    B.
    
     0x  87 65 43 21   -> ‭ 1000 0111‬   ‭0110 0101‬    0100 0011‬   ‭0010 0001‬ 
     
    ^
    
    ~0x  00 00 00 FF    -> 0000 0000   0000 0000    0000 0000   1111 1111   
         FF FF FF 00    -> 1111 1111   1111 1111    1111 1111   0000 0000   
    
     0x  78 9A BC 21    -> 0111 1000   1001 1010    1011 1100   0010 0001  
     
     > 涉及到的知识点：1字节=8位，2^4 = 16 , 也就是4位存放1个16进制，1字节=8位=2个16进制.
     > 以这种存储方式，把数据全部转换为二进制进行运算，就得出了位运算。
    ```

  * C

    ```
     0x 87654321 & ~0xFF | 0xFF
     ->标准答案：
     0x 87654321 |0xFF 
     -> 原因：
     在二进制层面，任何位 | 0xFF 都是 0|1=1，所以会全是1，也就是 x|F=F
    ```

    ![image-20200607152653648](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607152653648.png)



##### 2.1.8 C语言中的逻辑运算符

![image-20200608223146297](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223146297.png)

按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

##### 2.1.9 C语言中的移位运算

![image-20200608223428838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223428838.png)

> 几乎所有的编译器、机器组合都对有符号数使用算术右移，且许多程序员也假设机器会使用这种右移。另一方面，对无符号数，右移必须是逻辑的。
>
> 与C相比，Java对于如何进行右移有明确的定义。表达式 x>>k 会将 x 算术右移 k 个位置，而  x>>>k 会对 x 做逻辑右移。

![image-20200608223838205](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223838205.png)



#### 2.2 整数表示

![image-20200609231804178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231804178.png)

##### 2.2.1 整型数据类型

![image-20200609231848641](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231848641.png)

> C 和 C++ 都支持有符号（默认）和无符号数。Java只支持有符号数。

##### 2.2.2 无符号数的编码

![image-20200609232141626](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232141626.png)

![image-20200609232221336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232221336.png)

##### 2.2.3 补码编码

![image-20200609232301739](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232301739.png)

![image-20200609232321093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232321093.png)

![image-20200609232350969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232350969.png)

![image-20200609232420691](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232420691.png)

##### * 2.2.4 有符号数和无符号数之间的转换

重要概念：对于有符号数和无符号数之间的转换，是用不同的解释方式去解释二进制位，但是本质上的二进制位并没有改变，只是改变了解读的方式，所以解读成了不同的数值。

![image-20200609233037797](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233037797.png)

##### 2.2.5 C 语言中的有符号数与无符号数

> 几乎所有的机器使用补码。通常，大多数数字都默认为是有符号的。
>
> C语言中，当声明一个像 12345 或者 0x1A2B 这样的常量时，默认是有符号的。
>
> 要创建一个无符号常量，必须加上后缀字符“U”或者"u"，
>
> 例如：12345U 或者 0x1A2Bu.

![image-20200609233503663](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233503663.png)

##### * 2.2.6 扩展一个数字的位表示

![image-20200609234051890](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234051890.png)



##### 2.2.7 截断数字

![image-20200609234645555](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234645555.png)

![image-20200609234656316](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234656316.png)

![image-20200609234709178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234709178.png)

##### 2.2.8 关于有符号数与无符号数的建议

> 略过

#### 2.3 整数运算





