# 深入理解计算机系统-读书笔记

## 第1天 - 2020.06.01

个人觉得这本书第一章是对本书知识地图的梳理，一个引导建立对本书完整概念的一章，比较重要，阅读的细一些，会仔细理解比较重要的概念，阅读进度较慢，阅读到 1.8 系统之间利用网络通信。

### 第一章：计算机系统漫游

> 本章前言，了解到1个信息点：C编程语言经典教材[61]
> 后续有时间可以查阅一下。

#### 1.1 信息就是位 + 上下文

* 8位 构成 1字节

* 字节构成字，字在不同操作系统上表示大小不同

* ASCII 编码很重要，其他非英文编码的包含，应该有指的是 UTF8

* 理解 hello.c 这种源文件，在计算存储中的表示方式

  > 字符 -> ASCII -> 数字 -> 二进制

* 初步揭示了Linux系统中一些都是数据文件

* 重要概念：数字在机器中的表示方式，是对真值的近似值，会有坑

#### 1.2 程序被其他程序翻译成不同的的格式

* 将源码翻译成可执行文件的 `四个阶段程序` 及对应的 `四个过程`
  * 预处理器(cpp)   
    * hello.c(源文本) -> hello.i(插入依赖库源码的源文本)
  * 编译器（ccl）
    * hello.i -> hello.s（汇编代码-文本格式）
  * 汇编器（as）
    * hello.s -> hello.o （可重定位目标程序 - 二进制了）
  * 链接器（ld）
    * hello.o & printf.o(依赖库) -> hello （整hello.o和依赖库）
    * 最终完成的可执行文件就是 hello

#### 1.3 了解编译系统如何工作大有益处

理解编译系统如何工作的，可以帮助达成以下目标：

* 优化程序性能

* 理解链接时出现的错误

  > 这个在NDK编译中很有帮助

* 避免安全漏洞

#### 1.4 处理器读并解释存储在内存中的指令

* 可执行程序的二进制被载入到内存中，从而执行指令

##### 1.4.1 系统的硬件组成

* 总线

  * 贯穿系统全局的管道，用于跟各部分交互传输数据，大交通动脉

* I/O设备

  * 系统中几乎所有配件设备都可以归纳为I/O设备
  * I/O设备的类型可以分为 控制器和适配器
    * 控制器是主板或者鼠标这类自带芯片的设备
    * 适配器是插在主板插槽上的辅助设备

* 主存

  * 应该指的就是内存（第6章会介绍存储技术）

* 处理器（CPU）

  * 重要概念：`寄存器` 和 `程序计数器(PC)`

    * PC 指向的永远是当前内存中要执行的指令，这个很重要 

  * 系统基于CPU层面的执行模型

    * 就是不断执行计数器（PC）指向地址上的程序
    * 更新程序计数器就操纵了执行执行，这个由`指令集架构决定`

  * CPU的关联硬件

    * 主存

    * 寄存器文件

    * 算数/逻辑单元（ALU）

      > 用来进行寄存器的加减逻辑运算操作
      >
      > 计算新的数据和地址值，配合刷新PC，控制程序执行

    * CPU可能做的操作

      > 加载、存储、操作、跳转
      >
      > 这些都是为了配合PC控制程序执行

  * 两个概念区分

    * 指令集架构 - 针对机器代码指令的效果
    * 微体系结构 - 指处理器的实现

    > 指令集架构在同一架构下，指令的效果应该是相同的
    >
    > 微体系结构上处理器的实现，可能各有差异
    >
    > 理解一下，应该就是 Intel和AMD同样指令集下，可以让程序跑出相同的目标效果，但是处理器实现上却可能存在差异。

##### 1.4.2 运行 hello 程序

介绍执行程序的流程中，通过总线连接CPU、内存、IO设备的整个关系。

#### 1.5 高速缓存至关重要

由于 寄存器、内存的速度差异巨大，而寄存器贵，内存便宜，那么中间的高速缓存就很有必要了。

> 例如，或许可以理解 I7 ，I5 每一代的 二级缓存，三级缓存的意义了

#### 1.6 存储设备形成层次结构

概念上跟Android中的三级缓存意义差不多，只不过增加了硬件方面的 寄存器和 L1 ，L2 高速缓存，实现的目的和原理是基本一致的。

#### 1.7 操作系统管理硬件

> 一个很重要的概念：操作系统为应用程序屏蔽了硬件的差异。
>
> 让应用程序的开发可以更简单，大部分程序开发是面向操作系统的。

##### 1.7.1 进程

* 重要概念：进程是抽象出来的让程序貌似独占资源的虚拟概念。

  > 进程的抽象出来，让程序貌似独占资源，大大简化了面向编程人员的复杂性。
  > 进程是计算机科学中最重要和最成功的概念之一。
  
* 重要概念：上下文

  * 为了CPU可以执行多个进程程序，操作系统设计了上下文

  * 每个进程程序对应一个上下文，操作系统通过切换上下文，来切换程序对CPU资源的使用。

  * 而上下文的切换是由操作系统内核来管理的

    > 内核不是一个独立的进程。
    >
    > 它是系统管理全部进程所用代码和数据结构的集合。

* 上下文概念的通用性

  > 关于上下文这个概念，在编程中普遍存在。
  >
  > Android中的Context，Kotlin协程中的 Dispatch.IO ，这些上下文的概念是普适性的，原理上都是一致的，都是为了保存环境信息，切换执行再恢复执行，需要用到保存的上下文信息。

##### 1.7.2 线程

多线程的开销比多进程小，多线程可以容易的共享进程数据，多线程共享一个进程的上下文，多线程可以提高性能。

> 进程 -> 多线程 -> 协程，都是为了尽可能减少开销

##### 1.7.3 虚拟内存

虚拟内存也是一个抽象概念，给进程一个假象，好像每个进程都独占的使用内存。

* 重要概念：每个进程看到的内存是一致的，称为 `虚拟地址空间`

* 虚拟地址空间的构成

  * 程序代码和数据

  * 堆（动态分配大小）

  * 共享库

  * 栈（动态分配大小）

  * 内核虚拟内存

    > 地址空间顶部区域为内核保留，不允许应用程序来读写这个区域。

* 上述介绍地址空间的构成，是从 程序代码 -> 内核虚拟内存地址是递增的。

##### 1.7.4 文件

Linux系统中几乎一切都可以表示为文件。所有的操作都是统一的 Unix I/O 来通过读写文件实现。这个机制精简却很强大。

## 第2天 - 2020.06.02

#### 1.8 系统之间利用网络通信

文件就是字节序列。网络也是一种特殊的IO设备，可以直接在计算机之间进行数据传递。抛开实现上的细节，从IO概念上看，网络这种IO设备运作原理上跟其他IO设备是一致的，都是对文件字节序列的读写传输。

#### 1.9 重要主题

系统是硬件和软件互相交织的集合体，共同协作达到运行应用程序的目的。

##### 1.9.1 Amdahl 定律

吉恩·阿姆达尔定律 ， 很重要，可以用来指导进行性能优化。

* 理解过程

  > Told = 100; // 原始性能花费时间
  > a = 0.2; // 部分原占比 a*Told=20
  > k = 200% = 2.0; // 性能的提升 1.0 ，那么 a / k * Told = 0.2 / 2 * 100 = 10  
  >
  > 推导出：(a*Told) / k = (0.2 * 100) / 2.0 = 20 / 2 = 10
  >
  > 验证 Tnew = (1-a)*Told + (a*Told)/k = Told*[(1-a) + a/k]
  >
  >     Tnew = (1-0.2)*100 + (0.2*100)/2.0 = 80 + 10 = 90
  >          = 100*[(1-0.2)+0.2/2.0] = 100 * [0.8+0.1] = 90
  >
  > 加速比公式：S = Told/Tnew 
  > 代入 求Told 和 Tnew 的公式可得： S =  1/(1-a) + a/k
  >
  > 验证计算加速比 S = 1 / (1-0.2) + 0.2/2.0 =  1/0.8 + 0.1 = 5/4 + 0.1 =  1.25 + 0.1 = 1.35
  >
  > 1/[(1-0.2) + 0.2/2] = 1 / [0.8+0.1] = 1/0.9 = 1.11 
  >
  > 这里面综合考虑了对部分的加速，作用于整个系统中的效果。
  >
  > 计算 Told 和 Tnew 的计算公式，应用的 a 和 k 都是相对于部分的。k 的性能提升比例，指的是相对于部分的 a 的比例。计算对系统的加速比是计算部分的这个加速，应用于整个系统上，加速效果是多少。
  >
  >
  > 这里会出现一个现象：虽然我们对系统的一个主要部分做出了重大改进，但是获得系统加速比却可能明显小于这部分的加速比。
  > 举例子，设 系统某个部分初始耗时比例为 60% (a=0.6) ，其部分的加速比因子为 3 (k=3) 。则我们可以获得的整个系统的加速比为 1/[0.4+0.6/3] = 1.67 倍。
  > 这个例子表明了上面的现象，虽然对主要部分做出来重大改进，但是系统获得的加速比却明显小于这部分的加速比。
  >
  > Gene Amdahl（吉恩·阿姆达尔）定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
  >
  > 关于理解相对性能的比例概念有两种方式。
  > 推荐方式：Told/Tnew .
  > 其中Told 为原始系统所需时间，Tnew 为修改后系统所需时间。如果有所改进，则比值应大于1。用后缀 "X" 来表示比例，因此，"2.2X" 读作“2.2倍”。
  >
  > ---------
  >
  > 1.9.1 - Exercise - 1.1
  >
  > 1.9.1 - Exercise - 1.2
  > S = 1 / ((1-a)+a/k)
  >
  > 1.67X = 1 / (1-0.6 + 0.6/k)
  >
  > 1.67 = 1/ (0.4+0.6/k)
  >
  > 0.4+0.6/k = 1/1.67 = 1/(5/3) = 3/5 = 0.6
  >
  > 0.6/k = 0.2
  > k = 0.6/0.2 = 3

##### 1.9.2 并发和并行

* 三个主要层次

  * 线程级并发

    > 多核处理器促进了线程级并发

  * 指令级并行

    > 以 8086 为最简单的理解结构。
    >
    > 在第5章中会重点介绍这部分内容

  * 单指令、多数据并行

    > 在最低层次上，将一条指令产生多个可以并行执行的操作。
    >
    > 这种操作成为 单指令、多数据。SIMD并行。
    >
    > 目的都是为了提高CPU的处理效率。

##### 1.9.3 计算机系统中抽象的重要性

四个重要的抽象概念：

* 文件
  * 对I/O设备的抽象
* 虚拟内存
  * 对程序存储器的抽象（包含文件I/O设备和主存）
* 进程
  * 对一个正在的运行程序的抽象（包含处理器、主存和I/O设备）
  * 1.7 也有相关概念介绍
* 虚拟机
  * 对整个计算机的抽象（包含 操作系统、处理器、程序）
  * 主要目的是为了让计算机能够运行为不同操作系统设计的程序

##### 1.10 小结

三个基本抽象重要，重复一下：

（1）文件是对I/O设备的抽象

（2）虚拟内存是对主存和磁盘的抽象

（3）进程是对处理器、主存和I/O设备的抽象

> 网络是一种特殊的I/O设备，提供了计算机系统之间的通信手段。



### 第二章：信息的表示和处理

> 使用二进制作为计算机进制是因为它非常易于用电路表示，并且简单可靠。

* 三种最重要的数字表示
  * 无符号（unsigned）编码
    * 基于传统的二进制表示法
    * 表示大于或等于零的数字
  * 补码（two's-complement）编码
    * 表示有符号整数的最常见的方式
    * 有符号整数就是可以为正或者为负的数字
  * 浮点数（floating-point) 编码
    * 表示实数的科学计数法的2为基数的版本

> 计算机表示法用有限数量的位来对一个数字编码
>
> 因此会可能出现溢出，了解这些知识可以避免一些安全漏洞

> 各种编码基本定义、属性、位级表示、算数运算属性。

* GCC指定不同的C语言版本进行编译

![image-20200603231218929](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200603231218929.png)

#### 2.1 信息手册

> 大多数计算机使用 8位 一个字节，作为最小可寻址的内存单位。
>
> 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
>
> 内存的每个字节都由一个唯一的数字来标识，称为内存地址。
>
> 所有可能的地址的集合就称为 虚拟地址空间。

> 虚拟地址空间只是一个展现给机器级程序的概念，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组（第9章有讲解）。



##### 2.1.1 十六进制表示法

> 一个字节可以用两个十六进制来表示。
> 解释：
> 一个字节有8位   0000 0000 ，表示为16进制就是 0x00。
> 从另一个角度，16 = 2^4 ，也就是可以用四个2进制表示一个十六进制。

* 十六进制解释

![image-20200604000357644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000357644.png)

* 十六进制和二进制的转换

![image-20200604000547479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000547479.png)

* 练习题 2.1

  > A:
  > 0x 3 9 A 7 F B
  > 0011 1001 1010 0111 1111 1011
  >
  > B:
  > 1100 1001 0111 1011
  > 8421 8421 8421 8421
  > 8+4  8+1  4+2+1 8+2+1
  > C    9    7     B
  >
  > C:
  > 0x D  5  E  4  C
  >
  > 1101 0101 1110 0100 1100 
  >
  > D:
  >
  > 0010 0110 1110  0111  1011  0101
  > 8421 8421 8421  8421  8421  8421
  > 2    4+2  8+4+2 4+2+1 8+2+1 4+1
  > 2    6    E     7     B     5

* 十六进制和十进制换算方法

![image-20200604003019854](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604003019854.png)

> 以上列举的是转换的计算方法，实际应用中直接用计算器算

* 练习题 2.4

  > A:
  > 0x 803c 
  > +
  > 0x    8
  > 8044
  > B:
  > 0x 503c
  > -
  > 0x   40
  > 4EEc
  > C:
  > 0x 503c
  >
  > +    64
  >    50A0
  > D:
  > 0x 50ea
  > -
  > 0x 503c
  >      AE
  >    
  >    A B C D E F
  >    10 11 12 13 14 15

##### 2.1.2 字数据大小

![image-20200604233606380](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604233606380.png)

   32位系统最大支持内存，2^32 byte  = 4GB 

* 位（bit） -> 比特

  >  计算机内部存储的最小单位。表示二进制位。
  >
  > 11010100 是一个8位二进制。

* 字节（byte）-> 拜特 / B

  > 字节是计算机数据处理的基本单位。
  >
  > 8位 构成 1字节 => 8bit = 1byte

* 字（word）

  > 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。
  > 一个字通常由一个或多个字节构成。
  >
  > 例如，
  > ​	    286微机的字由2个字节组成，它的字长为16；
  > ​        486微机的字由4个字节组成，它的字长为32；
  > 计算机的字长决定了其CPU一次操作处理实际位数是多少，由此可见计算机的字长越大，其性能越优越。
  
  * 字长概念的解释
  
    > 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位，16 位，32 位数据，但是处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
    >
    > 其实，CPU 指令集众多，各种例外是难免的。比如，8088 处理 16 位操作数的时候，只要不涉及主内存（只是立即数或者寄存器）就不花费额外周期，否则花费额外周期。所以称为准 16 位。再比如，如今的支持 SSE 指令集的 CPU，所称的字长从历史角度考虑，根本就没把 SSE 这种单指令多数据的情况算进去。
    >
    > 而且，字长还经常会从地址总线宽度，数据总线宽度这类概念借用过来。总之，说 64-bit CPU，32-bit CPU 的时候，明白自己指什么就好，不必拘泥于字长这个概念。
    >
    > 引用描述地址：https://www.zhihu.com/question/20536161



#### 2.1.3 寻址和字节顺序

大部分程序对象是跨越多字节的。那么对理解这个对象的存储需要理解两个重要概念。

两个重要规则概念：

* 对象的地址是什么

  * 多字节对象被存储为连续的字节序列

  * 对象地址为所使用的字节中最小的地址。

    > 假设，一个类型为 int 的变量 x 的地址为 0x100 ，也就是说，地址表达式 &x 的值为 0x100.
    >
    > 那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的 0x100、0x101、0x102和0x103位置。

* 内存中如何排列这些字节

  * 大端法、小端法
  * 大部分Intel和手机用小端法

![image-20200605000645086](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605000645086.png)



概念：

> 设 变量 x 类型为 int , 位于地址 0x100 处, 它的十六进制为 0x01234567.
>
> 注意：在字 0x01234567 中
>
> * 高位字节的十六进制为 0x01
> * 低位字节的十六进制为 0x67

* 大端法
  * 最高有效字节在最前面的方式，成为大端法
* 小端法
  * 最低有效字节在最前面的方式，称为小端法

![image-20200605003613984](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605003613984.png)

关于字节顺序的大端法和小端法需要注意的事项：

* 在大端法和小端法的两种类型机器间传递数据时，需要注意可能会出现接收方字节成反序的问题。
* 避免这类问题的方法是，网络应用程序的代码必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部的表示转换成网络标准，而接收方机器则将网络标准转换成它的内部表示。（第11章中会讲转换例子）

反汇编器概念：

> 反汇编器是一种确定可执行程序文件【所表示的指令序列】的工具。
>
> 第3章将学习这部分内容。

![image-20200605004405153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605004405153.png)



![image-20200605005917616](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605005917616.png)