# 深入理解计算机系统-读书笔记

## 第1天 - 2020.06.01

个人觉得这本书第一章是对本书知识地图的梳理，一个引导建立对本书完整概念的一章，比较重要，阅读的细一些，会仔细理解比较重要的概念，阅读进度较慢，阅读到 1.8 系统之间利用网络通信。

### 第一章：计算机系统漫游

> 本章前言，了解到1个信息点：C编程语言经典教材[61]
> 后续有时间可以查阅一下。

#### 1.1 信息就是位 + 上下文

* 8位 构成 1字节

* 字节构成字，字在不同操作系统上表示大小不同

* ASCII 编码很重要，其他非英文编码的包含，应该有指的是 UTF8

* 理解 hello.c 这种源文件，在计算存储中的表示方式

  > 字符 -> ASCII -> 数字 -> 二进制

* 初步揭示了Linux系统中一些都是数据文件

* 重要概念：数字在机器中的表示方式，是对真值的近似值，会有坑

#### 1.2 程序被其他程序翻译成不同的的格式

* 将源码翻译成可执行文件的 `四个阶段程序` 及对应的 `四个过程`
  * 预处理器(cpp)   
    * hello.c(源文本) -> hello.i(插入依赖库源码的源文本)
  * 编译器（ccl）
    * hello.i -> hello.s（汇编代码-文本格式）
  * 汇编器（as）
    * hello.s -> hello.o （可重定位目标程序 - 二进制了）
  * 链接器（ld）
    * hello.o & printf.o(依赖库) -> hello （整hello.o和依赖库）
    * 最终完成的可执行文件就是 hello

#### 1.3 了解编译系统如何工作大有益处

理解编译系统如何工作的，可以帮助达成以下目标：

* 优化程序性能

* 理解链接时出现的错误

  > 这个在NDK编译中很有帮助

* 避免安全漏洞

#### 1.4 处理器读并解释存储在内存中的指令

* 可执行程序的二进制被载入到内存中，从而执行指令

##### 1.4.1 系统的硬件组成

* 总线

  * 贯穿系统全局的管道，用于跟各部分交互传输数据，大交通动脉

* I/O设备

  * 系统中几乎所有配件设备都可以归纳为I/O设备
  * I/O设备的类型可以分为 控制器和适配器
    * 控制器是主板或者鼠标这类自带芯片的设备
    * 适配器是插在主板插槽上的辅助设备

* 主存

  * 应该指的就是内存（第6章会介绍存储技术）

* 处理器（CPU）

  * 重要概念：`寄存器` 和 `程序计数器(PC)`

    * PC 指向的永远是当前内存中要执行的指令，这个很重要 

  * 系统基于CPU层面的执行模型

    * 就是不断执行计数器（PC）指向地址上的程序
    * 更新程序计数器就操纵了执行执行，这个由`指令集架构决定`

  * CPU的关联硬件

    * 主存

    * 寄存器文件

    * 算数/逻辑单元（ALU）

      > 用来进行寄存器的加减逻辑运算操作
      >
      > 计算新的数据和地址值，配合刷新PC，控制程序执行

    * CPU可能做的操作

      > 加载、存储、操作、跳转
      >
      > 这些都是为了配合PC控制程序执行

  * 两个概念区分

    * 指令集架构 - 针对机器代码指令的效果
    * 微体系结构 - 指处理器的实现

    > 指令集架构在同一架构下，指令的效果应该是相同的
    >
    > 微体系结构上处理器的实现，可能各有差异
    >
    > 理解一下，应该就是 Intel和AMD同样指令集下，可以让程序跑出相同的目标效果，但是处理器实现上却可能存在差异。

##### 1.4.2 运行 hello 程序

介绍执行程序的流程中，通过总线连接CPU、内存、IO设备的整个关系。

#### 1.5 高速缓存至关重要

由于 寄存器、内存的速度差异巨大，而寄存器贵，内存便宜，那么中间的高速缓存就很有必要了。

> 例如，或许可以理解 I7 ，I5 每一代的 二级缓存，三级缓存的意义了

#### 1.6 存储设备形成层次结构

概念上跟Android中的三级缓存意义差不多，只不过增加了硬件方面的 寄存器和 L1 ，L2 高速缓存，实现的目的和原理是基本一致的。

#### 1.7 操作系统管理硬件

> 一个很重要的概念：操作系统为应用程序屏蔽了硬件的差异。
>
> 让应用程序的开发可以更简单，大部分程序开发是面向操作系统的。

##### 1.7.1 进程

* 重要概念：进程是抽象出来的让程序貌似独占资源的虚拟概念。

  > 进程的抽象出来，让程序貌似独占资源，大大简化了面向编程人员的复杂性。
  > 进程是计算机科学中最重要和最成功的概念之一。

* 重要概念：上下文

  * 为了CPU可以执行多个进程程序，操作系统设计了上下文

  * 每个进程程序对应一个上下文，操作系统通过切换上下文，来切换程序对CPU资源的使用。

  * 而上下文的切换是由操作系统内核来管理的

    > 内核不是一个独立的进程。
    >
    > 它是系统管理全部进程所用代码和数据结构的集合。

* 上下文概念的通用性

  > 关于上下文这个概念，在编程中普遍存在。
  >
  > Android中的Context，Kotlin协程中的 Dispatch.IO ，这些上下文的概念是普适性的，原理上都是一致的，都是为了保存环境信息，切换执行再恢复执行，需要用到保存的上下文信息。

##### 1.7.2 线程

多线程的开销比多进程小，多线程可以容易的共享进程数据，多线程共享一个进程的上下文，多线程可以提高性能。

> 进程 -> 多线程 -> 协程，都是为了尽可能减少开销

##### 1.7.3 虚拟内存

虚拟内存也是一个抽象概念，给进程一个假象，好像每个进程都独占的使用内存。

* 重要概念：每个进程看到的内存是一致的，称为 `虚拟地址空间`

* 虚拟地址空间的构成

  * 程序代码和数据

  * 堆（动态分配大小）

  * 共享库

  * 栈（动态分配大小）

  * 内核虚拟内存

    > 地址空间顶部区域为内核保留，不允许应用程序来读写这个区域。

* 上述介绍地址空间的构成，是从 程序代码 -> 内核虚拟内存地址是递增的。

##### 1.7.4 文件

Linux系统中几乎一切都可以表示为文件。所有的操作都是统一的 Unix I/O 来通过读写文件实现。这个机制精简却很强大。

## 第2天 - 2020.06.02

#### 1.8 系统之间利用网络通信

文件就是字节序列。网络也是一种特殊的IO设备，可以直接在计算机之间进行数据传递。抛开实现上的细节，从IO概念上看，网络这种IO设备运作原理上跟其他IO设备是一致的，都是对文件字节序列的读写传输。

#### 1.9 重要主题

系统是硬件和软件互相交织的集合体，共同协作达到运行应用程序的目的。

##### 1.9.1 Amdahl 定律

吉恩·阿姆达尔定律 ， 很重要，可以用来指导进行性能优化。

* 理解过程

  > Told = 100; // 原始性能花费时间
  > a = 0.2; // 部分原占比 a*Told=20
  > k = 200% = 2.0; // 性能的提升 1.0 ，那么 a / k * Told = 0.2 / 2 * 100 = 10  
  >
  > 推导出：(a*Told) / k = (0.2 * 100) / 2.0 = 20 / 2 = 10
  >
  > 验证 Tnew = (1-a)*Told + (a*Told)/k = Told*[(1-a) + a/k]
  >
  >  Tnew = (1-0.2)*100 + (0.2*100)/2.0 = 80 + 10 = 90
  >       = 100*[(1-0.2)+0.2/2.0] = 100 * [0.8+0.1] = 90
  >
  > 加速比公式：S = Told/Tnew 
  > 代入 求Told 和 Tnew 的公式可得： S =  1/(1-a) + a/k
  >
  > 验证计算加速比 S = 1 / (1-0.2) + 0.2/2.0 =  1/0.8 + 0.1 = 5/4 + 0.1 =  1.25 + 0.1 = 1.35
  >
  > 1/[(1-0.2) + 0.2/2] = 1 / [0.8+0.1] = 1/0.9 = 1.11 
  >
  > 这里面综合考虑了对部分的加速，作用于整个系统中的效果。
  >
  > 计算 Told 和 Tnew 的计算公式，应用的 a 和 k 都是相对于部分的。k 的性能提升比例，指的是相对于部分的 a 的比例。计算对系统的加速比是计算部分的这个加速，应用于整个系统上，加速效果是多少。
  >
  >
  > 这里会出现一个现象：虽然我们对系统的一个主要部分做出了重大改进，但是获得系统加速比却可能明显小于这部分的加速比。
  > 举例子，设 系统某个部分初始耗时比例为 60% (a=0.6) ，其部分的加速比因子为 3 (k=3) 。则我们可以获得的整个系统的加速比为 1/[0.4+0.6/3] = 1.67 倍。
  > 这个例子表明了上面的现象，虽然对主要部分做出来重大改进，但是系统获得的加速比却明显小于这部分的加速比。
  >
  > Gene Amdahl（吉恩·阿姆达尔）定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
  >
  > 关于理解相对性能的比例概念有两种方式。
  > 推荐方式：Told/Tnew .
  > 其中Told 为原始系统所需时间，Tnew 为修改后系统所需时间。如果有所改进，则比值应大于1。用后缀 "X" 来表示比例，因此，"2.2X" 读作“2.2倍”。
  >
  > ---------
  >
  > 1.9.1 - Exercise - 1.1
  >
  > 1.9.1 - Exercise - 1.2
  > S = 1 / ((1-a)+a/k)
  >
  > 1.67X = 1 / (1-0.6 + 0.6/k)
  >
  > 1.67 = 1/ (0.4+0.6/k)
  >
  > 0.4+0.6/k = 1/1.67 = 1/(5/3) = 3/5 = 0.6
  >
  > 0.6/k = 0.2
  > k = 0.6/0.2 = 3

##### 1.9.2 并发和并行

* 三个主要层次

  * 线程级并发

    > 多核处理器促进了线程级并发

  * 指令级并行

    > 以 8086 为最简单的理解结构。
    >
    > 在第5章中会重点介绍这部分内容

  * 单指令、多数据并行

    > 在最低层次上，将一条指令产生多个可以并行执行的操作。
    >
    > 这种操作成为 单指令、多数据。SIMD并行。
    >
    > 目的都是为了提高CPU的处理效率。

##### 1.9.3 计算机系统中抽象的重要性

四个重要的抽象概念：

* 文件
  * 对I/O设备的抽象
* 虚拟内存
  * 对程序存储器的抽象（包含文件I/O设备和主存）
* 进程
  * 对一个正在的运行程序的抽象（包含处理器、主存和I/O设备）
  * 1.7 也有相关概念介绍
* 虚拟机
  * 对整个计算机的抽象（包含 操作系统、处理器、程序）
  * 主要目的是为了让计算机能够运行为不同操作系统设计的程序

##### 1.10 小结

三个基本抽象重要，重复一下：

（1）文件是对I/O设备的抽象

（2）虚拟内存是对主存和磁盘的抽象

（3）进程是对处理器、主存和I/O设备的抽象

> 网络是一种特殊的I/O设备，提供了计算机系统之间的通信手段。



### 第二章：信息的表示和处理

> 使用二进制作为计算机进制是因为它非常易于用电路表示，并且简单可靠。

* 三种最重要的数字表示
  * 无符号（unsigned）编码
    * 基于传统的二进制表示法
    * 表示大于或等于零的数字
  * 补码（two's-complement）编码
    * 表示有符号整数的最常见的方式
    * 有符号整数就是可以为正或者为负的数字
  * 浮点数（floating-point) 编码
    * 表示实数的科学计数法的2为基数的版本

> 计算机表示法用有限数量的位来对一个数字编码
>
> 因此会可能出现溢出，了解这些知识可以避免一些安全漏洞

> 各种编码基本定义、属性、位级表示、算数运算属性。

* GCC指定不同的C语言版本进行编译

![image-20200603231218929](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200603231218929.png)

#### 2.1 信息手册

> 大多数计算机使用 8位 一个字节，作为最小可寻址的内存单位。
>
> 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
>
> 内存的每个字节都由一个唯一的数字来标识，称为内存地址。
>
> 所有可能的地址的集合就称为 虚拟地址空间。

> 虚拟地址空间只是一个展现给机器级程序的概念，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组（第9章有讲解）。



##### 2.1.1 十六进制表示法

> 一个字节可以用两个十六进制来表示。
> 解释：
> 一个字节有8位   0000 0000 ，表示为16进制就是 0x00。
> 从另一个角度，16 = 2^4 ，也就是可以用四个2进制表示一个十六进制。

* 十六进制解释

![image-20200604000357644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000357644.png)

* 十六进制和二进制的转换

![image-20200604000547479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000547479.png)

* 练习题 2.1

  > A:
  > 0x 3 9 A 7 F B
  > 0011 1001 1010 0111 1111 1011
  >
  > B:
  > 1100 1001 0111 1011
  > 8421 8421 8421 8421
  > 8+4  8+1  4+2+1 8+2+1
  > C    9    7     B
  >
  > C:
  > 0x D  5  E  4  C
  >
  > 1101 0101 1110 0100 1100 
  >
  > D:
  >
  > 0010 0110 1110  0111  1011  0101
  > 8421 8421 8421  8421  8421  8421
  > 2    4+2  8+4+2 4+2+1 8+2+1 4+1
  > 2    6    E     7     B     5

* 十六进制和十进制换算方法

![image-20200604003019854](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604003019854.png)

> 以上列举的是转换的计算方法，实际应用中直接用计算器算

* 练习题 2.4

  > A:
  > 0x 803c 
  > +
  > 0x    8
  > 8044
  > B:
  > 0x 503c
  > -
  > 0x   40
  > 4EEc
  > C:
  > 0x 503c
  >
  > + 64
  >   50A0
  >   D:
  >   0x 50ea
  >   -
  >   0x 503c
  >     AE
  >
  >   A B C D E F
  >   10 11 12 13 14 15

##### 2.1.2 字数据大小

![image-20200604233606380](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604233606380.png)

   32位系统最大支持内存，2^32 byte  = 4GB 

* 位（bit） -> 比特

  >  计算机内部存储的最小单位。表示二进制位。
  >
  >  11010100 是一个8位二进制。

* 字节（byte）-> 拜特 / B

  > 字节是计算机数据处理的基本单位。
  >
  > 8位 构成 1字节 => 8bit = 1byte

* 字（word）

  > 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。
  > 一个字通常由一个或多个字节构成。
  >
  > 例如，
  > ​	    286微机的字由2个字节组成，它的字长为16；
  > ​        486微机的字由4个字节组成，它的字长为32；
  > 计算机的字长决定了其CPU一次操作处理实际位数是多少，由此可见计算机的字长越大，其性能越优越。

  * 字长概念的解释

    > 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位，16 位，32 位数据，但是处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
    >
    > 其实，CPU 指令集众多，各种例外是难免的。比如，8088 处理 16 位操作数的时候，只要不涉及主内存（只是立即数或者寄存器）就不花费额外周期，否则花费额外周期。所以称为准 16 位。再比如，如今的支持 SSE 指令集的 CPU，所称的字长从历史角度考虑，根本就没把 SSE 这种单指令多数据的情况算进去。
    >
    > 而且，字长还经常会从地址总线宽度，数据总线宽度这类概念借用过来。总之，说 64-bit CPU，32-bit CPU 的时候，明白自己指什么就好，不必拘泥于字长这个概念。
    >
    > 引用描述地址：https://www.zhihu.com/question/20536161



##### 2.1.3 寻址和字节顺序

大部分程序对象是跨越多字节的。那么对理解这个对象的存储需要理解两个重要概念。

两个重要规则概念：

* 对象的地址是什么

  * 多字节对象被存储为连续的字节序列

  * 对象地址为所使用的字节中最小的地址。

    > 假设，一个类型为 int 的变量 x 的地址为 0x100 ，也就是说，地址表达式 &x 的值为 0x100.
    >
    > 那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的 0x100、0x101、0x102和0x103位置。

* 内存中如何排列这些字节

  * 大端法、小端法
  * 大部分Intel和手机用小端法

![image-20200605000645086](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605000645086.png)



概念：

> 设 变量 x 类型为 int , 位于地址 0x100 处, 它的十六进制为 0x01234567.
>
> 注意：在字 0x01234567 中
>
> * 高位字节的十六进制为 0x01
> * 低位字节的十六进制为 0x67

* 大端法
  * 最高有效字节在最前面的方式，成为大端法
* 小端法
  * 最低有效字节在最前面的方式，称为小端法

![image-20200605003613984](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605003613984.png)

关于字节顺序的大端法和小端法需要注意的事项：

* 在大端法和小端法的两种类型机器间传递数据时，需要注意可能会出现接收方字节成反序的问题。
* 避免这类问题的方法是，网络应用程序的代码必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部的表示转换成网络标准，而接收方机器则将网络标准转换成它的内部表示。（第11章中会讲转换例子）

反汇编器概念：

> 反汇编器是一种确定可执行程序文件【所表示的指令序列】的工具。
>
> 第3章将学习这部分内容。

![image-20200605004405153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605004405153.png)



![image-20200605005917616](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605005917616.png)

* C中特殊转换指针类型的方法

  > typedef unsigned char *byte_pointer



* 弄明白 Clion 在Windows 和 Linux 上的配置

  * Windows上模仿Linux专属组件
    * MinGW
      * Minimalist GNU for Windows
      * 用于开发原生（32位）Windows应用的开发环境。
      * 主要提供了针对win32应用的GCC、GNU binutils 等工具。 
      * MinGW能替代cl编译不包含MFC，以WinSDK为主的应用。
      * MinGW被CodeBlocks，DevC++等选为Windows版本的默认编辑器
      * 据上一条可以理解，为什么可以依靠安装DevC++来配置Windows的C开发环境。
    * Cygwin
      * RedHat 项目，提供运行于Windows平台的类Unix环境。
        * 以GUN工具为代码
        * 提供一套抽象的dll，将Posix调用转换成Windows的API
    * msys
      * 提供一个较小的类Unix环境
    * mingw-w64
      * MinGW-w64是新一代MinGW
      * 支持更多API
      * 支持64位应用开发

* 验证代码

  ```c
  #include <stdio.h>
  
  typedef unsigned char *byte_pointer;
  
  void show_bytes(byte_pointer start,size_t len){
      size_t i;
      for(i = 0; i < len; i++){
          printf(" %.2x",start[i]);
      }
      printf("\n");
  }
  
  void show_int(int x){
      show_bytes((byte_pointer) &x,sizeof(int));
  }
  
  void show_float(float x){
      show_bytes((byte_pointer) &x,sizeof(float));
  }
  
  void show_pointer(void *x){
      show_bytes((byte_pointer) &x,sizeof(void *));
  }
  
  void test_show_bytes(int val){
      int ival = val;
      float fval = (float )ival;
      int *pval = &ival;
      show_int(ival);
      show_float(fval);
      show_pointer(pval);
  }
  
  int main() {
      test_show_bytes(12345);
      return 0;
  }
  
  ```

  > windows x64 系统输出 :
  >
  > 39 30 00 00
  > 00 e4 40 46
  > 0c fe 61 00 00 00 00 00



* 相关思考

```
同样123456编码， 整型内存字节表示为：0x00003039 ，浮点数表示为 0x4640E400

00003039
0000000000000000001 1000000111001
4640E400
010001100           1000000111001     0000000000

将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列(1000000111001)

这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。


思考：从二进制 0101011000 这些数学表示，反推转换成 十六进制，十进制，都是没有疑问的。

但是从输入层二进制推，就出现了疑惑，为什么Java里的byte输入是10进制？例如 byte[] keys = {60,61}

但继续思考这个同样的123456值，分别用整数型和浮点型转换为十六进制后，在内存字节上表示不同，但是又有13位是相同的二进制，

 ** 那么可以推测整数型123456的内存字节 0x00003039 和 浮点型的内存字节 0x4640E400 表示的是相同的值内容，

 ** 但是由于类型不同，附加了一些相关属性，所以导致123456的浮点型的内存字节多了一些符号表示。
 
 ** 标记此处，待后面验证

 [Java的byte数组的不同写法](https://blog.csdn.net/LVXIANGAN/article/details/41294989)
 [Java中Byte数组与十六进制字符串相互转换原理](https://cloud.tencent.com/developer/article/1385802)


数学符号大全：
https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8
```



##### 2.1.4 表示字符串

* 编码验证

  ```c
  void test_char(){
      const char *s = "abcdef";
      show_bytes((byte_pointer)s,strlen(s));
  }
  int main() {
      test_show_bytes(12345);
      test_char();
      return 0;
  }
  ```

  输出结果：

  >  39 30 00 00
  >  00 e4 40 46
  >  0c fe 61 00 00 00 00 00
  >  61 62 63 64 65 66  // abcdef 的ASCII码

* 相关编码集 ASCII、Unicode

* 编码考虑的事情

  * 能够包含大多数字符
  * 在包含大多数字符的情况下，如何保证合理占用字节空间
  * 路哥提供的哈夫曼编码压缩方法，可以合理处理这个问题

##### 2.1.5 表示代码

> 不同的机器类型使用不同的且不兼容的指令和编码方式，即使完全一样的进程，运行在不同操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。



##### 2.1.6 布尔代数运算

![image-20200606184319815](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606184319815.png)

* 布尔运算〜

  * 对应于逻辑运算 NOT

    > 当 P 不是真的时候，我们就说"T3 是真的，反之亦然。相应地，当 P 等于 0 时，〜P 等于1, 反之亦然。

* 布尔运算&

  * 对应于逻辑运算AND

    > 当P和Q都为真时，为真

* 布尔运算符 |

  * 对应逻辑运算 OR

    > 当 p=1 或者 q=1 时，p|q等于1.

* 布尔运算 ^

  * 对应逻辑运算异或

    > 当P 或者Q 为真但不同时为真时，成立。
    >
    > 当 p = 1 且 q = 0，或者 p=0 且 q=1时，p^q等于1



> 这一小节对应逻辑符号的描述，帮助理解了以前上的一门课，逻辑课，用来进行逻辑推理的公式，原来就是用计算机的数学逻辑来表示的！



* 重点概念：位向量

  > 位向量就是固定长度为 w ，由 0 和 1 组成的串。
  >
  > 位向量运算，可以定义成参数的每个对应元素之间的运算。

* 练习题 2.9 增进理解Android中对颜色的处理

* ![img](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/20160422211037563.gif)

* 练习题 2.10 帮助理解自定义View的重要环节 onMeasure 测量

  * 测量模式和测量值的存储和解析

  > //对应11000000000000000000000000000000;总共32位，前两位是1
  > int MODE_MASK  = 0xc0000000;
  >
  > //提取模式
  > public static int getMode(int measureSpec) {
  >  return (measureSpec & MODE_MASK);
  > }
  > //提取数值
  > public static int getSize(int measureSpec) {
  >  return (measureSpec & ~MODE_MASK);
  > }

​       练习题回答：

       ```

*x = a, *y = b

*y = *x ^ *y = a ^ b
*x = *x ^ *y = a ^ (a ^ b) = 0 ^ b = b 
*y = *x ^ *y = (0 ^ b) ^ ( a ^ b) = b ^ (a ^ b) = a 
       ```



* 练习题 2.11

  * 练习题回答

    ```
    A.
    end : first = k ; last = k
    B.
    此时 a[frist] = a[last]
    基于 ^ 的原理，a^a = 0; 所以，此时为0。
    C.
    跳过这个不替换。方法是 让for循环的条件排除 frist = last。也就是 将 first <= last 改为 first < last.
    ```



##### 2.1.7 C语言中的位级运算

![image-20200607135724336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607135724336.png)

* 从上图可以看出，根据 0xFF 的二进制是 [1111 1111] ，可以推出重要结论:

  * 当 `0x41 & 0xFF`  时，转换为二进制位运算，可以得到的是 `0x41` 本身。

    >​    0x41        0100  0001
    >&  0xFF        1111  1111
    >=  0X41        0100   0001

  * 当`0x41 & 0x00` 时，转换为二进制位运算，可以得到`0x41`被消减为0。

    >​    0x41        0100  0001
    >&  0x00       0000  0000
    >=  0x00        0000   0000

    这说明，可以用 数值 x 与 `0xFF` 或者 `0x00` 来进行位运算，来消减不想要的位，保留想要的位。

    再配合 `& | ~ ^` 这些布尔代数逻辑运算符，就可以进行各种位操作了。

![image-20200606183953489](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606183953489.png)



* 练习题 2.12

  * A 

    ```
    这个很简单，按照 x & 0xFF = x ，的二进制位运算推导出来
    x=0x87654321
    x & 0xFF = 0x87654321 = 0x000000FF & 0x87654321 = 0x0000021 
    ```

  * B

    ```
    B.
    
     0x  87 65 43 21   -> ‭ 1000 0111‬   ‭0110 0101‬    0100 0011‬   ‭0010 0001‬ 
     
    ^
    
    ~0x  00 00 00 FF    -> 0000 0000   0000 0000    0000 0000   1111 1111   
         FF FF FF 00    -> 1111 1111   1111 1111    1111 1111   0000 0000   
    
     0x  78 9A BC 21    -> 0111 1000   1001 1010    1011 1100   0010 0001  
     
     > 涉及到的知识点：1字节=8位，2^4 = 16 , 也就是4位存放1个16进制，1字节=8位=2个16进制.
     > 以这种存储方式，把数据全部转换为二进制进行运算，就得出了位运算。
    ```

  * C

    ```
     0x 87654321 & ~0xFF | 0xFF
     ->标准答案：
     0x 87654321 |0xFF 
     -> 原因：
     在二进制层面，任何位 | 0xFF 都是 0|1=1，所以会全是1，也就是 x|F=F
    ```

    ![image-20200607152653648](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607152653648.png)



##### 2.1.8 C语言中的逻辑运算符

![image-20200608223146297](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223146297.png)

按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

##### 2.1.9 C语言中的移位运算

![image-20200608223428838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223428838.png)

> 几乎所有的编译器、机器组合都对有符号数使用算术右移，且许多程序员也假设机器会使用这种右移。另一方面，对无符号数，右移必须是逻辑的。
>
> 与C相比，Java对于如何进行右移有明确的定义。表达式 x>>k 会将 x 算术右移 k 个位置，而  x>>>k 会对 x 做逻辑右移。

![image-20200608223838205](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223838205.png)



#### 2.2 整数表示

![image-20200609231804178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231804178.png)

##### 2.2.1 整型数据类型

![image-20200609231848641](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231848641.png)

> C 和 C++ 都支持有符号（默认）和无符号数。Java只支持有符号数。

##### 2.2.2 无符号数的编码

![image-20200609232141626](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232141626.png)

![image-20200609232221336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232221336.png)

##### 2.2.3 补码编码

![image-20200609232301739](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232301739.png)

![image-20200609232321093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232321093.png)

![image-20200609232350969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232350969.png)

![image-20200609232420691](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232420691.png)

##### * 2.2.4 有符号数和无符号数之间的转换

重要概念：对于有符号数和无符号数之间的转换，是用不同的解释方式去解释二进制位，但是本质上的二进制位并没有改变，只是改变了解读的方式，所以解读成了不同的数值。

![image-20200609233037797](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233037797.png)

##### 2.2.5 C 语言中的有符号数与无符号数

> 几乎所有的机器使用补码。通常，大多数数字都默认为是有符号的。
>
> C语言中，当声明一个像 12345 或者 0x1A2B 这样的常量时，默认是有符号的。
>
> 要创建一个无符号常量，必须加上后缀字符“U”或者"u"，
>
> 例如：12345U 或者 0x1A2Bu.

![image-20200609233503663](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233503663.png)

##### * 2.2.6 扩展一个数字的位表示

![image-20200609234051890](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234051890.png)



##### * 2.2.7 截断数字

![image-20200609234645555](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234645555.png)

![image-20200609234656316](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234656316.png)

![image-20200609234709178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234709178.png)

##### 2.2.8 关于有符号数与无符号数的建议

> 略过

#### 2.3 整数运算

##### 2.3.1 无符号加法

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610224725270.png" alt="image-20200610224725270" style="zoom:50%;" />

##### * 2.3.2 补码加法

对于补码加法，必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。

![image-20200610232418089](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610232418089.png)



##### * 2.3.2 补码的非

##### * 2.3.4 无符号乘法

##### * 2.3.5 补码乘法

##### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或者更多的周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数银子的乘法。首先，会考虑乘以2的幂的情况，然后再概括成乘以任意常数。

![image-20200610233126232](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610233126232.png)

> 注意,无论是无符号运算还是补码运算,乘以2的幂都可能会导致溢出。结果表明,
> 即使溢出的时候,我们通过移位得到的结果也是一样的。
>
> 例如 将4位模式[1011] (数值为11)左移两位得到[101100] (数值为44)。将这个值截断为4位得到[1100] (数值为12=44mod16)。

##### * 2.3.7 除以2的幂

大多数机器上，整数的除法要比乘法更慢，需要30个或者更多的时钟周期。

除以2的幂也可以用移位运算来实现，只不过用的是右移，而不是左移。

无符号数分别使用逻辑移位和算术移位来达到目的。

##### 2.3.8 关于整数运算的最后思考

计算机执行的 "整数" 运算实际上是一种模运算形式。表述数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种既能表示负数，也能表示正数的灵活方法，同时使用了与执行无符号运算相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。

#### 2.4 浮点数

重要概念：

![image-20200610235012367](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235012367.png)

##### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。

十进制表示法使用如下形式表示：

![image-20200610235621184](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235621184.png)

![image-20200610235828093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235828093.png)

十进制表示法不能准确表达 1/3 , 5/7 这样的数。因为它只能精确表示那些可以被写成  x X 2^y 的数。其他的值，只能被近似的表示。

![image-20200611000145943](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000145943.png)

##### 2.4.2 IEEE 浮点表示

![image-20200611000633695](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000633695.png)

![image-20200611001020700](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611001020700.png)

##### 2.4.3 数字示例

![image-20200611003809100](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003809100.png)

![image-20200611003905149](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003905149.png)

* 注意的点：

![image-20200611003950473](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003950473.png)

* 一些重要的单精度和双精度浮点数的表示和数字值：

![image-20200611004333652](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004333652.png)

##### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点数运算只能近似地表示实数运算。因此，对于值 x , 我们一般想用一种系统的方法，能够找到 "最接近的"匹配值 x' ，它可以用期望的浮点数形式表示出来。

这就是舍入（rounding）运算的任务。

一个关键的问题是在两个可能的值中间确定舍入方向。

> 例如,如果我有1.50美元,想把它舍入到最接近的美元数,应该是1美元还是2美元呢?
>
> 一种可选择的方法是维持实际数字的下界和上界。

![image-20200611004755578](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004755578.png)

* 舍入的方法

![image-20200611005845993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611005845993.png)

* 舍入方式的分析：

![image-20200611010008694](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010008694.png)

##### 2.4.5 浮点运算

![image-20200611010511900](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010511900.png)

##### 2.4.6 C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数据类型：float 和 double 。

在支持 IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。

另外，这类机器使用向偶舍入的舍入方式。

> 但是，因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍人方式或者得到诸如一0、十∞、一∞或者№aN之类的特殊值。
>
> 大多数系统提供include(‘.h’)文件和读取这些特征的过程库,但是细节随系统不同而不同。

例如,当程序文件中出现下列句子时,GNU编译器GCC会定义程序常数 INFINTTY(表示+∞)和NAN(表示NaN):

```c
#define _GNU_SOURCE 1
#include <math.h>
```

##### 浮点数小结

```
① 浮点数的表示，受制于计算机的二进制方式，只能表示 x X 2^t 的数值。其他的值只能被近似的表示。

② IEEE 的浮点数表示方法，将浮点数分为 三个部分：

  <1> 符号（sign）
  <2> 尾数（significand） -> n 位的编码数 M ，表示二进制小数
  <3> 阶码（exponent）    -> k 位的编码数 E ，表示负浮点数的加权。2 的 E次幂（可能是负数）。
  
  以上这种分为三部分的表示方式，能更接近的精度的表示小数。
  
③ 以上的表示方法依然限制了浮点数的范围和精度，因此再找 '最接近的' 匹配值，使用 舍入 方法。

  > 舍入的方法，有好几种，但是面对唯一需要决策的 1.5 这种中间数值的舍入，偏向于向偶舍入。
  
  > 即，1.5 和 2.5 都舍入为 2 。这是一种最常见的策略，更容易表示。
```

#### 2.5 小结

计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C语言的设计可以包含多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。

大多数机器对于`整数使用补码编码`，而对`浮点数使用 IEEE 标准754 编码`。

`在位级上理解这些编码，并且理解算术运算的数学特性`，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

![image-20200611012004885](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012004885.png)

* 要注意的点：

![image-20200611012050830](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012050830.png)

### 第3章 程序的机器级表示

计算机执行`机器代码`，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。

GCC C 语言编译器以及`汇编代码`的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用 `汇编器` 和 `链接器` ，根据汇编代码生成可执行的机器代码。

#### 3.1 历史观点

#### 3.2 程序编码

![image-20200612000317416](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612000317416.png)

##### 3.2.1 机器级代码（原理）

重要的两种抽象概念：

* 第一种是由 `指令集体系结构或指令集架构` 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

  > 大多数 ISA ，包括 x86-64 ，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。
  >
  > 处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

* 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

  > 存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。
  >
  > 第9章会讲到。

![image-20200612001116141](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001116141.png)

虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。

> C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
>
> 即使是对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

![image-20200612001722618](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001722618.png)

##### 3.2.2 代码示例（原理）

![image-20200612002330761](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612002330761.png)

* 调试 mstore.o

  ![image-20200612004851388](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612004851388.png)

  > gdb 调试上述程序的方式。
  >
  > ① gdb mstore.o   // 开始调试可执行文件
  >
  > ② x/14xb multstore // 告诉GDB显示从函数 multstore 所处地址开始的 14 个进制格式表示的字节。 
  >
  > 其他命令：quit // 退出gdb调试

  调试结果:

  ```shell
  (gdb) x/14xb multstore
  0x0 <multstore>:        0x53    0x48    0x83    0xec    0x20    0x4c    0x89    0xc3
  0x8 <multstore+8>:      0xba    0x02    0x00    0x00    0x00    0xe8
  (gdb) quit
  ```

* [gdb调试参考资料](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)

* 反汇编器(disassembler)

  ![image-20200612005425280](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612005425280.png)

​     使用 objdump 实际反汇编的结果：

```shell
//windows下执行
// mstore.o 大小：758
objdump.exe -d mstore.o

mstore.o:     file format pe-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 83 ec 20             sub    $0x20,%rsp
   5:   4c 89 c3                mov    %r8,%rbx
   8:   ba 02 00 00 00          mov    $0x2,%edx
   d:   e8 00 00 00 00          callq  12 <multstore+0x12>
  12:   89 03                   mov    %eax,(%rbx)
  14:   48 83 c4 20             add    $0x20,%rsp
  18:   5b                      pop    %rbx
  19:   c3                      retq
  1a:   90                      nop
  1b:   90                      nop
  1c:   90                      nop
  1d:   90                      nop
  1e:   90                      nop
  1f:   90                      nop
```

其中一些关于机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。

* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。

  > 例如，只有指令 pushq %rbx 是以字节值 53 开头的。

* 反汇编只是给予机器代码文件中的字节序列来确定汇编代码。

  > 它不需要访问程序的源代码或者汇编代码。

* 反汇编其使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。

  > 在我们的示例种，它省略了很多指令结尾的 `q` 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编其给 call 和 ret 指令加了 `q` 后缀，同样，省略这些后缀也没有问题。

![image-20200613124456938](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613124456938.png)

 然后，用以下方法生成可执行文件 prog:

```shell
linux > gcc -Og -o prog main.c mstore.c
```

![image-20200613143527397](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613143527397.png)

> 在当前 windows10 机器上测试，变成了 47083 个字节。这说明在不同机器上，生成的字节是不一样的。虽然通过编译器，可以保证执行的结果是一致的，但是二进制产生了差异，这就是不同操作系统和硬件的翻译有区别。编译器处理了这一层差异。

上面讲的抽取出的这段代码与 mstore.c 反汇编产生的代码几乎完全一样。

几点细微的区别如下：

* 第一个主要的区别是 左边列出的地址不同 —— 链接器将这段代码的地址移到了一段不同的地址范围中。

* 第二个不同之处在于链接器填上了 callq 指令调用函数 mult2 需要使用的地址（上面抽取出的反汇编代码第4行）。

  链接器的任务之一就是 `为函数调用找到匹配的【函数的可执行代码的位置】` 。

* 最后一个区别是多了两行代码（第8和第9行）。

  这两条指令对程序没有影响，因为它们出现在返回指令后面（第7行）。插入这些指令是为了使函数代码变为16字节，使得就存储器性能而言，能更好的放置下一个代码块。

  > 这里表达的意思应该是，存储器更适宜于存取机器/系统指定的固定长度的地址，这里16字节为一个长度单位去存取数据是最快的，在不同机器、系统环境下这个适宜的长度单位应该也会发生变化。

##### 3.2.3 关于格式的注解

GCC 产生的汇编代码对于我们来说有点难读。一方面，它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。

例如，假设我们用如下命令生成文件 mstore.s ：

![image-20200613145002462](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145002462.png)

所有以 "." 开头的行都是知道汇编器和链接器工作的伪指令，我们通常可以忽略这些行。

另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

![image-20200613145227519](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145227519.png)

通常我们只会给出与讨论内容相关的代码行。每一行左边都有编号供引用，右边是注释，简单描述指令的效果以及它与原始C语言代码中的计算操作的关系。

这是一种汇编语言程序员写代码的风格。

#### 3.3 数据格式

![image-20200613145740644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145740644.png)

如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

> 例如，数据传送指令有四个变种：moveb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。
>
> 后缀 '1' 用来表示 4 字节整数 和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

#### 3.4 访问信息

一个 x86-64 的中央处理单元(CPU) 包含一组16个存储64位值的`通用目的寄存器`。

![image-20200613150242935](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150242935.png)

![image-20200613150313874](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150313874.png)

有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

> 在  `3.7 - 过程` 章节中描述过程的实现时，会讲述这些惯例。   

##### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

> 源数据值可以以常数形式给出，或是从寄存器或内存中读出。
>
> 结果可以存放在寄存器或内存中。

因此操作数被分为三种类型：

* 立即数(immediate)

  > 表示常数值。
  >
  > ATT格式的汇编代码种，立即数用 $ 来表示（参考的描述，不准确）

* 寄存器(register)

  > 表示某个寄存器的内容。
  >
  > 用 r 表示寄存器（参考的描述，不准确）

* 内存引用

  > 根据计算出来的地址(通常称为`有效地址`)访问某个内存位置。
  >
  > 用 M 表示内存引用（参考的描述，不准确）

![image-20200613151316013](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151316013.png)

##### 3.4.2 数据传送指令

最频繁使用的指令，是将数据从一个位置复制到另一个位置。

操作数表示的通用性，使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

>  把许多不同的指令划分成 `指令类` ，
> 每一类中的指令执行相同的操作，只不过操作数大小不同。

![image-20200613151753993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151753993.png)

![image-20200613152029123](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152029123.png)

![image-20200613152234259](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152234259.png)

##### 3.4.3 数据传送示例

![image-20200613152505439](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152505439.png)

这段汇编代码有亮点值得注意：

① C 语言中的 "指针" 就是地址。

> 间接引用指针就是将该指针放在一个寄存器中，然后在内存中使用这个寄存器。

② 像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。

> 访问寄存器比访问内存要快的多。

##### 3.4.4 压入和弹出数据

![image-20200613153526387](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153526387.png)

![image-20200613153602838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153602838.png)

> 栈在内存中的某个地方，所以压栈是：减少寄存器的值，将数据存放到内存中。

#### 3.5 算数和逻辑操作

![image-20200613154411994](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613154411994.png)

操作分类分类：

* 加载有效地址
* 一元操作
* 二元操作
* 移位

> 二元操作有两个操作数，一元操作有一个操作数

##### 3.5.1 加载有效地址

`加载有效地址(load effective address)` 指令 `leaq` 实际上是 movq 的指令变形。

它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。

> 它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![image-20200613155417025](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613155417025.png)

这二个指令的效果是将 `S的地址` 写入到 `寄存器D` 。

根本没有引用内存，只是操作的地址。

![image-20200613160045168](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613160045168.png)

##### 3.5.2 一元和二元操作

`这里的分组，都是指 图3-10 中的分组。`

第二组中的操作是一元操作，只有一个操作数，既是源又是目的。

> 这个操作数可以是一个寄存器，也可以是一个内存地址。

第三组是二元操作，其中，第二个操作数既是源又是目的。

> 注意1：源操作数是第一个，目的操作数是第二个。
>
> 第一个操作数可以是立即数、寄存器或是内存地址。
>
> 第二个操作数可以是寄存器或是内存地址。
>
> 注意2：当第二个操作数是内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

##### 3.5.3 移位操作

![image-20200613161003390](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161003390.png)

##### 3.5.4 讨论

图3-10 所示的大多数指令，既可以用于无符号运算，也可以用于补码运算。

>  只有右移操作要求区分有符号和无符号。
>
> 这个特性是补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

![image-20200613161435121](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161435121.png)

##### 3.5.5 特殊的算数操作

![image-20200613162933114](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613162933114.png)

#### 3.6 控制

到目前位置，我们只考虑了 `直线代码行为` ，也就是指令一条接接着一条顺序的执行。

C 语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。

机器代码提供两种基本的低级机制来实现有条件的行为：

① 测试数据值

② 然后根据测试的结果来改变控制流或数据流。

与数据相关的控制流是实现有条件行为更一般和更常见的方法。

> 通常 C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。
>
> 用 jump 指令，可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。
>
> 编译器必须产生构建在这种低级机制基础上的指令序列，来实现C语言的控制结构。

##### 3.6.1 条件码

除了整数寄存器，CPU还维护着一组单个位的 `条件码(condition code) 寄存器` ，它们描述了最近的算术或逻辑操作的属性。

可以检测这些寄存器来执行条件分支指令。

最常用的条件码有：

* CF : 进位标志

  > 最近的操作使最高位产生了进位。
  >
  > 可用来检查无符号操作的溢出。

* ZF : 零标志

  > 最近的操作得出的结果为0。

* SF : 符号标志

  > 最近操作得到的结果为负数。

* OF : 溢出标志

  > 最近的操作导致一个补码溢出 —— 正溢出负溢出。

![image-20200613164720092](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164720092.png)

##### 3.6.2 访问条件码

条件码通常不会直接读取，通常的使用方法有三种：

① 可以根据条件码的某种组合，将一个字节设置为 0 或者 1

② 可以条件跳转到程序的某个其他的部分

③ 可以有条件地传输数据

![image-20200613164933457](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164933457.png)

##### 3.6.3 跳转指令

正常执行的情况下，指令按照它们出现的顺序一条一条地执行。

`跳转` 指令会导致执行切换到程序中一个全新的位置。

在汇编代码中，这些跳转的目的地通常用一个符号(label) 指明。

![image-20200613165142534](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165142534.png)

##### 3.6.4 跳转指令的编码

虽然我们不关心及前期代码格式的细节，但是理解跳转指令的目标如何编码，这对`研究链接(第7章)`非常重要。

此外，它也能帮助理解反汇编器的输出。

>  在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。
>
> 第一种编码：
> 跳转指令有几种不同的编码，但是最常用的都是 `PC相对的(PC-relative)` 。
> 也就是说，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2或4个字节。
>
> 第二种编码：
> 这种编码方式是，给出"绝对"地址，用4个字节直接指定目标。
>
> 以上两种方式编码用哪种，取决于汇编器和链接器会选择适当的跳转目的编码。

![image-20200613165918872](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165918872.png)

##### 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

(另一种方式在 3.6.6节有讲，有些条件可以用数据的条件转移实现，而不是用控制的条件转移来实现。)

##### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用 `控制的条件转移`。

> 当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。
>
> 这种机制简单而通用，但是在现代处理器上，它可能非常低效。

一种替代的策略是使用 `数据的条件转移`。

> 这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。
>
> 只有在一些受限制的情况中，这种策略才可行。
>
> 但是如果可行，就可以用一条简单的 条件传送 指令来实现它。条件传送指令更符合现代处理器的性能特性。

```
为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码（如图 3-16 中
那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第 4
章和第 5 章中看到的，处理器通过使用流水线（pipelining)来获得高性能
```

##### 3.6.7 循环

`汇编中没有循环指令存在，可以用条件测试和跳转组合起来实现循环的效果。`

* 思考
  * 前提：如何翻译成汇编主要取决于汇编器
  * 问题：
    * 那么不同语言的不同汇编器产生的汇编是不同的，二进制是否相同？
      * 汇编不同，二进制也应该不同
        * 那么执行的时候，不同汇编器产生的二进制，如何执行起来的？

##### 3.6.8 switch 语句

![image-20200613171429054](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613171429054.png)

#### 3.7 过程（重要）

过程是软件中一种很重要的抽象。

> 它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。
>
> 然后，可以在程序中不同的地方调用这个函数。
>
> 设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

不同编程语言中，过程的形式多样，主要的有以下几种：

* 函数(function)
* 方法(method)
* 子例程(subroutine)
* 处理函数(handler)

但是它们都有一些共性。要提供对过程的机器级支持，必须要处理许多不同的属性。

为了方便讨论，`假设 过程P 调用 过程Q ， Q 执行后返回到 P `，这些动作至少包含以下共性之一：

* 传递控制

  > 在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。

* 传递数据

  > P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。

* 分配和释放内存

  > 在开始时，Q 可能需要为局部变量分配控件，而在返回前，又必须释放这些存储空间。

##### 3.7.1 运行时栈

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。

> 在 过程P 调用 过程Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。
>
> 当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
> 另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。
> 因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
>
> 当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

![image-20200613173457689](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173457689.png)

大多数过程的栈帧都是定长的，在过程开始就分配好了。

但是，有些过程需要变长的帧，这个问题会在 `3.10.5` 节中讨论。

> 通过寄存器 ，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。
>
> 思考：这是不是意味着，超过 6 个参数，会导致性能下降？

![image-20200613173920746](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173920746.png)

> 思考：这里的6个参数寄存器性能限制，是对C语言来讲的，那么基于JVM的Java，是否也是相同的限制？

##### 3.7.2 转移控制

将控制从 函数P 转移到 函数Q 只需要简单地把程序计数器(PC) 设置为 函数Q 代码的起始位置。

不过，当稍后从 Q 返回时，处理器必须记录好它需要继续 函数P 执行的代码位置。

> 在 x86-64 机器中，这个信息是用指令 `call Q`  调用过程Q 来记录的。
>
> 该指令会把 地址A 压入栈中，并将 PC 设置为 函数Q 的起始地址。
>
> 压入的 地址A  被称为返回地址，是 `紧跟在 call 指令后面的那条指令的地址` 。
>
> 对应的 `指令ret` 会从栈中弹出 地址A ，并把 PC 设置为 A 。

> 自己组织语言解释：
>
>  `call指令` 会先把 "执行完call后的下一条指令地址 A" 压入栈中，并将 PC 设置为 "要call的Q函数地址" 。这样，当 Q函数 执行完，调用 `ret指令` 时，会从栈中弹出 "执行完call后的下一条指令地址 A" ，并将 PC 设置为 地址A ， 从而继续执行 call指令之前的程序顺序。

思考：逆向中的找 call ，其实要关注两点：① call ② ret 

> call 指令保存了执行call之后的下一条指令地址，
>
> ret 指令从栈中弹出了要继续执行的 下一条指令地址。

![image-20200613180018825](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613180018825.png)

> 图3-3 出现在 3.4.1 节。

