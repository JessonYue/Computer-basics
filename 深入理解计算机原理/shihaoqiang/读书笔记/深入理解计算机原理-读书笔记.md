# 深入理解计算机系统-读书笔记

个人觉得这本书第一章是对本书知识地图的梳理，一个引导建立对本书完整概念的一章，比较重要，阅读的细一些，会仔细理解比较重要的概念，阅读进度较慢，阅读到 1.8 系统之间利用网络通信。

### 第一章：计算机系统漫游

> 本章前言，了解到1个信息点：C编程语言经典教材[61]
> 后续有时间可以查阅一下。

#### 1.1 信息就是位 + 上下文

* 8位 构成 1字节

* 字节构成字，字在不同操作系统上表示大小不同

* ASCII 编码很重要，其他非英文编码的包含，应该有指的是 UTF8

* 理解 hello.c 这种源文件，在计算存储中的表示方式

  > 字符 -> ASCII -> 数字 -> 二进制

* 初步揭示了Linux系统中一些都是数据文件

* 重要概念：数字在机器中的表示方式，是对真值的近似值，会有坑

#### 1.2 程序被其他程序翻译成不同的的格式

* 将源码翻译成可执行文件的 `四个阶段程序` 及对应的 `四个过程`
  * 预处理器(cpp)   
    * hello.c(源文本) -> hello.i(插入依赖库源码的源文本)
  * 编译器（ccl）
    * hello.i -> hello.s（汇编代码-文本格式）
  * 汇编器（as）
    * hello.s -> hello.o （可重定位目标程序 - 二进制了）
  * 链接器（ld）
    * hello.o & printf.o(依赖库) -> hello （整hello.o和依赖库）
    * 最终完成的可执行文件就是 hello

#### 1.3 了解编译系统如何工作大有益处

理解编译系统如何工作的，可以帮助达成以下目标：

* 优化程序性能

* 理解链接时出现的错误

  > 这个在NDK编译中很有帮助

* 避免安全漏洞

#### 1.4 处理器读并解释存储在内存中的指令

* 可执行程序的二进制被载入到内存中，从而执行指令

##### 1.4.1 系统的硬件组成

* 总线

  * 贯穿系统全局的管道，用于跟各部分交互传输数据，大交通动脉

* I/O设备

  * 系统中几乎所有配件设备都可以归纳为I/O设备
  * I/O设备的类型可以分为 控制器和适配器
    * 控制器是主板或者鼠标这类自带芯片的设备
    * 适配器是插在主板插槽上的辅助设备

* 主存

  * 应该指的就是内存（第6章会介绍存储技术）

* 处理器（CPU）

  * 重要概念：`寄存器` 和 `程序计数器(PC)`

    * PC 指向的永远是当前内存中要执行的指令，这个很重要 

  * 系统基于CPU层面的执行模型

    * 就是不断执行计数器（PC）指向地址上的程序
    * 更新程序计数器就操纵了执行执行，这个由`指令集架构决定`

  * CPU的关联硬件

    * 主存

    * 寄存器文件

    * 算数/逻辑单元（ALU）

      > 用来进行寄存器的加减逻辑运算操作
      >
      > 计算新的数据和地址值，配合刷新PC，控制程序执行

    * CPU可能做的操作

      > 加载、存储、操作、跳转
      >
      > 这些都是为了配合PC控制程序执行

  * 两个概念区分

    * 指令集架构 - 针对机器代码指令的效果
    * 微体系结构 - 指处理器的实现

    > 指令集架构在同一架构下，指令的效果应该是相同的
    >
    > 微体系结构上处理器的实现，可能各有差异
    >
    > 理解一下，应该就是 Intel和AMD同样指令集下，可以让程序跑出相同的目标效果，但是处理器实现上却可能存在差异。

##### 1.4.2 运行 hello 程序

介绍执行程序的流程中，通过总线连接CPU、内存、IO设备的整个关系。

#### 1.5 高速缓存至关重要

由于 寄存器、内存的速度差异巨大，而寄存器贵，内存便宜，那么中间的高速缓存就很有必要了。

> 例如，或许可以理解 I7 ，I5 每一代的 二级缓存，三级缓存的意义了

#### 1.6 存储设备形成层次结构

概念上跟Android中的三级缓存意义差不多，只不过增加了硬件方面的 寄存器和 L1 ，L2 高速缓存，实现的目的和原理是基本一致的。

#### 1.7 操作系统管理硬件

> 一个很重要的概念：操作系统为应用程序屏蔽了硬件的差异。
>
> 让应用程序的开发可以更简单，大部分程序开发是面向操作系统的。

##### 1.7.1 进程

* 重要概念：进程是抽象出来的让程序貌似独占资源的虚拟概念。

  > 进程的抽象出来，让程序貌似独占资源，大大简化了面向编程人员的复杂性。
  > 进程是计算机科学中最重要和最成功的概念之一。

* 重要概念：上下文

  * 为了CPU可以执行多个进程程序，操作系统设计了上下文

  * 每个进程程序对应一个上下文，操作系统通过切换上下文，来切换程序对CPU资源的使用。

  * 而上下文的切换是由操作系统内核来管理的

    > 内核不是一个独立的进程。
    >
    > 它是系统管理全部进程所用代码和数据结构的集合。

* 上下文概念的通用性

  > 关于上下文这个概念，在编程中普遍存在。
  >
  > Android中的Context，Kotlin协程中的 Dispatch.IO ，这些上下文的概念是普适性的，原理上都是一致的，都是为了保存环境信息，切换执行再恢复执行，需要用到保存的上下文信息。

##### 1.7.2 线程

多线程的开销比多进程小，多线程可以容易的共享进程数据，多线程共享一个进程的上下文，多线程可以提高性能。

> 进程 -> 多线程 -> 协程，都是为了尽可能减少开销

##### 1.7.3 虚拟内存

虚拟内存也是一个抽象概念，给进程一个假象，好像每个进程都独占的使用内存。

* 重要概念：每个进程看到的内存是一致的，称为 `虚拟地址空间`

* 虚拟地址空间的构成

  * 程序代码和数据

  * 堆（动态分配大小）

  * 共享库

  * 栈（动态分配大小）

  * 内核虚拟内存

    > 地址空间顶部区域为内核保留，不允许应用程序来读写这个区域。

* 上述介绍地址空间的构成，是从 程序代码 -> 内核虚拟内存地址是递增的。

##### 1.7.4 文件

Linux系统中几乎一切都可以表示为文件。所有的操作都是统一的 Unix I/O 来通过读写文件实现。这个机制精简却很强大。

---
> 第2天 - 2020.06.02
---
#### 1.8 系统之间利用网络通信

文件就是字节序列。网络也是一种特殊的IO设备，可以直接在计算机之间进行数据传递。抛开实现上的细节，从IO概念上看，网络这种IO设备运作原理上跟其他IO设备是一致的，都是对文件字节序列的读写传输。

#### 1.9 重要主题

系统是硬件和软件互相交织的集合体，共同协作达到运行应用程序的目的。

##### 1.9.1 Amdahl 定律

吉恩·阿姆达尔定律 ， 很重要，可以用来指导进行性能优化。

* 理解过程

  > Told = 100; // 原始性能花费时间
  > a = 0.2; // 部分原占比 a*Told=20
  > k = 200% = 2.0; // 性能的提升 1.0 ，那么 a / k * Told = 0.2 / 2 * 100 = 10  
  >
  > 推导出：(a*Told) / k = (0.2 * 100) / 2.0 = 20 / 2 = 10
  >
  > 验证 Tnew = (1-a)*Told + (a*Told)/k = Told*[(1-a) + a/k]
  >
  >  Tnew = (1-0.2)*100 + (0.2*100)/2.0 = 80 + 10 = 90
  >       = 100*[(1-0.2)+0.2/2.0] = 100 * [0.8+0.1] = 90
  >
  > 加速比公式：S = Told/Tnew 
  > 代入 求Told 和 Tnew 的公式可得： S =  1/(1-a) + a/k
  >
  > 验证计算加速比 S = 1 / (1-0.2) + 0.2/2.0 =  1/0.8 + 0.1 = 5/4 + 0.1 =  1.25 + 0.1 = 1.35
  >
  > 1/[(1-0.2) + 0.2/2] = 1 / [0.8+0.1] = 1/0.9 = 1.11 
  >
  > 这里面综合考虑了对部分的加速，作用于整个系统中的效果。
  >
  > 计算 Told 和 Tnew 的计算公式，应用的 a 和 k 都是相对于部分的。k 的性能提升比例，指的是相对于部分的 a 的比例。计算对系统的加速比是计算部分的这个加速，应用于整个系统上，加速效果是多少。
  >
  >
  > 这里会出现一个现象：虽然我们对系统的一个主要部分做出了重大改进，但是获得系统加速比却可能明显小于这部分的加速比。
  > 举例子，设 系统某个部分初始耗时比例为 60% (a=0.6) ，其部分的加速比因子为 3 (k=3) 。则我们可以获得的整个系统的加速比为 1/[0.4+0.6/3] = 1.67 倍。
  > 这个例子表明了上面的现象，虽然对主要部分做出来重大改进，但是系统获得的加速比却明显小于这部分的加速比。
  >
  > Gene Amdahl（吉恩·阿姆达尔）定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
  >
  > 关于理解相对性能的比例概念有两种方式。
  > 推荐方式：Told/Tnew .
  > 其中Told 为原始系统所需时间，Tnew 为修改后系统所需时间。如果有所改进，则比值应大于1。用后缀 "X" 来表示比例，因此，"2.2X" 读作“2.2倍”。
  >
  > ---------
  >
  > 1.9.1 - Exercise - 1.1
  >
  > 1.9.1 - Exercise - 1.2
  > S = 1 / ((1-a)+a/k)
  >
  > 1.67X = 1 / (1-0.6 + 0.6/k)
  >
  > 1.67 = 1/ (0.4+0.6/k)
  >
  > 0.4+0.6/k = 1/1.67 = 1/(5/3) = 3/5 = 0.6
  >
  > 0.6/k = 0.2
  > k = 0.6/0.2 = 3

##### 1.9.2 并发和并行

* 三个主要层次

  * 线程级并发

    > 多核处理器促进了线程级并发

  * 指令级并行

    > 以 8086 为最简单的理解结构。
    >
    > 在第5章中会重点介绍这部分内容

  * 单指令、多数据并行

    > 在最低层次上，将一条指令产生多个可以并行执行的操作。
    >
    > 这种操作成为 单指令、多数据。SIMD并行。
    >
    > 目的都是为了提高CPU的处理效率。

##### 1.9.3 计算机系统中抽象的重要性

四个重要的抽象概念：

* 文件
  * 对I/O设备的抽象
* 虚拟内存
  * 对程序存储器的抽象（包含文件I/O设备和主存）
* 进程
  * 对一个正在的运行程序的抽象（包含处理器、主存和I/O设备）
  * 1.7 也有相关概念介绍
* 虚拟机
  * 对整个计算机的抽象（包含 操作系统、处理器、程序）
  * 主要目的是为了让计算机能够运行为不同操作系统设计的程序

##### 1.10 小结

三个基本抽象重要，重复一下：

（1）文件是对I/O设备的抽象

（2）虚拟内存是对主存和磁盘的抽象

（3）进程是对处理器、主存和I/O设备的抽象

> 网络是一种特殊的I/O设备，提供了计算机系统之间的通信手段。

## 第一部分 ：程序结构和执行

### 第二章：信息的表示和处理

> 使用二进制作为计算机进制是因为它非常易于用电路表示，并且简单可靠。

* 三种最重要的数字表示
  * 无符号（unsigned）编码
    * 基于传统的二进制表示法
    * 表示大于或等于零的数字
  * 补码（two's-complement）编码
    * 表示有符号整数的最常见的方式
    * 有符号整数就是可以为正或者为负的数字
  * 浮点数（floating-point) 编码
    * 表示实数的科学计数法的2为基数的版本

> 计算机表示法用有限数量的位来对一个数字编码
>
> 因此会可能出现溢出，了解这些知识可以避免一些安全漏洞

> 各种编码基本定义、属性、位级表示、算数运算属性。

* GCC指定不同的C语言版本进行编译

![image-20200603231218929](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200603231218929.png)

#### 2.1 信息手册

> 大多数计算机使用 8位 一个字节，作为最小可寻址的内存单位。
>
> 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
>
> 内存的每个字节都由一个唯一的数字来标识，称为内存地址。
>
> 所有可能的地址的集合就称为 虚拟地址空间。

> 虚拟地址空间只是一个展现给机器级程序的概念，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统结合起来，为程序提供一个看上去统一的字节数组（第9章有讲解）。



##### 2.1.1 十六进制表示法

> 一个字节可以用两个十六进制来表示。
> 解释：
> 一个字节有8位   0000 0000 ，表示为16进制就是 0x00。
> 从另一个角度，16 = 2^4 ，也就是可以用四个2进制表示一个十六进制。

* 十六进制解释

![image-20200604000357644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000357644.png)

* 十六进制和二进制的转换

![image-20200604000547479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604000547479.png)

* 练习题 2.1

  > A:
  > 0x 3 9 A 7 F B
  > 0011 1001 1010 0111 1111 1011
  >
  > B:
  > 1100 1001 0111 1011
  > 8421 8421 8421 8421
  > 8+4  8+1  4+2+1 8+2+1
  > C    9    7     B
  >
  > C:
  > 0x D  5  E  4  C
  >
  > 1101 0101 1110 0100 1100 
  >
  > D:
  >
  > 0010 0110 1110  0111  1011  0101
  > 8421 8421 8421  8421  8421  8421
  > 2    4+2  8+4+2 4+2+1 8+2+1 4+1
  > 2    6    E     7     B     5

* 十六进制和十进制换算方法

![image-20200604003019854](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604003019854.png)

> 以上列举的是转换的计算方法，实际应用中直接用计算器算

* 练习题 2.4

  > A:
  > 0x 803c 
  > +
  > 0x    8
  > 8044
  > B:
  > 0x 503c
  > -
  > 0x   40
  > 4EEc
  > C:
  > 0x 503c
  >
  > + 64
  >   50A0
  >   D:
  >   0x 50ea
  >   -
  >   0x 503c
  >     AE
  >
  >   A B C D E F
  >   10 11 12 13 14 15

##### 2.1.2 字数据大小

![image-20200604233606380](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200604233606380.png)

   32位系统最大支持内存，2^32 byte  = 4GB 

* 位（bit） -> 比特

  >  计算机内部存储的最小单位。表示二进制位。
  >
  >  11010100 是一个8位二进制。

* 字节（byte）-> 拜特 / B

  > 字节是计算机数据处理的基本单位。
  >
  > 8位 构成 1字节 => 8bit = 1byte

* 字（word）

  > 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。
  > 一个字通常由一个或多个字节构成。
  >
  > 例如，
  > ​	    286微机的字由2个字节组成，它的字长为16；
  > ​        486微机的字由4个字节组成，它的字长为32；
  > 计算机的字长决定了其CPU一次操作处理实际位数是多少，由此可见计算机的字长越大，其性能越优越。

  * 字长概念的解释

    > 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位，16 位，32 位数据，但是处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
    >
    > 其实，CPU 指令集众多，各种例外是难免的。比如，8088 处理 16 位操作数的时候，只要不涉及主内存（只是立即数或者寄存器）就不花费额外周期，否则花费额外周期。所以称为准 16 位。再比如，如今的支持 SSE 指令集的 CPU，所称的字长从历史角度考虑，根本就没把 SSE 这种单指令多数据的情况算进去。
    >
    > 而且，字长还经常会从地址总线宽度，数据总线宽度这类概念借用过来。总之，说 64-bit CPU，32-bit CPU 的时候，明白自己指什么就好，不必拘泥于字长这个概念。
    >
    > 引用描述地址：https://www.zhihu.com/question/20536161



##### 2.1.3 寻址和字节顺序

大部分程序对象是跨越多字节的。那么对理解这个对象的存储需要理解两个重要概念。

两个重要规则概念：

* 对象的地址是什么

  * 多字节对象被存储为连续的字节序列

  * 对象地址为所使用的字节中最小的地址。

    > 假设，一个类型为 int 的变量 x 的地址为 0x100 ，也就是说，地址表达式 &x 的值为 0x100.
    >
    > 那么，（假设数据类型int为32位表示）x的4个字节将被存储在内存的 0x100、0x101、0x102和0x103位置。

* 内存中如何排列这些字节

  * 大端法、小端法
  * 大部分Intel和手机用小端法

![image-20200605000645086](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605000645086.png)



概念：

> 设 变量 x 类型为 int , 位于地址 0x100 处, 它的十六进制为 0x01234567.
>
> 注意：在字 0x01234567 中
>
> * 高位字节的十六进制为 0x01
> * 低位字节的十六进制为 0x67

* 大端法
  * 最高有效字节在最前面的方式，成为大端法
* 小端法
  * 最低有效字节在最前面的方式，称为小端法

![image-20200605003613984](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605003613984.png)

关于字节顺序的大端法和小端法需要注意的事项：

* 在大端法和小端法的两种类型机器间传递数据时，需要注意可能会出现接收方字节成反序的问题。
* 避免这类问题的方法是，网络应用程序的代码必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部的表示转换成网络标准，而接收方机器则将网络标准转换成它的内部表示。（第11章中会讲转换例子）

反汇编器概念：

> 反汇编器是一种确定可执行程序文件【所表示的指令序列】的工具。
>
> 第3章将学习这部分内容。

![image-20200605004405153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605004405153.png)



![image-20200605005917616](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200605005917616.png)

* C中特殊转换指针类型的方法

  > typedef unsigned char *byte_pointer



* 弄明白 Clion 在Windows 和 Linux 上的配置

  * Windows上模仿Linux专属组件
    * MinGW
      * Minimalist GNU for Windows
      * 用于开发原生（32位）Windows应用的开发环境。
      * 主要提供了针对win32应用的GCC、GNU binutils 等工具。 
      * MinGW能替代cl编译不包含MFC，以WinSDK为主的应用。
      * MinGW被CodeBlocks，DevC++等选为Windows版本的默认编辑器
      * 据上一条可以理解，为什么可以依靠安装DevC++来配置Windows的C开发环境。
    * Cygwin
      * RedHat 项目，提供运行于Windows平台的类Unix环境。
        * 以GUN工具为代码
        * 提供一套抽象的dll，将Posix调用转换成Windows的API
    * msys
      * 提供一个较小的类Unix环境
    * mingw-w64
      * MinGW-w64是新一代MinGW
      * 支持更多API
      * 支持64位应用开发

* 验证代码

  ```c
  #include <stdio.h>
  
  typedef unsigned char *byte_pointer;
  
  void show_bytes(byte_pointer start,size_t len){
      size_t i;
      for(i = 0; i < len; i++){
          printf(" %.2x",start[i]);
      }
      printf("\n");
  }
  
  void show_int(int x){
      show_bytes((byte_pointer) &x,sizeof(int));
  }
  
  void show_float(float x){
      show_bytes((byte_pointer) &x,sizeof(float));
  }
  
  void show_pointer(void *x){
      show_bytes((byte_pointer) &x,sizeof(void *));
  }
  
  void test_show_bytes(int val){
      int ival = val;
      float fval = (float )ival;
      int *pval = &ival;
      show_int(ival);
      show_float(fval);
      show_pointer(pval);
  }
  
  int main() {
      test_show_bytes(12345);
      return 0;
  }
  
  ```

  > windows x64 系统输出 :
  >
  > 39 30 00 00
  > 00 e4 40 46
  > 0c fe 61 00 00 00 00 00



* 相关思考

```
同样123456编码， 整型内存字节表示为：0x00003039 ，浮点数表示为 0x4640E400

00003039
0000000000000000001 1000000111001
4640E400
010001100           1000000111001     0000000000

将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列(1000000111001)

这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。


思考：从二进制 0101011000 这些数学表示，反推转换成 十六进制，十进制，都是没有疑问的。

但是从输入层二进制推，就出现了疑惑，为什么Java里的byte输入是10进制？例如 byte[] keys = {60,61}

但继续思考这个同样的123456值，分别用整数型和浮点型转换为十六进制后，在内存字节上表示不同，但是又有13位是相同的二进制，

 ** 那么可以推测整数型123456的内存字节 0x00003039 和 浮点型的内存字节 0x4640E400 表示的是相同的值内容，

 ** 但是由于类型不同，附加了一些相关属性，所以导致123456的浮点型的内存字节多了一些符号表示。
 
 ** 标记此处，待后面验证

 [Java的byte数组的不同写法](https://blog.csdn.net/LVXIANGAN/article/details/41294989)
 [Java中Byte数组与十六进制字符串相互转换原理](https://cloud.tencent.com/developer/article/1385802)


数学符号大全：
https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8
```



##### 2.1.4 表示字符串

* 编码验证

  ```c
  void test_char(){
      const char *s = "abcdef";
      show_bytes((byte_pointer)s,strlen(s));
  }
  int main() {
      test_show_bytes(12345);
      test_char();
      return 0;
  }
  ```

  输出结果：

  >  39 30 00 00
  >  00 e4 40 46
  >  0c fe 61 00 00 00 00 00
  >  61 62 63 64 65 66  // abcdef 的ASCII码

* 相关编码集 ASCII、Unicode

* 编码考虑的事情

  * 能够包含大多数字符
  * 在包含大多数字符的情况下，如何保证合理占用字节空间
  * 路哥提供的哈夫曼编码压缩方法，可以合理处理这个问题

##### 2.1.5 表示代码

> 不同的机器类型使用不同的且不兼容的指令和编码方式，即使完全一样的进程，运行在不同操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。



##### 2.1.6 布尔代数运算

![image-20200606184319815](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606184319815.png)

* 布尔运算〜

  * 对应于逻辑运算 NOT

    > 当 P 不是真的时候，我们就说"T3 是真的，反之亦然。相应地，当 P 等于 0 时，〜P 等于1, 反之亦然。

* 布尔运算&

  * 对应于逻辑运算AND

    > 当P和Q都为真时，为真

* 布尔运算符 |

  * 对应逻辑运算 OR

    > 当 p=1 或者 q=1 时，p|q等于1.

* 布尔运算 ^

  * 对应逻辑运算异或

    > 当P 或者Q 为真但不同时为真时，成立。
    >
    > 当 p = 1 且 q = 0，或者 p=0 且 q=1时，p^q等于1



> 这一小节对应逻辑符号的描述，帮助理解了以前上的一门课，逻辑课，用来进行逻辑推理的公式，原来就是用计算机的数学逻辑来表示的！



* 重点概念：位向量

  > 位向量就是固定长度为 w ，由 0 和 1 组成的串。
  >
  > 位向量运算，可以定义成参数的每个对应元素之间的运算。

* 练习题 2.9 增进理解Android中对颜色的处理

* ![img](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/20160422211037563.gif)

* 练习题 2.10 帮助理解自定义View的重要环节 onMeasure 测量

  * 测量模式和测量值的存储和解析

  > //对应11000000000000000000000000000000;总共32位，前两位是1
  > int MODE_MASK  = 0xc0000000;
  >
  > //提取模式
  > public static int getMode(int measureSpec) {
  >  return (measureSpec & MODE_MASK);
  > }
  > //提取数值
  > public static int getSize(int measureSpec) {
  >  return (measureSpec & ~MODE_MASK);
  > }

​       练习题回答：

```
*x = a, *y = b

*y = *x ^ *y = a ^ b
*x = *x ^ *y = a ^ (a ^ b) = 0 ^ b = b 
*y = *x ^ *y = (0 ^ b) ^ ( a ^ b) = b ^ (a ^ b) = a 
```

* 练习题 2.11

  * 练习题回答

    ```
    A.
    end : first = k ; last = k
    B.
    此时 a[frist] = a[last]
    基于 ^ 的原理，a^a = 0; 所以，此时为0。
    C.
    跳过这个不替换。方法是 让for循环的条件排除 frist = last。也就是 将 first <= last 改为 first < last.
    ```



##### 2.1.7 C语言中的位级运算

![image-20200607135724336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607135724336.png)

* 从上图可以看出，根据 0xFF 的二进制是 [1111 1111] ，可以推出重要结论:

  * 当 `0x41 & 0xFF`  时，转换为二进制位运算，可以得到的是 `0x41` 本身。

    >​    0x41        0100  0001
    >&  0xFF        1111  1111
    >=  0X41        0100   0001

  * 当`0x41 & 0x00` 时，转换为二进制位运算，可以得到`0x41`被消减为0。

    >​    0x41        0100  0001
    >&  0x00       0000  0000
    >=  0x00        0000   0000

    这说明，可以用 数值 x 与 `0xFF` 或者 `0x00` 来进行位运算，来消减不想要的位，保留想要的位。

    再配合 `& | ~ ^` 这些布尔代数逻辑运算符，就可以进行各种位操作了。

![image-20200606183953489](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200606183953489.png)



* 练习题 2.12

  * A 

    ```
    这个很简单，按照 x & 0xFF = x ，的二进制位运算推导出来
    x=0x87654321
    x & 0xFF = 0x87654321 = 0x000000FF & 0x87654321 = 0x0000021 
    ```

  * B

    ```
    B.
    
     0x  87 65 43 21   -> ‭ 1000 0111‬   ‭0110 0101‬    0100 0011‬   ‭0010 0001‬ 
     
    ^
    
    ~0x  00 00 00 FF    -> 0000 0000   0000 0000    0000 0000   1111 1111   
         FF FF FF 00    -> 1111 1111   1111 1111    1111 1111   0000 0000   
    
     0x  78 9A BC 21    -> 0111 1000   1001 1010    1011 1100   0010 0001  
     
     > 涉及到的知识点：1字节=8位，2^4 = 16 , 也就是4位存放1个16进制，1字节=8位=2个16进制.
     > 以这种存储方式，把数据全部转换为二进制进行运算，就得出了位运算。
    ```

  * C

    ```
     0x 87654321 & ~0xFF | 0xFF
     ->标准答案：
     0x 87654321 |0xFF 
     -> 原因：
     在二进制层面，任何位 | 0xFF 都是 0|1=1，所以会全是1，也就是 x|F=F
    ```

    ![image-20200607152653648](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200607152653648.png)



##### 2.1.8 C语言中的逻辑运算符

![image-20200608223146297](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223146297.png)

按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。

##### 2.1.9 C语言中的移位运算

![image-20200608223428838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223428838.png)

> 几乎所有的编译器、机器组合都对有符号数使用算术右移，且许多程序员也假设机器会使用这种右移。另一方面，对无符号数，右移必须是逻辑的。
>
> 与C相比，Java对于如何进行右移有明确的定义。表达式 x>>k 会将 x 算术右移 k 个位置，而  x>>>k 会对 x 做逻辑右移。

![image-20200608223838205](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200608223838205.png)



#### 2.2 整数表示

![image-20200609231804178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231804178.png)

##### 2.2.1 整型数据类型

![image-20200609231848641](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609231848641.png)

> C 和 C++ 都支持有符号（默认）和无符号数。Java只支持有符号数。

##### 2.2.2 无符号数的编码

![image-20200609232141626](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232141626.png)

![image-20200609232221336](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232221336.png)

##### 2.2.3 补码编码

![image-20200609232301739](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232301739.png)

![image-20200609232321093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232321093.png)

![image-20200609232350969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232350969.png)

![image-20200609232420691](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609232420691.png)

##### * 2.2.4 有符号数和无符号数之间的转换

重要概念：对于有符号数和无符号数之间的转换，是用不同的解释方式去解释二进制位，但是本质上的二进制位并没有改变，只是改变了解读的方式，所以解读成了不同的数值。

![image-20200609233037797](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233037797.png)

##### 2.2.5 C 语言中的有符号数与无符号数

> 几乎所有的机器使用补码。通常，大多数数字都默认为是有符号的。
>
> C语言中，当声明一个像 12345 或者 0x1A2B 这样的常量时，默认是有符号的。
>
> 要创建一个无符号常量，必须加上后缀字符“U”或者"u"，
>
> 例如：12345U 或者 0x1A2Bu.

![image-20200609233503663](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609233503663.png)

##### * 2.2.6 扩展一个数字的位表示

![image-20200609234051890](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234051890.png)



##### * 2.2.7 截断数字

![image-20200609234645555](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234645555.png)

![image-20200609234656316](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234656316.png)

![image-20200609234709178](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200609234709178.png)

##### 2.2.8 关于有符号数与无符号数的建议

> 略过

#### 2.3 整数运算

##### 2.3.1 无符号加法

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610224725270.png" alt="image-20200610224725270" style="zoom:50%;" />

##### * 2.3.2 补码加法

对于补码加法，必须确定当结果太大（为正）或者太小（为负）时，应该做些什么。

![image-20200610232418089](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610232418089.png)



##### * 2.3.2 补码的非

##### * 2.3.4 无符号乘法

##### * 2.3.5 补码乘法

##### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或者更多的周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数银子的乘法。首先，会考虑乘以2的幂的情况，然后再概括成乘以任意常数。

![image-20200610233126232](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610233126232.png)

> 注意,无论是无符号运算还是补码运算,乘以2的幂都可能会导致溢出。结果表明,
> 即使溢出的时候,我们通过移位得到的结果也是一样的。
>
> 例如 将4位模式[1011] (数值为11)左移两位得到[101100] (数值为44)。将这个值截断为4位得到[1100] (数值为12=44mod16)。

##### * 2.3.7 除以2的幂

大多数机器上，整数的除法要比乘法更慢，需要30个或者更多的时钟周期。

除以2的幂也可以用移位运算来实现，只不过用的是右移，而不是左移。

无符号数分别使用逻辑移位和算术移位来达到目的。

##### 2.3.8 关于整数运算的最后思考

计算机执行的 "整数" 运算实际上是一种模运算形式。表述数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。

补码表示提供了一种既能表示负数，也能表示正数的灵活方法，同时使用了与执行无符号运算相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。

#### 2.4 浮点数

重要概念：

![image-20200610235012367](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235012367.png)

##### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。

十进制表示法使用如下形式表示：

![image-20200610235621184](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235621184.png)

![image-20200610235828093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200610235828093.png)

十进制表示法不能准确表达 1/3 , 5/7 这样的数。因为它只能精确表示那些可以被写成  x X 2^y 的数。其他的值，只能被近似的表示。

![image-20200611000145943](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000145943.png)

##### 2.4.2 IEEE 浮点表示

![image-20200611000633695](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611000633695.png)

![image-20200611001020700](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611001020700.png)

##### 2.4.3 数字示例

![image-20200611003809100](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003809100.png)

![image-20200611003905149](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003905149.png)

* 注意的点：

![image-20200611003950473](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611003950473.png)

* 一些重要的单精度和双精度浮点数的表示和数字值：

![image-20200611004333652](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004333652.png)

##### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点数运算只能近似地表示实数运算。因此，对于值 x , 我们一般想用一种系统的方法，能够找到 "最接近的"匹配值 x' ，它可以用期望的浮点数形式表示出来。

这就是舍入（rounding）运算的任务。

一个关键的问题是在两个可能的值中间确定舍入方向。

> 例如,如果我有1.50美元,想把它舍入到最接近的美元数,应该是1美元还是2美元呢?
>
> 一种可选择的方法是维持实际数字的下界和上界。

![image-20200611004755578](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611004755578.png)

* 舍入的方法

![image-20200611005845993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611005845993.png)

* 舍入方式的分析：

![image-20200611010008694](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010008694.png)

##### 2.4.5 浮点运算

![image-20200611010511900](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611010511900.png)

##### 2.4.6 C 语言中的浮点数

所有的 C 语言版本提供了两种不同的浮点数据类型：float 和 double 。

在支持 IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。

另外，这类机器使用向偶舍入的舍入方式。

> 但是，因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍人方式或者得到诸如一0、十∞、一∞或者№aN之类的特殊值。
>
> 大多数系统提供include(‘.h’)文件和读取这些特征的过程库,但是细节随系统不同而不同。

例如,当程序文件中出现下列句子时,GNU编译器GCC会定义程序常数 INFINTTY(表示+∞)和NAN(表示NaN):

```c
#define _GNU_SOURCE 1
#include <math.h>
```

##### 浮点数小结

```
① 浮点数的表示，受制于计算机的二进制方式，只能表示 x X 2^t 的数值。其他的值只能被近似的表示。

② IEEE 的浮点数表示方法，将浮点数分为 三个部分：

  <1> 符号（sign）
  <2> 尾数（significand） -> n 位的编码数 M ，表示二进制小数
  <3> 阶码（exponent）    -> k 位的编码数 E ，表示负浮点数的加权。2 的 E次幂（可能是负数）。
  
  以上这种分为三部分的表示方式，能更接近的精度的表示小数。
  
③ 以上的表示方法依然限制了浮点数的范围和精度，因此再找 '最接近的' 匹配值，使用 舍入 方法。

  > 舍入的方法，有好几种，但是面对唯一需要决策的 1.5 这种中间数值的舍入，偏向于向偶舍入。
  
  > 即，1.5 和 2.5 都舍入为 2 。这是一种最常见的策略，更容易表示。
```

#### 2.5 小结

计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C语言的设计可以包含多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。

大多数机器对于`整数使用补码编码`，而对`浮点数使用 IEEE 标准754 编码`。

`在位级上理解这些编码，并且理解算术运算的数学特性`，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

![image-20200611012004885](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012004885.png)

* 要注意的点：

![image-20200611012050830](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200611012050830.png)

### 第3章 程序的机器级表示

计算机执行`机器代码`，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的管理，经过一系列的阶段生成机器代码。

GCC C 语言编译器以及`汇编代码`的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用 `汇编器` 和 `链接器` ，根据汇编代码生成可执行的机器代码。

#### 3.1 历史观点

#### 3.2 程序编码

![image-20200612000317416](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612000317416.png)

##### 3.2.1 机器级代码（原理）

重要的两种抽象概念：

* 第一种是由 `指令集体系结构或指令集架构` 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

  > 大多数 ISA ，包括 x86-64 ，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。
  >
  > 处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

* 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

  > 存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。
  >
  > 第9章会讲到。

![image-20200612001116141](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001116141.png)

虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。

> C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
>
> 即使是对标量数据类型，汇编代码也不区分有符号和无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。

![image-20200612001722618](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612001722618.png)

##### 3.2.2 代码示例（原理）

![image-20200612002330761](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612002330761.png)

* 调试 mstore.o

  ![image-20200612004851388](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612004851388.png)

  > gdb 调试上述程序的方式。
  >
  > ① gdb mstore.o   // 开始调试可执行文件
  >
  > ② x/14xb multstore // 告诉GDB显示从函数 multstore 所处地址开始的 14 个进制格式表示的字节。 
  >
  > 其他命令：quit // 退出gdb调试

  调试结果:

  ```shell
  (gdb) x/14xb multstore
  0x0 <multstore>:        0x53    0x48    0x83    0xec    0x20    0x4c    0x89    0xc3
  0x8 <multstore+8>:      0xba    0x02    0x00    0x00    0x00    0xe8
  (gdb) quit
  ```

* [gdb调试参考资料](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)

* 反汇编器(disassembler)

  ![image-20200612005425280](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200612005425280.png)

​     使用 objdump 实际反汇编的结果：

```shell
//windows下执行
// mstore.o 大小：758
objdump.exe -d mstore.o

mstore.o:     file format pe-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 83 ec 20             sub    $0x20,%rsp
   5:   4c 89 c3                mov    %r8,%rbx
   8:   ba 02 00 00 00          mov    $0x2,%edx
   d:   e8 00 00 00 00          callq  12 <multstore+0x12>
  12:   89 03                   mov    %eax,(%rbx)
  14:   48 83 c4 20             add    $0x20,%rsp
  18:   5b                      pop    %rbx
  19:   c3                      retq
  1a:   90                      nop
  1b:   90                      nop
  1c:   90                      nop
  1d:   90                      nop
  1e:   90                      nop
  1f:   90                      nop
```

其中一些关于机器代码和它的反汇编表示的特性值得注意：

* x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。

* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。

  > 例如，只有指令 pushq %rbx 是以字节值 53 开头的。

* 反汇编只是给予机器代码文件中的字节序列来确定汇编代码。

  > 它不需要访问程序的源代码或者汇编代码。

* 反汇编其使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。

  > 在我们的示例种，它省略了很多指令结尾的 `q` 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编其给 call 和 ret 指令加了 `q` 后缀，同样，省略这些后缀也没有问题。

![image-20200613124456938](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613124456938.png)

 然后，用以下方法生成可执行文件 prog:

```shell
linux > gcc -Og -o prog main.c mstore.c
```

![image-20200613143527397](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613143527397.png)

> 在当前 windows10 机器上测试，变成了 47083 个字节。这说明在不同机器上，生成的字节是不一样的。虽然通过编译器，可以保证执行的结果是一致的，但是二进制产生了差异，这就是不同操作系统和硬件的翻译有区别。编译器处理了这一层差异。

上面讲的抽取出的这段代码与 mstore.c 反汇编产生的代码几乎完全一样。

几点细微的区别如下：

* 第一个主要的区别是 左边列出的地址不同 —— 链接器将这段代码的地址移到了一段不同的地址范围中。

* 第二个不同之处在于链接器填上了 callq 指令调用函数 mult2 需要使用的地址（上面抽取出的反汇编代码第4行）。

  链接器的任务之一就是 `为函数调用找到匹配的【函数的可执行代码的位置】` 。

* 最后一个区别是多了两行代码（第8和第9行）。

  这两条指令对程序没有影响，因为它们出现在返回指令后面（第7行）。插入这些指令是为了使函数代码变为16字节，使得就存储器性能而言，能更好的放置下一个代码块。

  > 这里表达的意思应该是，存储器更适宜于存取机器/系统指定的固定长度的地址，这里16字节为一个长度单位去存取数据是最快的，在不同机器、系统环境下这个适宜的长度单位应该也会发生变化。

##### 3.2.3 关于格式的注解

GCC 产生的汇编代码对于我们来说有点难读。一方面，它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。

例如，假设我们用如下命令生成文件 mstore.s ：

![image-20200613145002462](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145002462.png)

所有以 "." 开头的行都是知道汇编器和链接器工作的伪指令，我们通常可以忽略这些行。

另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

![image-20200613145227519](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145227519.png)

通常我们只会给出与讨论内容相关的代码行。每一行左边都有编号供引用，右边是注释，简单描述指令的效果以及它与原始C语言代码中的计算操作的关系。

这是一种汇编语言程序员写代码的风格。

#### 3.3 数据格式

![image-20200613145740644](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613145740644.png)

如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

> 例如，数据传送指令有四个变种：moveb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。
>
> 后缀 '1' 用来表示 4 字节整数 和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

#### 3.4 访问信息

一个 x86-64 的中央处理单元(CPU) 包含一组16个存储64位值的`通用目的寄存器`。

![image-20200613150242935](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150242935.png)

![image-20200613150313874](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613150313874.png)

有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

> 在  `3.7 - 过程` 章节中描述过程的实现时，会讲述这些惯例。   

##### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

> 源数据值可以以常数形式给出，或是从寄存器或内存中读出。
>
> 结果可以存放在寄存器或内存中。

因此操作数被分为三种类型：

* 立即数(immediate)

  > 表示常数值。
  >
  > ATT格式的汇编代码种，立即数用 $ 来表示（参考的描述，不准确）

* 寄存器(register)

  > 表示某个寄存器的内容。
  >
  > 用 r 表示寄存器（参考的描述，不准确）

* 内存引用(Mb[Addr])

  > 根据计算出来的地址(通常称为`有效地址`)访问某个内存位置。
  >
  > 用 M 表示内存引用（参考的描述，不准确）

![image-20200613151316013](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151316013.png)

##### 3.4.2 数据传送指令

最频繁使用的指令，是将数据从一个位置复制到另一个位置。

操作数表示的通用性，使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

>  把许多不同的指令划分成 `指令类` ，
> 每一类中的指令执行相同的操作，只不过操作数大小不同。

![image-20200613151753993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613151753993.png)

![image-20200613152029123](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152029123.png)

![image-20200613152234259](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152234259.png)

##### 3.4.3 数据传送示例

![image-20200613152505439](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613152505439.png)

这段汇编代码有亮点值得注意：

① C 语言中的 "指针" 就是地址。

> 间接引用指针就是将该指针放在一个寄存器中，然后在内存中使用这个寄存器。

② 像 x 这样的局部变量通常是保存在寄存器中，而不是内存中。

> 访问寄存器比访问内存要快的多。

##### 3.4.4 压入和弹出数据

![image-20200613153526387](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153526387.png)

![image-20200613153602838](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613153602838.png)

> 栈在内存中的某个地方，所以压栈是：减少寄存器的值，将数据存放到内存中。

#### 3.5 算数和逻辑操作

![image-20200613154411994](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613154411994.png)

操作分类分类：

* 加载有效地址
* 一元操作
* 二元操作
* 移位

> 二元操作有两个操作数，一元操作有一个操作数

##### 3.5.1 加载有效地址

`加载有效地址(load effective address)` 指令 `leaq` 实际上是 movq 的指令变形。

它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。

> 它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

![image-20200613155417025](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613155417025.png)

这二个指令的效果是将 `S的地址` 写入到 `寄存器D` 。

根本没有引用内存，只是操作的地址。

![image-20200613160045168](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613160045168.png)

##### 3.5.2 一元和二元操作

`这里的分组，都是指 图3-10 中的分组。`

第二组中的操作是一元操作，只有一个操作数，既是源又是目的。

> 这个操作数可以是一个寄存器，也可以是一个内存地址。

第三组是二元操作，其中，第二个操作数既是源又是目的。

> 注意1：源操作数是第一个，目的操作数是第二个。
>
> 第一个操作数可以是立即数、寄存器或是内存地址。
>
> 第二个操作数可以是寄存器或是内存地址。
>
> 注意2：当第二个操作数是内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

##### 3.5.3 移位操作

![image-20200613161003390](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161003390.png)

##### 3.5.4 讨论

图3-10 所示的大多数指令，既可以用于无符号运算，也可以用于补码运算。

>  只有右移操作要求区分有符号和无符号。
>
> 这个特性是补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

![image-20200613161435121](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613161435121.png)

##### 3.5.5 特殊的算数操作

![image-20200613162933114](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613162933114.png)

#### 3.6 控制

到目前位置，我们只考虑了 `直线代码行为` ，也就是指令一条接接着一条顺序的执行。

C 语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。

机器代码提供两种基本的低级机制来实现有条件的行为：

① 测试数据值

② 然后根据测试的结果来改变控制流或数据流。

与数据相关的控制流是实现有条件行为更一般和更常见的方法。

> 通常 C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。
>
> 用 jump 指令，可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。
>
> 编译器必须产生构建在这种低级机制基础上的指令序列，来实现C语言的控制结构。

##### 3.6.1 条件码

除了整数寄存器，CPU还维护着一组单个位的 `条件码(condition code) 寄存器` ，它们描述了最近的算术或逻辑操作的属性。

可以检测这些寄存器来执行条件分支指令。

最常用的条件码有：

* CF : 进位标志

  > 最近的操作使最高位产生了进位。
  >
  > 可用来检查无符号操作的溢出。

* ZF : 零标志

  > 最近的操作得出的结果为0。

* SF : 符号标志

  > 最近操作得到的结果为负数。

* OF : 溢出标志

  > 最近的操作导致一个补码溢出 —— 正溢出负溢出。

![image-20200613164720092](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164720092.png)

##### 3.6.2 访问条件码

条件码通常不会直接读取，通常的使用方法有三种：

① 可以根据条件码的某种组合，将一个字节设置为 0 或者 1

② 可以条件跳转到程序的某个其他的部分

③ 可以有条件地传输数据

![image-20200613164933457](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613164933457.png)

##### 3.6.3 跳转指令

正常执行的情况下，指令按照它们出现的顺序一条一条地执行。

`跳转` 指令会导致执行切换到程序中一个全新的位置。

在汇编代码中，这些跳转的目的地通常用一个符号(label) 指明。

![image-20200613165142534](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165142534.png)

##### 3.6.4 跳转指令的编码

虽然我们不关心及前期代码格式的细节，但是理解跳转指令的目标如何编码，这对`研究链接(第7章)`非常重要。

此外，它也能帮助理解反汇编器的输出。

>  在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。
>
> 第一种编码：
> 跳转指令有几种不同的编码，但是最常用的都是 `PC相对的(PC-relative)` 。
> 也就是说，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2或4个字节。
>
> 第二种编码：
> 这种编码方式是，给出"绝对"地址，用4个字节直接指定目标。
>
> 以上两种方式编码用哪种，取决于汇编器和链接器会选择适当的跳转目的编码。

![image-20200613165918872](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613165918872.png)

##### 3.6.5 用条件控制来实现条件分支

将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。

(另一种方式在 3.6.6节有讲，有些条件可以用数据的条件转移实现，而不是用控制的条件转移来实现。)

##### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用 `控制的条件转移`。

> 当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。
>
> 这种机制简单而通用，但是在现代处理器上，它可能非常低效。

一种替代的策略是使用 `数据的条件转移`。

> 这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。
>
> 只有在一些受限制的情况中，这种策略才可行。
>
> 但是如果可行，就可以用一条简单的 条件传送 指令来实现它。条件传送指令更符合现代处理器的性能特性。

```
为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码（如图 3-16 中
那样）性能要好，我们必须了解一些关于现代处理器如何运行的知识。正如我们将在第 4
章和第 5 章中看到的，处理器通过使用流水线（pipelining)来获得高性能
```

##### 3.6.7 循环

`汇编中没有循环指令存在，可以用条件测试和跳转组合起来实现循环的效果。`

* 思考
  * 前提：如何翻译成汇编主要取决于汇编器
  * 问题：
    * 那么不同语言的不同汇编器产生的汇编是不同的，二进制是否相同？
      * 汇编不同，二进制也应该不同
        * 那么执行的时候，不同汇编器产生的二进制，如何执行起来的？

##### 3.6.8 switch 语句

![image-20200613171429054](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613171429054.png)

#### 3.7 过程（重要）

过程是软件中一种很重要的抽象。

> 它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。
>
> 然后，可以在程序中不同的地方调用这个函数。
>
> 设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。

不同编程语言中，过程的形式多样，主要的有以下几种：

* 函数(function)
* 方法(method)
* 子例程(subroutine)
* 处理函数(handler)

但是它们都有一些共性。要提供对过程的机器级支持，必须要处理许多不同的属性。

为了方便讨论，`假设 过程P 调用 过程Q ， Q 执行后返回到 P `，这些动作至少包含以下共性之一：

* 传递控制

  > 在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，要把程序计数器设置为 P 中调用 Q 后面那条指令的地址。

* 传递数据

  > P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。

* 分配和释放内存

  > 在开始时，Q 可能需要为局部变量分配控件，而在返回前，又必须释放这些存储空间。

##### 3.7.1 运行时栈

C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。

> 在 过程P 调用 过程Q 的例子中，可以看到当 Q 在执行时，P 以及所有在向上追溯到 P 的调用链中的过程，都是暂时被挂起的。
>
> 当 Q 运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
> 另一方面，当 Q 返回时，任何它所分配的局部存储空间都可以被释放。
> 因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。
>
> 当 P 调用 Q 时，控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。

![image-20200613173457689](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173457689.png)

大多数过程的栈帧都是定长的，在过程开始就分配好了。

但是，有些过程需要变长的帧，这个问题会在 `3.10.5` 节中讨论。

> 通过寄存器 ，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。
>
> 思考：这是不是意味着，超过 6 个参数，会导致性能下降？

![image-20200613173920746](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613173920746.png)

> 思考：这里的6个参数寄存器性能限制，是对C语言来讲的，那么基于JVM的Java，是否也是相同的限制？

##### 3.7.2 转移控制

将控制从 函数P 转移到 函数Q 只需要简单地把程序计数器(PC) 设置为 函数Q 代码的起始位置。

不过，当稍后从 Q 返回时，处理器必须记录好它需要继续 函数P 执行的代码位置。

> 在 x86-64 机器中，这个信息是用指令 `call Q`  调用过程Q 来记录的。
>
> 该指令会把 地址A 压入栈中，并将 PC 设置为 函数Q 的起始地址。
>
> 压入的 地址A  被称为返回地址，是 `紧跟在 call 指令后面的那条指令的地址` 。
>
> 对应的 `指令ret` 会从栈中弹出 地址A ，并把 PC 设置为 A 。

> 自己组织语言解释：
>
>  `call指令` 会先把 "执行完call后的下一条指令地址 A" 压入栈中，并将 PC 设置为 "要call的Q函数地址" 。这样，当 Q函数 执行完，调用 `ret指令` 时，会从栈中弹出 "执行完call后的下一条指令地址 A" ，并将 PC 设置为 地址A ， 从而继续执行 call指令之前的程序顺序。

思考：逆向中的找 call ，其实要关注两点：① call ② ret 

> call 指令保存了执行call之后的下一条指令地址，
>
> ret 指令从栈中弹出了要继续执行的 下一条指令地址。

![image-20200613180018825](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613180018825.png)

> 图3-3 出现在 3.4.1 节。

##### 3.7.3 数据传送

当调用一个过程时，除了要 `把控制传递给它` 并在过程 `返回时再传递回来` 之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。

x86-64 中，大部分过程间的数据传送是通过寄存器实现的。

> 例如，我们已经看到无数的函数示例，参数在寄存器％rdi、％rsi 和其他寄存器中传递。
>
> 当过程 **P** 调用过程 **Q** 时，**P** 的代码必须首先把参数复制到适当的寄存器中。
>
> 类似地，当 **Q** 返回到 **P** 时，**P** 的代码可以访问寄存器 %rax 中的返回值。

![image-20200613181206520](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613181206520.png)

> 思考：在 windows 中是否也有这种规则，根据寄存器的名字，可以推断出是第几个参数？

![image-20200613181558831](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613181558831.png)

> 图3-25 出现在 3.7.1 节

##### 3.7.4 栈上的局部存储

到目前为止，看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。

不过，有些时候，局部数据必须存放在内存中，常见的情况包括：

* 寄存器不足够存放所有的本地数据

* 对一个局部变量使用地址运算符 '&' ，因此必须为它产生一个地址。

  > 思考：这也就是说，当使用地址运算符 '&' 时，即使这个数据没有在内存中，是在寄存器中，那么也要把它放入内存中，产生一个内存地址？

* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

  > 在描述数组和结构分配时，会讨论这个问题

一般来说，过程通过减小栈指针在栈上分配空间。

分配的结果作为栈帧的一部分，标号为 "局部变量" ，在图 3-25 中有展示。

> 图3-25 出现在 3.7.1

##### 3.7.5 寄存器中的局部存储空间

`寄存器组是唯一被所有过程共享的资源` 。

虽然在给定时刻，只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值。

> 为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循。

思考：寄存器是CPU资源，也就是说符合 x86-64 结构CPU的操作系统（例如linux、mac、windows），都需要遵循相同的寄存器规则？

![image-20200613183957646](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613183957646.png)

##### 3.7.6 递归过程

前面已经描述的寄存器和栈的惯例使得 x86-64 能够递归的调用它们自身。

每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。

此外，栈的原则很自然的就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。

![image-20200613185311956](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613185311956.png)

![image-20200613185327077](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613185327077.png)

从这个例子中，我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。

如果需要，它还可以提供局部变量的存储。`栈分配和释放的规则` 很自然地就与 `函数调用-返回的顺序` 匹配。这种实现函数调用和返回的方法，甚至对更复杂的情况也适用，包括相互递归调用（例如，过程 P 调用 Q ，Q 再调用 P）。

> 思考，理解递归，只需要入手三个步骤：
>
> ① 入参规则（一般有规律）
>
> ② 拿掉递归的功能逻辑
>
> ③ 从递归最底层倒推两步，最多三步，就可以理解了
>
> 看懂拿掉递归的功能逻辑，再把有规律的入参一一带入，就很容易理清楚逻辑了。

 ```
用以上理解递归的思路去分析 图3-35 a) :
① 入参规则（一般有规律）
rfact(n-1) 决定了入参的规则，那么，假如起始 n = 9 , 
整个递归过程中，n = 9,8,7,6,5,4,3,2,1 
② 拿掉递归的功能逻辑
保证 n 为 1 后，依次 n * rfact(n-1)。
③ 从递归最底层倒推两步，最多三步
2*rfact(2-1) => 2*1   //n=2时，最底层的一步
3*rfact(3-2) => 3*2*1 //n=3时，倒数第二步

推到出来，很清晰明了。
 ```

#### 3.8 数组分配和访问

C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。

C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。

C 语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。

在机器代码中，这些指针会被翻译成地址计算。

> 这说明，C语言的指针运算天然对机器级代码友好。性能高。

> 拓展说说明：优化编译器非常善于简化数组索引所使用的地址计算。不过这使得C代码和它到机器代码的翻译之间的对应关系有些难以理解。

##### 3.8.1 基本原则

![image-20200613192452991](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613192452991.png) 

![image-20200613233801960](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613233801960.png)

> x86-64 的内存引用指令可以用简化数组访问。

##### 3.8.2 指针运算

C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。

![image-20200613234640361](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613234640361.png)

但操作数操作符 '&' 和 '*' 可以产生指针和间接引用指针。

* & : 直接产生指针地址，即时值在寄存器中，也会压入内存栈中，产生一个内存地址。
* '*' : 间接引用指针，指地址上的内容值，想要使用指针地址时，还是需要使用 & 。

![image-20200613235047082](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235047082.png)

* 拓展

  ![image-20200613235156131](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235156131.png)



##### 3.8.3 嵌套的数组

当创建数组的数组时，数组分配和引用的一般原则也是成立的。

![image-20200613235629907](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235629907.png)

##### 3.8.4 定长数组

C 语言编译器能优化定长多维数组上的操作代码。

![image-20200613235825365](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200613235825365.png)

##### 3.8.5 变长数组

历史上，C 语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。

程序员需要变长数组时，不得不用 `malloc` 或 `calloc` 这样的函数为这些数组分配存储空间。 

* 拓展资料

> 函数malloc()和calloc()都可以用来动态分配内存空间,但两者稍有区别。 
>
> malloc()函数有一个参数,即要分配的内存空间的大小: 
>
> void *malloc(size_t size); 
>
> calloc()函数有两个参数,分别为元素的数目和每个元素的大小,这两个参数的乘积就是要分配的内存空间的大小。 
>
> void *calloc(size_t numElements,size_t sizeOfElement); 
>
> 如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的首地址。 
>
> 函数malloc()和函数calloc()的主要区别是前者不能初始化所分配的内存空间,而后者能。如果由malloc()函数分配的内存空间原来没有 被使用过，则其中的每一位可能都是0;反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。也就是说，使用malloc()函数的程序开 始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。 
>
> 函数calloc()会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那麽这些元素将保证会被初始 化为0;如果你是为指针类型的元素分配内存,那麽这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零。 
>
> **realloc函数**
> 先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。
> 函数的原型是extern void *realloc(void *mem_address, unsigned int newsize)；
>
> 参考地址资料：
>
> [ C语言中malloc()和calloc()c函数用法 ](https://www.cnblogs.com/stevenwuzheng/p/5484986.html)
>
> [C语言中malloc，calloc，realloc等动态分配内存函数特点详解](https://blog.csdn.net/MarcoAsensio/article/details/85937002)

![image-20200614000745988](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614000745988.png)

* 动态的变长数组的优缺点

![image-20200614001017395](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001017395.png)

![image-20200614001220886](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001220886.png)

![image-20200614001236596](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614001236596.png)

#### 3.9 异质的数据结构

C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：

* 结构(structure)

  > 用关键字 `struct` 来声明，将多个对象集合到一个单位中。

* 联合(union)

  > 用关键字 `union` 来声明，允许用几种不同的类型来引用一个对象。



##### 3.9.1 结构

C 语言的  `struct` 声明创建一个数据类型，将可能不同的类型的对象聚合到一个对象中。

用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。

编译器维护关于每个结构类型的信息，指示每个字段 (field) 的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

![image-20200614002434161](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002434161.png)

##### 3.9.2 联合

联合提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。

![image-20200614002612170](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002612170.png)

![image-20200614002932167](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614002932167.png)

##### 3.9.3 数据对齐（有用）

许多计算机系统对基本数据类型的合法地址做出了一些限制。

要求某种类型对象的地址必须是某个值 K (通常是2、4 或 8) 的倍数。这种 `对齐限制` 简化了形成处理器和内存系统之间接口的硬件设计。

> 例如，假设一个处理器总是从内存中取 8 个字节，则地址必须为 8 的倍数。
>
> 如果能够保证将所有的 double 类型数据的地址对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了。
>
> 否则，可能需要执行两次内存访问，因为对象可能被分别放在两个 8 字节内存块中。

**对齐的优势，终于理解了**。

无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。

对齐的原则是：任何 K 字节的基本对象的地址必须是 K 的倍数。

可以看到这条原则会得到如下对齐：

![image-20200614003836562](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614003836562.png)

* 结构的对齐

  对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。

  > 也就是说结构的 K 是取它 `包含对象的k` 的最小公倍数。

  ![image-20200614004345354](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004345354.png)

  > 从上图可以看出，
  >
  > 偏移量：指的也就是对起始地址的偏移长度。

  编译器结构的末尾可能需要一些填充，这样数据结构中的每个元素都会满足它的对齐要求。

  例如，考虑下面这个结构声明：

  ![image-20200614004600173](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004600173.png)

* 总的来说，结构的对齐，从起始地址、到包含对象的地址、到结尾地址都应该满足 `包含对象的k 的最小公倍数`。

![image-20200614004941465](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614004941465.png)

#### 3.10 在机器级程序中将控制与数据结合起来

![image-20200614005302486](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614005302486.png)

##### 3.10.1 理解指针（重要）

![image-20200614010135287](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010135287.png)

![image-20200614010145018](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010145018.png)

* 函数指针的重点介绍

![image-20200614010410665](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614010410665.png)

##### 3.10.2 应用：使用 GDB 调试器

GUN 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。

有了 GDB ，可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。

![image-20200614022956679](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614022956679.png)

![image-20200614023300513](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023300513.png)

 ##### 3.10.3 内存越界引用和缓冲区溢出(安全相关)

我们已经看到，C 对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。

这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。

当程序使用这个被破坏的状态，试图重新加载寄存器或执行 `ret指令` 时，就会出现很严重的错误。

一种特别常见的状态破坏成为 `缓冲区溢出(buffer overflow)` 。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。

下面这个程序示例说明了这个问题：

![image-20200614023841780](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023841780.png)

![image-20200614023919807](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614023919807.png)

![image-20200614024027711](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024027711.png)

##### 3.10.4 对抗缓冲区溢出攻击

对抗缓冲区溢出攻击的方式：

* 栈随机化

  ![image-20200614024356852](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024356852.png)

![image-20200614024501712](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024501712.png)

* 栈破坏检测

  ![image-20200614024726737](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024726737.png)

* 限制可执行代码区域

  ![image-20200614024949243](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614024949243.png)

##### 3.10.5 支持变长栈帧

 到目前未知，我们已经检查了各种函数的机器级代码，但它们有一个共同点，即编译器能够预先确定需要为栈帧分配多少空间。

但是有些函数，需要的局部存储是变长的。

> 例如当函数调用 alloca 时就会发生这种情况。alloca 是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。

实现变长栈帧的过程，需要理解数组和对齐。

![image-20200614025501247](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614025501247.png)

![image-20200614025904516](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614025904516.png)

> 思考：变长栈帧，也是先保存变量值和相关需保存的环境值，然后在栈顶开辟空间，但是，根据前面描述的理论，栈顶的地址是越来越小的，那么这样去开辟空间，是否就会遇到栈顶预留地址不够开辟的情况？例如当前栈顶是 0x100 ，但是需要再开辟 多余0x100 个偏移的空间，栈顶地址不够用了？

#### 3.11 浮点代码

处理器的 `浮点体系结构` 包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

* 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。

* 对浮点数据操作的指令。

* 向函数传递浮点数参数和从函数返回浮点数结果的规则。

* 函数调用过程中保存寄存器的规则

  > 例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。

  ![image-20200614030946586](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614030946586.png)

这里的原理讲述是基于 AVX2 ，即 AVX 的第二个版本。它是在 2013 年 Core i7 Haswell 处理器中引入的（切实身边贴切的Haswell处理器，不再是讲古董了！）。

* 需要注意的点

  ![image-20200614031420925](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614031420925.png)

![image-20200614121727899](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614121727899.png)

##### 3.11.1 浮点传送和转换操作

重要概念：

* 向量指令

  > 向量指令的基本操作对象是向量。即，有序排列的一组数。
  >
  > 若指令为向量操作，则由指令确定向量操作数的地址（主存储器起始地址或向量寄存器号），并直接或隐含地指定如增量、向量长度等其他向量参数。
  >
  > 向量指令规定处理机按同一操作处理向量中的所有分量，可有效地提高计算机的运算速度。

* 标量指令

  > 不具备向量处理功能，只能对单个量即标量进行操作的指令，称为标量指令。

计算机指令系统的种类划分：

![image-20200614173825132](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614173825132.png)

[参考资料：指令系统-百科]([https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F](https://baike.baidu.com/item/指令系统))

![image-20200614173941497](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614173941497.png)

图 3-46 给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。

**引用内存的指令是`标量质量`** ，意味着它们只对单个而不是一组封装好的数据值进行操作。

数据要么保存在内存中(由表中的`M32`和`M64`指明)，要么保存在 XMM 寄存器中(在表中用X表示)。

>  无论数据对齐与否，这些指令都能正确执行，不过代码优化建议 32 位内存数据满足 4 字节对齐，64位数据满足 8 字节对齐。
>
> 内存引用的指定方式与整数 MOV 指令一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。

![image-20200614174452643](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614174452643.png)

##### 3.11.2 过程中的浮点代码

在 x86-64 中，XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。

如图 3-45（图在3.11小节开篇） 所示，可以看到如下规则：

* XMM 寄存器 %xmm0 ~ %xmm7 最多可以传递8个浮点数参数。

  > 按照参数列出的顺序使用这些寄存器。
  >
  > 可以通过栈传递额外的浮点参数。

* 函数使用寄存器 %xmm0 来返回浮点值。

* 所有的 XMM 寄存器都是调用者保存的。

  > 被调用者可以不用保存就覆盖这些寄存器中任意一个。

**当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过 XMM 寄存器传递。**

**也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。**

下面是一些例子：

![image-20200614175412814](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614175412814.png)

> 上面第三个 double f1(float x, double *y , long *z) ，中的 double *y 应该是作为一个指针类型来存放的？否则，作为双精度浮点数 double 类型，应该在 %xmm~%xmm7 中。
>
> 下一小节 3.11.3 中的例子，证明了这一点。

##### 3.11.3 浮点运算操作

![image-20200614175927969](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614175927969.png)

![image-20200614180007451](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614180007451.png)

##### 3.11.4 定义和使用浮点常数

> 操作数 中 立即数 的概念，在 3.4.1 小节。立即数值就是常数值。

和整数运算操作不同，AVX 浮点操作不能以 `立即数值` 作为 `操作数`。

相反，编译器必须为所有的常量值分配和初始化空间，然后代码再把这些值从内存读入。

下面从摄氏度到华氏度转换的函数就说明了这个问题：

![image-20200614180828074](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614180828074.png)

##### 3.11.5 在浮点数代码使用位级操作

有时我们会发现 GCC 生成的代码会在 XMM 寄存器上执行位级操作，得到有用的浮点结果。

![image-20200614181225943](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181225943.png)

上图 3-50 展示了一些相关的指令，类似于它们在通用寄存器上对应的操作。

这些操作都作用于封装好的数据，即它们更新整个目的 XMM 寄存器，对两个源寄存器的所有位都实施指定的位级操作。

##### 3.11.6  浮点数比较操作

![image-20200614181752684](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181752684.png)

![image-20200614181809479](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614181809479.png)

##### 3.11.7 对浮点代码的观察结论

我们可以看到，用 AVX2 为浮点数上的操作产生的机器代码，风格类似于证书上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数。

当然，处理不同的数据类型以及对包含`混合数据类型`的`表达式求值`的规则有许多复杂之处，同时，AVX2 代码包括许多比只执行整数运算的函数更加不同的指令和格式。

AVX2 还有能力在封装好的数据上执行并行操作，使计算机执行的更快。

> 编译器开发者致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的可靠方法是使用 GCC 支持的、操纵向量数据的 C 语言扩展。

#### 3.12 小结

![image-20200614182828292](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614182828292.png)

* 通过 C 语言提供的抽象层面下的东西，了解机器级编程。

  > 这一点很重要，这章节的都是基于C语言的GCC编译器的。
  >
  > 这些理论都是相似的，但是非C语言的情况下，具体实现上多少会有些不同。
  >
  > 这里只分析了 C 到 x86-64 的映射，但是大多数内容对其他语言和机器组合来说也是类似的。

* 通过让编译器产生机器级的汇编代码表示，了解了编译器和它的优化能力，以及 `机器`、`数据类型` 和 `指令集`。

  > 第5章，将会编写能有效映射到机器上的程序，会比较重要。
  >
  > 了解本章讲述的编译器特性，会帮助理解第5章。

*  Java的实现方式跟这里完全不同。

  > Java 的目标代码是一种特殊的二进制表示，称为 `Java字节代码`。
  >
  > `Java字节码` 这种代码可以看成是虚拟机的机器级程序。
  >
  > `Java字节码` 的这种虚拟机的机器级程序，并不是直接用硬件实现的，而是用软件解释处理字节码，虚拟的去模拟机器行为。（要理解这种虚拟机器行为的字节码，需要去读JVM的相关书籍？）



### 第4章 处理器体系结构

#### (本章节重要但需后延细读)

> 本章节很重要，但是鉴于现在课程量大，跟当前课程关联不是很密切，先快速阅读即可。

到目前为止，我们看到的计算机系统只限于机器语言程序级。

我们知道处理器必须执行一系列指令，**每条指令执行某个简单操作**，例如两个数相加。

---

指令被编码为由一个或多个字节序列组成的二进制格式。

重要概念：

* `指令集` 体系结构(Instruction-Set Architecture, ISA)

  > 一个处理器支持的 `指令` 和 `指令的字节集编码` 称为它的 `指令集体系结构`。

---

不同的处理器 "家族" ，例如 Intel IA32 和 x86-64 、IBM/Freescale Power 和 ARM 处理器家族，都有不同的 指令集(ISA) 。 

一个程序编译成在一种机器上运行，就不能再另一种机器上运行。

> 这里终于理解了，为什么针对不同的 ARM 芯片处理器机器，要重新编译程序了。

> 另外，同一个家族里也有很多不同型号的处理器。虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同的型号在 指令集(ISA) 级别上都保持着兼容。
>
> 一些常见的处理器家族（例如x86-64）中的处理器分别由多个厂商提供。

**因此，`指令集(ISA) ` 在编译器编写者和处理器设计人员之间提供了一个 `概念抽象层` 。**

编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；

而处理器设计者必须建造出执行这些指令的处理器。

![image-20200614193211253](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614193211253.png)

#### 4.1 Y86-64 指令集体系结构

定义一个指令集体系结构（例如 Y86-64）包括：

* 定义各种状态单元
* 指令集和它们的编码
* 一组编程规范
* 异常事件处理

##### 4.1.1 程序员可见状态

![image-20200614194739695](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194739695.png)

##### 4.1.2 Y86-64 指令

![image-20200614194240507](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194240507.png)

![image-20200614194253420](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194253420.png)

![image-20200614194311732](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194311732.png)

##### 4.1.3 指令编码

![image-20200614194411788](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194411788.png)

![image-20200614194421719](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194421719.png)

* 指令集的一个重要性质是 `字节码必须有唯一的解释` 。

  >任意一个字节序列要么是一个唯一的指令序列编码，要么就不是一个合法的字节序列

![image-20200614194633932](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614194633932.png)

##### 4.1.4 Y86-64 异常

![image-20200614195122331](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614195122331.png)

> 第 8 章会讲述，如何终止或者调用一个用户自定义的 `信号处理程序(signal handler)`。

##### 4.1.5 Y86-64 程序

略

##### 4.1.6 一些 Y86-64 指令的详情

![image-20200614195303008](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614195303008.png)

  #### 4.2 逻辑设计和硬件控制语言 HCL

**在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。**

大多数现代电路技术都是 `用信号线上的高电压` 或 `低电压` 来 `表示不同的位值`。

在当前的技术中，逻辑1 是用 1.0 伏特左右的高电压表示的，而 逻辑0 是用 0.0 伏特左右的低电压表示的。

要实现一个数字系统需要三个主要的组成部分：

* 计算 `对位进行操作的函数` 的 `组合逻辑`
* 存储 `位` 的 `存储单元`
* 控制存储器单元更新的时钟信号

![image-20200614230407574](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230407574.png)

![image-20200614230503056](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230503056.png)

##### 4.2.1 逻辑门（原理）

逻辑门是数字电路的基本计算单元。

它们产生的输出，等于它们输入位值的某个布尔函数。

![image-20200614230807147](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614230807147.png)

##### 4.2.2 组合电路和 HCL 布尔表达式

概念：

* 组合电路(combinational circuits)

  > 将很多的逻辑门组合成一个网，就能构建 计算块(computational block) ，
  >
  > 称为 组合电路

如何构建这些网有几个限制：

* 每个逻辑门的输入必须连接到下述选项之一

  * 一个系统输入（称为主输入）
  * 某个存储器单元的输出
  * 某个逻辑门的输出

* 两个或多个逻辑门的输出不能连接在一起。

  > 否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
  >
  > 大概是因为两个信号输入，大的电压盖过低的电压，产生一个异常的方向差值？

* 这个网必须是无环的。

  > 也就是在网中不能有路径经过一系列的门而形成一个回路，
  >
  > 这样的回路会导致该网络计算的函数有歧义。保证唯一性，解释的准确性、无歧义。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232310608.png" alt="image-20200614232310608" style="zoom:67%;" />

![image-20200614232326069](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232326069.png)

> 这里需要结合 4.2.1 小节中的 图 4-9 来理解

![image-20200614232436133](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232436133.png)

* 多路复用器(multiplexor)

  > 下图 4-11 给出了另一个简单但很有用的组合电路，称为 `多路复用器(multiplexor， 通常称为 "MUX")` 。
  >
  > 多路复用器 根据 `输入控制信号的值`，从一组不同的数据信号中选出一个。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614232606254.png" alt="image-20200614232606254" style="zoom:67%;" />

在 上图4-11 这个 `单个位` 的 多路复用器中，两个数据信号是 输入位 a 和 b , 控制信号是输入位 s 。

> 当 s 为 1 时，输出等于 a ；
> 当 s 为 0 时，输出等于 b 。
>
> 在这个电路中，我们可以看出两个 AND 门决定了是否将它们相对应的数据输入传送到  OR 门。
>
> 当 s 为 0 时，上面的 AND 门将传送信号 b（因为这个门的另一个输入是 !s），
> 当 s 为 1 时，下面的 AND 门将传送信号 a 。

接下来，写 上图4-11 的 输出信号 HCL 表达式，使用的就是组合逻辑中相同的操作：

```
bool out = (s && a) || (!s && b);
```

![image-20200614234119286](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614234119286.png)

重要特性：

> 由于 组合电路 是由一系列的逻辑门组成，它的属性是输出会持续的响应输入的变化。
>
> 如果电路的输入变化了，在一定的延迟后，输出也会相应的变化。
>
> 跟硬件中的 赫兹(Hz) 概念是一样的，硬件中的逻辑门都会持续响应，这是特性。 

##### 4.2.3 字级的组合电路和 HCL 整数表达式

通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。

通常，我们设计能对 数据字(word) 进行操作的电路。

有一些位级信号，代表一个整数或一些控制模式。

> 例如，我们的处理器设计将包含有很多字，字的大小范围为 4位到64位，代表整数、地址、指令代码和寄存器标识符。

执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。

![image-20200614234806395](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614234806395.png)

##### 4.2.4 集合关系

在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614235603359.png" alt="image-20200614235603359" style="zoom: 67%;" />

下面来看一个简单的例子，假设想从一个两位信号 code 中选择 `高位` 和 `低位` 来为 图4-14 中的四路复用器产生信号 s1 和 s0 , 

如下图所示：

![image-20200614235655234](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200614235655234.png)

##### 4.2.5 存储器和时钟（原理）

组合电路从本质上讲，不存储任何信息。

相反，它们知识简单地相应输入信号，产生等于输入的某个函数的输出。

概念：

* 时序电路(sequential circuit)

  > 有状态并且在这个状态上进行计算的系统。

为了产生 `时序电路(sequntial circuit)` ，我们必须引入按位存储信息的设备。

存储设备都是由 同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。

考虑两类存储设备：

* 时钟寄存器（简称寄存器） 

  > 存储单个位或字。
  >
  > 时钟信号控制寄存器加载输入值。

* 随机访问存储器（简称内存）

  > 存储多个字，用地址来选择该读或该写哪个字。

  随机访问存储器的例子包括:
* 处理器的虚拟内存系统
  
    > 硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字。
  
  * 寄存器文件
  
    > 在此，寄存器标识符作为地址。
    >
    > 在 IA32 或 Y86-64 处理器中，寄存器文件有 15 个程序寄存器（%rax~%r14）

注意：

在说到硬件和机器编程时，"寄存器" 这个词是两个有细微差别的事情。

* 在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。

* 在机器级编程中，寄存器代表的是 CPU 中位数不多的可寻址的字，这里的地址是寄存器 ID 。

  > 这些字通常都存在寄存器文件中，虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再读出来的延迟。
  >
  > 需要避免歧义时，我们会分别称为这两类寄存器为 "硬件寄存器" 和 "程序寄存器"。

![image-20200615001818505](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001818505.png)

![image-20200615001842877](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001842877.png)

![image-20200615001855766](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615001855766.png)

#### 4.3 Y86-64 的顺序实现 

> 此章节，待路上阅读，重要的阅读时间，留给跟课程密切相关的章节。



### 第5章 优化程序性能

编写高效程序需要做到以下几点：

* 必须选择一组适当的算法和数据结构

* 必须编写出编译器能够有效优化以转换成搞笑可执行代码的源代码

  > 对于这第二点，理解优化编译器的能力和局限性很重要。
  >
  > 编写程序方式中看上去只是一点小小的变动，都会引起编译器优化方式很大的变化。

程序优化的第一步就是消除不必要的工作，让代码尽可能有效的执行所期望的任务。

这包括消除不必要的函数调用、条件测试和内存引用。

> 这些优化不依赖于目标机器的任何具体属性。

#### 5.1 优化编译器的能力和局限性

现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。

然后，会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。

#### 5.2 表示程序性能

我们引入度量标准 `每元素的周期数(Cycles Per Element,CPE)` ，作为一种表示程序性能并知道我们改进代码的方法。

CPE 这种度量标准帮我我们在更细节的级别上理解迭代程序的循环性能。

>  这样的度量标准对执行重复计算的程序来说，是很适当的。
>
> 例如，处理图像中的像素，或是计算矩阵乘积中的元素。

处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用 `千兆赫兹(GHz)` ，即 十亿周期 每秒来表示。

> 例如，当表明一个系统有 "4GHz" 处理器，这表示处理器时钟运行频率为每秒 4x10^9 个周期。

**每个时钟周期的时间是时钟频率的倒数**。

通常是以纳秒(nanosecond, 1 纳秒= 10^-9 秒) 或皮秒(picosecond, 1 皮秒等于 10^-12秒) 为单位的。

> 例如，一个 4GHz 的时钟其周期为 0.25 纳秒，或者  250 皮秒。
>
> 从程序员的角度来看，用时钟周期来表示度量标准要比用纳秒或皮秒来表示有帮助的多。

用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行的有多快。

![image-20200615163257219](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163257219.png)

![image-20200615163312419](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163312419.png) 

![image-20200615163324787](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163324787.png)

#### 5.3 程序示例

![image-20200615163616354](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615163616354.png)

#### 5.4 消除循环的低效率

> 需配合 3.6.7 阅读

略。

#### 5.5 减少过程调用

过程调用会带来开销，妨碍大多数形式的程序优化。

![image-20200615165816804](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615165816804.png)

#### 5.6 消除不必要的内存引用

略。

#### 5.7 理解现代处理器（重要）

到目前为止，我们运用而优化都不依赖于目标机器的任何特性。

这些优化只是简单地降低了过程调用的开销，以及消除了一些重大的"妨碍优化的因素"，这些因素会给优化编译器造成困难。

随着试图进一步提高性能，必须考虑利用处理器 `微体系结构`　的优化，也就是处理器用来执行指令的底层系统设计。

要想充分提高性能，需要仔细分析程序，同时代码的生成也要针对目标处理器进行调整。尽管如此，我们还是能够运用一些基本的优化，在很大一类处理器上产生整体的性能提高。

![image-20200615172221908](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615172221908.png)

对这些微处理器运行的原则有一般性的了解就足够能够理解它们如何实现指令级并行。

我们发现两种下界描述了程序的最大性能：

* 延迟界限

  > 当一系列操作必须按照严格顺序执行时，就会遇到 `延迟界限(latencybound)` ，因为在下一条指令开始前，这条指令必须结束。 
  >
  > 当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制的程序性能。

* 吞吐量界限(throughputbound)

  > 吞吐量界限　刻画了处理功能单元的原始计算能力。
  >
  > 这个接线时程序性能的终极限制。

##### 5.7.1 整体操作(原理)

![image-20200615174146579](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174146579.png)

![image-20200615174207244](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174207244.png)

![image-20200615174355365](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615174355365.png)

##### 5.7.2 功能单元的的性能(理解)

重要概念：

* 延迟(latency)

  > 表示完成运算所需要的总时间。

* 发射时间(issue time)

  > 表示两个连续的同类型的运算之间需要的最小时钟周期数。

* 容量(capacity)

  > 表示能够执行该运算的功能单元的数量。

![image-20200615175738747](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615175738747.png)

我们看到，从整数运算到浮点数运算，延迟是增加的。

还可以看到加法和乘法运算的发射时间都为1，意思是说在每个时钟周期，处理器都可以开始一条新的这样的运算。

这种很短的发射时间是通过使用 `流水线` 实现的。

流水线化的功能单元实现为一系列的阶段(stage) ，每个阶段完成一部分的运算。

例如，一个典型的浮点加法器包含三个阶段（所以有三个周期的延迟）:

* 一个阶段处理指数值
* 一个阶段将小数相加
* 一个阶段对结果进行舍入

算数运算可以连续的通过各个阶段，而不用等待一个操作完成后再开始下一个。

只有当要执行的运算是连续的、逻辑上独立的时候，才能利用这种功能。

发射时间为 1 的功能单元被称为 `完全流水线化的(fully pipelined)` :

> 即，每个时钟周期可以开始一个新的运算。
>
> 出现容量大于1的运算是由于有多个功能单元，就如前面所述的参考机一样。

我们还看到，除法器（用于整数和浮点除法，还用来计算浮点平方根）不是完全流水线化的：

>它的发射时间等于它的延迟。
>
>这就意味着在开始一条新运算之前，除法器必须完成整个除法。
>
>我们还看到，对于除法的延迟和发射时间是以范围的形式给出的，因为某些被除数和除数的组合比其他的组合需要更多的步骤。
>
>除法的长延迟和长发射时间使之成为了一个相对开销很大的运算。

表达发射时间的一种更常见的方法是指明这个功能单元的 `最大吞吐量`，定义为发射时间的倒数。

一个完全流水线化的功能单元有最大的吞吐量，每个时钟周期一个运算，而发射时间较大的功能单元的最大吞吐量比较小。

具有多个功能单元可以进一步提高吞吐量。

对一个容量为 C ，发射时间为 I 的操作来说，处理器可能获得的吞吐量为 每时钟周期 C/I 个操作。

> 可能的吞吐量 = 容量(C) / 发射时间(I)

比如，我们的参考机可以每个时钟周期执行两个浮点乘法运算。

我们将看到利用这种能力来提高程序的性能。

![image-20200615235045898](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200615235045898.png)

##### 5.7.5 处理器操作的抽象模型

略。

#### 5.8 循环展开

略。

#### 5.9 提供并行性

在此，程序的性能是受运算单元的延迟限制的。

不过，正如我们表明的，执行加法和乘法的功能单元是完全流水线化的，这意味着它们可以每个时钟周期开始一个新操作，并且有些操作可以被多个功能单元执行。

硬件具有以更高速率执行乘法和加法的潜力，但是代码不能利用这种能力，即使使用循环展开也不能，这是因为我们将累积值放在一个单独的变量 acc 中。

在前面的计算完成之前，都不能计算 acc 的新值。

虽然计算 acc 新值的功能单元能够每个时钟周期开始一个新的操作，但是它只会每  L 个周期开始一条新操作，这里 L 是合并操作的延迟。

现在我们要考察打破这种顺序相关，得到比延迟界限更好性能的方法。

> 临时局部变量 acc ：（累积器 accumulator 的简写）

##### 5.9.1 多个累积变量

对于一个可结合可交换的合并运算来说，比如说整数加法或乘法，**我们可以通过将一组合并原酸分割成两个或更多的部分，并在最后合并结果来提高性能**。

![image-20200617233036135](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233036135.png)

##### 5.9.2 重新结合变换(需回顾)

现在来探讨另一种打破顺序相关从而使性能提高到延迟界限之外的方法。

我们看到过做 k X 1 循环展开的 combine5 没有改变合并向量元素形成和或者乘积中执行的操作。

不过，对代码做很小的改动，我们可以从跟不上改变合并执行的方式，也极大地提高程序的性能。

![image-20200617233315829](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233315829.png)

![image-20200617233337386](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233337386.png)

![image-20200617233400618](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617233400618.png)

总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。

大多数编译器不会尝试对浮点运算做重新结合，因为这些运算不保证是可结合的。

当前的 GCC 版本会对整数运算执行重新结合，但不是总有好的效果。

通常，我们发现循环展开和并行地累积在多个值中，是提高程序性能的更可靠的方法。

#### 5.10 优化合并代码的结果小结

![image-20200617234100798](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617234100798.png)

> CPE 的解释在 5.2 小节

#### 5.11 一些限制因素

我们已经看到在一个程序的数据流图表示中，关键路径指明了执行该程序所需时间的一个基本的下界。

也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于 T ，那么这个程序至少需要 T 个周期才能执行完。

我们还看到功能单元的吞吐量界限也是程序执行时间的一个下界。

也就是说，假设一个程序一共需要 `N` 个某种运算的计算，而微处理器只有 `C` 个能执行这个操作的功能单元，并且这些单元的发射时间为 `I` 。那么这个程序的执行至少需要 `N* I/C` 个周期。

##### 5.11.1 寄存器溢出

循环并行性的好处受汇编代码描述计算的能力限制。

如果我们的并行度 p 超过了可用的寄存器数量，那么编译器会诉诸 `溢出(spilling)` ，将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。

举个例子，将 combine6 的多累积变量模式扩展到 k = 10 和 k = 20 ，其结果比较如下表示：

![image-20200617235008514](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617235008514.png)

![image-20200617235034429](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200617235034429.png)

##### 5.11.2 分支预测和预测错误惩罚

> 与小节 3.6.6 、小节 4.5.7 有关联，必要时返回相应章节看一下。

 通用的优化原则：

* 不要过分关心可预测的分之
* 书写适合用条件传送实现的代码

#### 5.12 理解内存性能

到目前为止，我们写的所有代码，以及运行的所有测试，只访问相对比较少量的内存。

> 例如，我们都是在长度小于1000个元素的响亮上测试这些合并函数，数据量不会超过8000个字节。

所有的现代处理器都包含一个或多个 `高速缓存(cache)` 存储器，以及对这样少量的存储器提供快速的访问。

> 本节会进一步研究涉及加载（从内存到读到存储器）和存储 （寄存器写到内存）操作的程序的性能，只考虑所有的数据都存放在高速缓存中的情况。
>
> 在第6章，我们会更详细的探究高速缓存是如何工作的，它们的性能特性，以及如何编写充分利用高速缓存的代码。

如图 5-11 (图在5.7.1小节)所示，现代处理器有专门的功能单元来执行 `加载` 和 `存储` 操作，这些单元有内部的缓冲区来保存未完成的内存操作请求集合。

> 例如，我们的参考机有两个加载单元，每一个可以保存多达72个未完成的读请求。
>
> 它还有一个存储单元，其存储缓冲区能保存最多42个写请求。每个这样的单元通常可以每个时钟周期开始一个操作。

##### 5.12.1 加载的性能

一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。

##### 5.12.2 存储的性能

在迄今为止所有的示例中，我们只分析了大部分内存引用都是加载操作的函数，也就是从内存位置读到寄存器中，与之对应的是 `存储(store)` 操作，它将一个寄存器值写到内存。

这个操作的性能，尤其是与加载操作的相互关系，包括一些很细微的问题。

与加载操作一样，在大多数情况中，存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。

![image-20200619155006372](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200619155006372.png)

#### 5.13 应用：性能提高技术

虽然只考虑了有限的一组应用程序，但是我们能得出关于如何编写高效代码的很重要的经验教训。

已经得到的一些优化程序性能的基本策略：

* 高级设计

  > 为遇到的问题选择适当的算法和数据结构。
  >
  > 要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。

* 基本编码原则

  > 避免限制优化的因素，这样编译器就能产生高效的代码。

  * 消除连续的函数调用

    > 在可能时，将计算移到循环外。
    >
    > 考虑有选择的妥协程序的模块性以获得更大的效率。

  * 消除不必要的内存引用

    > 引入临时变量来保存中间结果。
    >
    > 只有在最后的值计算出来时，才将结果存放到数组或全局变量中。

  * 低级优化

    > 结构化代码以利用硬件功能。

    * 展开循环，降低开销，并且使得进一步的优化成为可能
    * 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。
    * 用功能性的风格重写条件操作，使得编译采用条件数据传送。

**注意:**

> 要警惕，在为了提高效率重写程序时避免引入错误。
>
> 在引入新变量、改变循环边界和使得代码整体上更复杂时，很容易犯错误。
>
> 一项有用的技术是在优化函数时，用检查代码来测试函数的每个版本，以确保在这个过程没有引入错误。
>
> 检查代码对函数的新版本实施一系列的测试，确保它们产生与原来一样的结果。
>
> 对于高度优化的代码，这组测试情况必须更加广泛，因为要考的情况也更多。
>
> 例如，使用循环展开的检查代码需要测试许多不同的循环界限，保证它能够u处理最终单步迭代所需要的所有不同的可能的数字。

#### 5.14 确认和消除性能瓶颈

到这里，我们只考虑了优化晓得程序，在这样的小程序中有一些很明显限制性能的地方，因此应该是集中注意对它们进行优化。

在处理大程序时，连知道应该优化什么地方都是很难的。

##### 5.14.1 程序剖析

`程序剖析(profiling)` 运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。

这对于确认程序中我们需要集中注意力优化的部分是很有用的。剖析的一个有利之处在于可以在现实的 `基准数据(benchmark data)` 上运行实际程序的同时，进行剖析。

Unix系统提供了一个剖析程序 GPROF 。

这个程序产生两种形式的信息：

* 首先，它确定程序中每个函数花费了多少 CPU 时间。
* 其次，它计算每个函数被调用的次数，以执行调用函数来分类。

这两种形式的信息的都非常有用。

> 这些计时给出了不同函数在确定整体运行时间中的相对重要性。
>
> 调用信息使得我们能理解程序的动态行为。

![image-20200619162120627](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200619162120627.png)

![image-20200619162423914](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200619162423914.png)

![image-20200619162711278](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200619162711278.png)

根据这个调用信息，我们通常可以推断出关于程序行为的有用信息。

例如，函数 `find_ele_rec` 是一个递归过程，它扫描一个 `哈希桶(hash bucket)` 的链表，查找一个特殊的字符串。

对于这个函数，比较递归调用的数量和底层调用的数量，提供了关于遍历这些链表的长度的统计的信息。

这里递归与顶层调用的比率是 164.4 ，我们可以推断出程序每次平均大约扫描 164 个元素。

**GPROF有些属性值得注意:**

* 计时不是很准确

  > 它的计时基于一个简单的 `间隔计数(interval counting)` 机制，编译过的程序为每个函数维护一个计数器，记录花费在执行函数上的时间。
  > 操作系统使得每个规则的间隔时间间隔 δ ，程序被中断一次。δ 的典型值的范围为 1.0~10.0 毫秒。
  > 当中断发生时，它会确定程序正在执行什么函数，并将该函数的计数器值加δ。
  > 当然，也可能这个函数只是刚开始执行，而很快就会完成，却赋给它从上次中断以来整个的执行花费。
  > 在两次中断之间也可能运行其他某个程序，却因此根本没有计算花费。
  >
  > 对于运行时间较长的程序，这种机制工作的相当好。
  > 从统计上说，应该根据花费在执行函数上的相对时间来计算每个函数的花费。
  > 不过，对于那些运行时间少于1秒的程序来说，得到的统计数字只能看成是粗略的估计值。

* 假设没有执行内联替换，则调用信息相当可靠。

  > 编译过的程序为每对调用者和被调用者维护了一个计数器。
  >
  > 每次调用一个过程时，就会对适当的计时器加 1。

* 默认情况下，不会显示对库函数的计时。

  > 相反，库函数的时间都被计算到调用它们的函数的时间中。

##### 5.14.2 使用剖析程序来指导优化

略（实际需要操作时，再来看）。

#### 5.15 小结

虽然关于代码优化的大多数论述都描述了编译器是如何能生成高效代码的，但是应用程序员有很多方法来协助编译器完成这项任务。

没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此，程序设计的这些方面仍然应该是程序员主要关心的。

我们还看到妨碍优化的因素，例如**内存别名使用和过程调用，严重限制了编译器执行大量优化的能力**。 

同样，程序员必须对消除这些妨碍优化的因素负主要的责任。这些应该被看做好的变成习惯的一部分，因为它们可以用来消除不必要的工作。

基本级别之外调整性能需要一些对处理器微体系结构的理解，描述处理器用来实现它的指令集体系结构的底层机制。
对于乱序处理器的情况，只需要知道一些关于 `操作`、`容量`、`延迟` 和 `功能单元发射时间` 的信息，就能够基本的预测程序的性能了。

我们研究了一系列技术，包括循环展开、创建多个累积变量和重新结合，它们可以利用现代处理器提供的指令级并行。
随着对优化的深入，研究产生的汇编代码以及试着理解机器如何执行计算变得重要起来。
确认由程序中的数据相关决定的关键路径，尤其是循环的不同迭代之间的数据相关，会收获良多。

我们还可以根据必须要计算的操作数量以及执行这些操作的功能单元的数量和发射时间，计算一个计算的吞吐量界限。

包含条件分支或与内存系统复杂交互的程序，比我们最开始考虑的简单循环程序，更难以分析和优化。基本策略是使分支更容易预测，或者使它们很容易用条件数据传送来实现。
我们还必须注意存储和加载操作。将数值保存在局部变量中，使得它们可以存放在寄存器中，这会很有帮助。

当处理大型程序时，将注意力集中在最耗时的部分变得很重要。
代码剖析程序和相关的工具能帮助我们系统地评价和改进程序性能。我们描述了 GPROF，一个标准的 Unix 剖析狗工具。还有更加复杂完善的剖析程序可用，例如Intel的 VTUNE 程序开发系统，还有 Linux 系统基本上都有的 VALGRIND。这些工具可以在过程级分解执行时间，估计程序每个 `基本块(basic block)` 的性能。（基本块是内部没有控制转移的指令序列，因此基本块总是整个被执行的。）

### 第6章 存储器层次结构

到目前为止，在对系统的研究中我们依赖于一个简单的计算机系统模型，CPU执行指令，而存储器系统为CPU存放指令和数据。

在简单模型中，存储器系统是一个线性的数组，而CPU能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型，但是它没有反应现代系统实际工作的方式。

实际上，`存储器系统(memeory system)` 是一个具有不同容量、成本和访问时间的存储器设备的层次结构：

* CPU寄存器
  * CPU 寄存器保存着最常用的数据。
* 高速缓存器(cache memory)
  * 靠近 CPU 的小的、快速的的 `高速缓存器(cache memory)` 作为一部分存储在相对慢速的 `主存储器(main memory)` 中数据和指令的缓冲区域。
* 主缓存存储
  * 主缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。

存储器层次结构是可行的，这是因为与下一个更低层次的存储设备相比来说，**一个编写良好的程序倾向于更频繁地访问某一个层次上的存储设备**。

所以，下一层的存储设备可以更慢速一点，也因此可以更大，每个比特位更便宜。整体效果是一个大的存储器池，其成本与层次结构底层最便宜的存储设备相当，但是却以接近于层次结构顶部存储设备的高速率向程序提供数据。

作为一个程序员，需要理解存储器层次结构，因为它对应用程序的性能有巨大的影响。

> 如何你的程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在 0 个周期内就能访问呢到它们。
>
> 如果存储在告诉缓存中，需要4~75个周期。
>
> 如果存储在主存种，需要上百个周期。
>
> 而如果存储在磁盘上，需要大约几千万个周期！

**缓存性能的差异如此之大！一个体验良好的程序，必须注意缓存结构的处理**

这里就是计算机系统中一个基本而持久的思想：

> 如果理解系统是如何将数据在存储器层次中上上下下移动的，那么就可以编写自己的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。

这个思想围绕着计算机程序的一个称为  `局部性(locality)` 的基本属性。

> 具有良好局部性的程序倾向于一次又一次的访问相同的数据项集合，或是倾向于访问邻近的数据项集合。
> 具有良好局部性的程序比局部性差的程序更多的倾向于从存储器层级结构中较高层次处访问数据项，因此运行的更快。
>
> 例如  Corei7 系统，不同的矩阵乘法核心程序执行相同数量的算数操作，但是有不同程度的局部性，它们的运行时间可以相差40倍！

在本章中，会看到以下基本的存储技术：

* SRAM 寄存器
* DRAM 寄存器
* ROM 存储器
* 转速机械硬盘和固态硬盘

并描述它们是如何被组织成层次结构的。

`高速缓存存储器： 介于 CPU 和 主存之间的缓存区域。`

特别地，我们将注意力集中在高速缓存存储器上，它是作为 CPU 和 主存 之间的缓存区域，因为它们对应用程序性能的影响最大。

#### 6.1 存储技术

##### 6.1.1 随机访问存储器(概念普及)

`随机访问存储器(Random-Access Memory, RAM)` 分为两类：静态的 和 动态的。

**静态RAM(SRAM)** 比 **动态RAM(DRAM)** 更快。也贵的多。

* 静态RAM(SRAM)

  > SRAM 用来作为告诉缓存存储器，既可以在CPU芯片上，也可以在片下。

* 动态RAM(DRAM)
  
  > DRAM 用来作为主存以及图形系统的帧缓冲区。
  >

典型地，一个桌面系统的 SRAM 不会超过几兆字节，但是 DRAM 却有几百或几千兆字节。

类型汇总：

* 静态RAM
* 动态RAM
* 传统的DRAM
* 内存模块
* 增强的DRAM
* 非易失性存储器
* 访问主存

![image-20200620123218248](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620123218248.png)

![image-20200620123839595](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620123839595.png)





![image-20200620124122993](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124122993.png)



![image-20200620124246629](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124246629.png)



![image-20200620124311440](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124311440.png)

![image-20200620124504668](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124504668.png)

![image-20200620124517890](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124517890.png)

![image-20200620124546793](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620124546793.png)

##### 6.1.2 磁盘存储(概念普及·需回顾)

磁盘是广为应用的保存大量数据的存储设备，存储设局的数量级可以达到几百到几千兆字节，而基于 RAM 的存储器只能有几百兆或几千兆字节。
不过，从磁盘上读信息的时间为毫秒级，比从 DRAM 读慢了 10 万倍，比从 SRAM 读慢了 100万倍。

*略（待回顾）*

##### 6.1.3 固态硬盘

![image-20200620125059811](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620125059811.png)

*略（待回顾）*

##### 6.1.4 存储技术趋势

`不同的存储技术有不同的价格和性能折中`。 

SRAM 比 DRAM 快一点，而 DRAM 比 磁盘要快很多。

另一方面，快速存储总是比慢速存储要贵。

SRAM 每字节的造价比 DRAM 高，DRAM 的造价又比 磁盘 高的多。

SSD 位于 DRAM 和 机械转速磁盘之间。

 *略（详细内容待回顾）*

#### 6.2 局部性

一个编写良好的计算机程序常常具有良好的 `局部性(locality)` 。

也就是，它们倾向于引用 邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。

这种倾向性被称为 `局部性原理(principle of locality)` ，是一个持久的概念，对硬件和软件系统的设计和性能都有极大地影响。

局部性通常有两种不同的形式：`时间局部性(temporal locality)` 和 `空间局部性(spatical locality)` 。

在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。

在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。

程序员应该理解局部性原理，因为一般而言，`有良好局部性的程序比局部性差的程序运行的更快`。

现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。

在硬件层，局部性原理允许计算机设计者通过引入称为 `高速缓存存储器` 的小而快速的存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。

在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的 `高速缓存`。

类似地，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。

##### 6.2.1 对程序引用的局部性

略。

##### 6.2.2 取指令的局部性

> 图 6-17 在 6.2.1 小节。

因为程序指令是存放在内存中的，CPU 必须取出(读出) 这些指令，所以我们也能够评价一个程序关于取指令的局部性。

> 例如，图 6-17 中 for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。
>
> 因为循环体会被执行多次，所以它也有很好地时间局部性。
>
> 代码区别于程序数据的一个重要属性时在运行时，它是不能被修改的。
>
> 当程序正在执行时，CPU 只从内存中读出它的指令。
>
> CPU 很少会重写或修改这些指令。

##### 6.2.3 局部性小结

在这一节中，我们介绍了局部性的基本思想，还给出了量化评价程序中局部性的一些简单原则：

* 重复引用相同变量的程序有良好的时间局部性

* 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好。

  > 具有步长为 l 的引用模式的程序有良好的空间局部性。
  > 在内存中以大步长跳来跳去的程序空间局部性会很差。

* 对于取指令来说，循环有良好的时间和空间局部性。

  > 循环体越小，循环迭代次数越多，局部性越好。

在本章后面，我们学习了高速缓存存储器以及它们是如何工作的之后，我们会介绍如何用 `高速缓存命中率` 和 `不命中率` 来 **量化局部性** 的概念。

我们还会弄明白为什么有良好局部性的程序通常比局部性差的程序运行的更快。

尽管如此，了解如何看一眼源码就能获得对程序中局部性的更高层次的认识，是程序员要掌握的一项有用的而且重要的技能。

#### 6.3 存储器层次结构

在 6.1 节 和 6.2 节描述了 存储技术 和 计算机软件 的一些基本的和持久的属性：

* 存储技术

  > 不同存储技术的访问时间差异很大。
  >
  > 速度较快的存储技术每字节的成本要比速度较慢的技术高，而且容量较小。
  >
  > CPU 和 主存之间的速度差距在增大。

* 计算机软件

  > 一个编写良好的程序倾向于展示出良好的局部性。

计算机中一个喜人的巧合是：硬件和软件的这些基本属性互相补充得很完美。

它们这种相互补充的性质使人想到一种组织存储器系统的方法，称为 `存储器层次结构(memory hierarchy)` 。所有的现代计算机系统中都使用了这种方法。

下面 图 6-21 展示了一个典型的存储器层次结构。

![image-20200620132325738](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620132325738.png)

一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在更高层（L0），是少量最快速的 CPU 寄存器，CPU 可以在一个时钟周期内访问它们。

接下来是一个或多个小型到中型的基于 SRAM 的告诉缓存存储器，可以在几个 CPU 时钟周期内访问它们。

然后是一个大的基于 DRAM 的主存，可以在几十到几百个时钟周期内访问它们。

接下来是慢速但是容量很大的本地磁盘。

最后，有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们。

> 例如，像 安德鲁文件系统(Andrew File System，AFS) 或 网络文件系统(Network File System, NFS) 这样的分布式文件系统，允许程序访问存储在远程的网络服务器上的文件。
>
> 类似地，万维网允许程序访问存储在世界上任何地方的 Web 服务器上的远程文件。

##### 6.3.1 存储器层次结构中的缓存

一般而言，`高速缓存(cache，读作"cash")` 是一个小而快速的存储设备，它作为 存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为  `缓存(caching，读作cashing)`。

存储器层次结构的中心思想史，对于每个 k ，位于 k 层的更快的更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。

换句话说从，层次结构中的每一层都换成来自较低一层的数据对象。（这些概念前三章提到过）

> 例如，
>
> 本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，
>
> 主存作为本地磁盘上数据的缓存，依次类推，知道最小的缓存 —— CPU 寄存器组。

 ![](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620153352912.png)

![image-20200620153626077](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620153626077.png)

* 缓存命中

  当程序需要 第 `k+1` 层的某个数据对象 `d` 时，它首先在当前存储在第 k 层的一个块中查找 d 。

  如果 d 刚好缓存在 第 k 层中，那么就是我们所说的 `缓存命中(cache hit)` 。

  该程序直接从第 k 层读取 d ，根据存储器层次机构的性质，这要比从 第 k+1 层读取 d 更快。

  例如，一个有良好时间局部性的程序可以从块 14 中读出一个数据对象，得到一个对 第 k 层的缓存命中。

* 缓存不命中

  另一方面，如果 第 k 层 没有缓存数据对象 d , 那么就是我们所说的 `缓存不命中(cache miss)` 。当发生缓存不命中时，第 k 层的缓存从第 k+1 层缓存中取出包含 d 的那个块，如果 第 k 层的缓存已经满了，可能就会覆盖现存的一个块。

  ![image-20200620155021196](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620155021196.png)

* 缓存不命中的种类

  区分不同种类的缓存不命中有时候是很有帮助的。

  如果第 k 层的缓存是空的，那么对任何数据对象的访问都会不命中。

  一个空的缓存有时被称为 `冷缓存(clod cache)`，此类不命中称为 `强制性不命中(compulsory miss)` 或 `冷不命中(cold miss)` 。

  冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得  `缓存暖身(warmed up)` 之后的稳定状态中出现。

  ![image-20200620155403819](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620155403819.png)

![image-20200620155436094](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620155436094.png)

这种先执行的放置策略会引起一种不命中，称为 `冲突不命中(conflict miss)`。

![image-20200620155526485](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620155526485.png)

当工作集的大小超过缓存的大小时，缓存会经历 `容量不命中(capacity miss)`。

> 换句话说，容量不命中就是缓存太小了，不能处理这个工作集。 

* 缓存管理

![image-20200620155732171](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620155732171.png)

##### 6.3.2 存储器层次结构概念小结

概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：

* 利用时间局部性

  > 由于时间局部性，同一数据对象可能会被多次使用。
  >
  > 一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。
  >
  > 因为缓存比第一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。

* 利用空间局部性

  > 块通常包含有多个数据对象。
  >
  > 由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。

![image-20200620160652740](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620160652740.png)

![image-20200620160658809](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620160658809.png)



#### 6.4 高速缓存存储器

早期计算机系统的存储器层次结构只有三层：

* CPU 寄存器
* DRAM 主存储器
* 磁盘

不过，由于 CPU 和 主存 之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件 和 主存之间插入了一个小的 SRAM `高速缓存存储器`，称为 `L1高速缓存(一级缓存)` ，如 下面 图 6-24 所示。  

`L1高速缓存`  的访问速度几乎和寄存器一样快，典型地是大约 4 个时钟周期。

![image-20200620161025391](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620161025391.png)

随着 CPU 和 主存 之间的性能差距不断增大，系统设计者在 L1 高速缓存 和 主存 之间又插入了一个更大的高速缓存，称为 `L2 高速缓存`，可以在大约 10个 时钟周期 内访问到它。

有些现代系统还包括有一个更大的 高速缓存，称为 `L3 高速缓存` ，在存储器层次结构中，它位于 L2 高速缓存 和 主存 之间，可以在大约 50 个时钟周期 内访问到它。

虽然安排上有相当多的变化，但是通用原则是一样的。

##### 6.4.1 通用的高速缓缓存存储器组织结构（重要）

记忆理解（细节略，看书内）

##### 6.4.2 直接映射高速缓存

高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：

* 1) 组选择
* 2) 行匹配
* 3) 字抽取

实际使用中涉及以下使用方法：

* 直接映射高速缓存命中的组选择
* 直接映射高速缓存中的行匹配
* 直接映射高速缓存中的字选择
* 直接映射高速缓存中不命中时的行替换
* 综合：运行中的直接映射高速缓存（书中有更具体步骤划分描述）

* 直接映射高速缓存中的冲突不命中

##### 6.4.3 组相联高速缓存

直接映射高速缓存中冲突不命中造成的问题源于每个组只有一行（或者，按照我们的术语来描述就是 E = 1）这个限制。

`组相联高速缓存(set associative cache)` 放松了这条限制，所以每个组都保存有多于一个的高速缓存行。

一个 `1<E<C/B` 的告诉缓存通常称为 `E 路组相连高速缓存`。

![image-20200620162348810](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620162348810.png)

**1. 组相连高速缓存中的组选择**

它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。

> 图 6-33 总结了这个原理

**2. 组相联高速缓存中的行匹配和字选择**

组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因为它必须检查多个行的标记位和有效位，以确定所请求的字是否在集合中。

传统的内存是一个值的数组，以地址作为输入，并返回存储在那个地址的值。

另一方面，`相联存储器` 是一个 (key,value) 对 的数组，以 key 为输入，返回与输入 key 相匹配的 (key,value) 对 中的value值。

因此，我们可以把 `组相联高速缓存` 中的每个 `组` 都看成一个 `小的相联存储器`，key 是标记和有效位，而 value 就是块的内容。

![image-20200620162905740](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620162905740.png)

![image-20200620162952988](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620162952988.png)

**3. 组相联高速缓存中不命中时的行替换**

如果 CPU 请求的字不再组的任何一行中，那么就是缓存不命中，高速缓存必须从内存中取出包含这个字的块。

不过，一旦高速缓存取出了这个块，该替换哪个行呢？
当然，如果有一个空行，那它就是个很好的候选。
但是，如果该组中没有空行，那么我们必须从中选择一个非空的行，希望 CPU 不会很快引用这个被替换的行。

![image-20200620163329215](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620163329215.png)

##### 6.4.4 全相联高速缓存

`全相联高速缓存(fully associative cache)` 是由一个包含所有高速缓存行的组( 即 E=C/B ) 组成的。

图 6-35 给出了基本结构：

![image-20200620163453107](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620163453107.png)

**1. 全相联高速缓存中的组选择**

![image-20200620163652502](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620163652502.png)

**2. 全相联高速缓存中的航匹配和字选择**

![image-20200620163741497](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620163741497.png)

因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相联高速缓存很困难，而且很昂贵。

因此，全相联高速缓存只适合做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器(TLB)，它的缓存页表项（见9.6.2节)。

##### 6.4.5 有关写的问题

正如我们看到的，高速缓存关于读的操作非常简单。首先，在高速缓存中查找所需字 w 的副本。如果命中，立即返回字 w 给 CPU 。如果不命中，从存储器层次结构中较低层中取出包含 字 w 的块。将这个块存储到某个高速缓存行中（可能会驱逐一个有效的行），然后返回字 w。

写的情况就要复杂一些了。假设我们要写一个已经缓存了的 字w(写命中，write hit)。
在高速缓存更新了它的 w 的副本之后，怎么更新 w 在层次结构中紧接着第一层中的副本呢？

* 直写法(write-through)

  > 最简单的方法，称为直写(write-through)，就是直接将 w 的高速缓冲块写回到紧接着的第一层中。
  > 虽然简单 ,但是，直写的缺点是每次写都会引起总线流量。
  
* 写回法(write-back)
  
  > 另一种方法，称为 `写回(write-back)` ，尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。
  > 由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位(dirty bit)，表明这个高速缓冲块是否被修改过。

另一个问题是如何处理写不命中：

* 写分配法(write-allocate)

  > 加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。
  >
  > 写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。

* 非写分配法(not-write-allocate)

  > 避开高速缓存，直接把这个字写到低一层中。

`直写` 高速缓存通常是 `非写分配` 的。
`写回` 高速缓存通常是 `写分配` 的。

  ![image-20200620165412454](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620165412454.png)

##### 6.4.6 一个真实的高速缓存层次结构剖析

到目前为止，我们一直假设高速缓存只保存程序数据。不过，实际上，高速缓存既保持数据，也保存指令。

根据高速缓存保存内容的不同可以分类为：

* i-cache(指令高速缓存)

  > 只保存指令的高速缓存称为 `i-cache`。

* d-cache(程序数据高速缓存)

  > 只保存程序数据的告诉缓存称为 `d-cache`。

这样做有很多原因，有两个独立的高速缓存，处理器能够同时读 `一个指令字` 和 `一个数据字`。

`i-cache` 通常是只读的，因此比较简单。

通常会针对不同的访问模式来优化这两个高速缓存，它们可以有不同的块大小，`相联度` 和 `容量` 。

使用不同的高速缓存也确保了 `数据访问` 不会与 `指令访问` 形成 `冲突不命中` ，反过来也是一样，代价就是可能会引起容量不命中增加。

![image-20200620170215092](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620170215092.png)

![image-20200620170229312](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620170229312.png)

##### 6.4.7 高速缓存参数的性能影响

有许多指标来衡量高速缓存的性能：

* 不命中率(miss rate)

  > 在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。
  >
  > 它是这样计算的：不命中数量 / 引用数量。

* 命中率(hit rate)

  > 命中内存引用比率。
  >
  > 它的计算 :  1 - 不命中率。

* 命中时间(hit time) 

  > 从高速缓存传送一个字到 CPU 所需的时间，包括组选择、行确认和字选择的时间。
  >
  > 对于 L1 高速缓存来说，命中时间的数量级是几个时钟周期。

* 不命中处罚(miss penalty)

  > 由于不命中所需要的额外时间。
  >
  > L1 不命中需要从 L2 得到服务的处罚，通常是数10个周期；
  >
  > 从L3 得到服务的处罚，50个周期；
  >
  > 从主存得到服务的处罚，200个周期。

优化高速缓存的成本和性能的折中是一项很精细的工作，它需要在现实的基准程序代码上进行大量的模拟。因此超出了我们讨论的范围，不过，还是可以认识一些定性的折中考量：

* **1. 高速缓存大小的影响**

  > 一方面，较大的高速缓存可能会提高命中率。
  >
  > 另一方面，使大存储器运行得更快总是要难一些。
  >
  > 结果，较大的高速缓存可能会增加命中时间。
  >
  > 这解释了，为什么 L1高速缓存 比 L2高速缓存 小，
  > 以及为什么 L2高速缓存 比 L3高速缓存小。

* 块大小的影响

  > 大的块有利有弊。
  >
  > 一方面，较大的块能利用程序中可能存在的空间局部性，帮助提高命中率。
  >
  > 不过，对于给定的高速缓存大小，块越大就意味着高速缓存行数越少，这会损害时间局部性比空间局部性更好的程序的命中率。
  >
  > 较大的块对不命中处罚也有负面影响，因为块越大，传送时间就越长。
  >
  > 现代系统(如Core i7) 会折中使高速缓存块包含 64 个字节。

* 相联度的影响

  ![image-20200620171549730](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620171549730.png)

* 写策略的影响

  直写高速缓存比较容易实现，而且能使用独立于高速缓存的 `写缓冲区(write buffer)`，用来更新内存。

  此外，读不命中开销没这么大，因为它们不会触发内存写。

  另一方面，写回高速缓存引起的传送比较少，它允许更多的到内存的带宽用于执行 DMA 的 I/O 设备。

  此外，越往层次结构下面走，传送时间增加，减少传送的数量就变得更加重要。

  一般而言，高速缓存越往下层，月可能使用写回而不是直写。

  ![image-20200620172033283](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620172033283.png)

#### 6.5 编写高速缓存友好的代码

在 6.2 节中，我们介绍了局部性的思想，而且定性的谈了一下什么会具有良好的局部性。

明白了高速缓存器是如何工作的，我么你就能更加准确一些了。局部性比较好的程序更容易有较低的不命中率，而且不命中率较低的程序往往比不命中率较高的程序运行的更快。

因此，从具有良好局部性的意义上来说，好的程序员总是应该试着去编写 `高速缓存友好(cache friendly)` 的代码。

确保代码高速缓存友好的基本方法：

* 让最常见的情况运行的快

  > 程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间都花在了少量循环上。
  >
  > 所以，要把注意力集中在核心函数里的循环上，而忽略其他部分。

* 尽量减小每个循环内部的缓存不命中数量。

  > 在其他条件（例如加载和存储的总次数）相同的情况下，不命中率较低的循环运行的更快。

![image-20200620172752576](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620172752576.png)

两个关于编写高速缓存友好的代码的重要问题：

* 对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文件中（时间局部性）
* 步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是讲数据存储为连续的块（空间局部性）。

> 在 Java 的 JVM 层面，空间局部性 和 时间局部性 应该也是适用的，只不过需要转换为 JVM 的处理策略。原理是相通的，只是实现上可能略有差异。

![image-20200620173111744](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620173111744.png)



#### 6.6 综合：高速缓存对程序性能的影响

##### 6.6.4 存储器山

一个程序从存储系统中读数据的速率称为 `读吞吐量(read throughout)` ，或者有时被称为 `读带宽(read bandwidth)`。

如果一个程序在 `s` 秒的时间段内读 `n` 个字节，那么这段时间内的读吞吐量就等于 `n/s` ，通常以兆字节每秒(MB/s) 为单位。

*详细内容 略——参见书中内容*

![image-20200620173530424](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620173530424.png)

##### 6.6.3 在程序中利用局部性

![image-20200620173633150](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620173633150.png)

理解存储器层次结构本质的程序员能够利用这些知识编写出更有效的程序，无论具体的存储系统结构是怎样的。

推荐的方法：

* 将注意力集中在内循环上，大部分计算和内存访问都发生在这里
* 通过按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得程序中的空间局部性最大
* 一旦从存储器中读入了一个数据对象，就尽可能多的使用它，从而使得程序中的时间局部性最大。

#### 6.7 小结

![image-20200620173857293](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620173857293.png)

## 第二部分：在系统上运行程序

继续我们对计算机系统的探索，进一步来看看构建和运行应用程序的系统软件。

链接器把程序的各个部分联合成一个文件，处理器可以将这个文件加载到内存，并且执行它。

现代操作系统与硬件合作，为每个程序提供一种幻象，好像这个程序是在独占地使用处理器和内存，而实际上，在任何时刻，系统上都有多个程序在运行。

![image-20200620174415986](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620174415986.png)



### 第7章：链接

`链接(linking)` 是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被 `加载(复制)` 到内存并执行。

链接可以执行于 `编译时(compile time)` ，也就是在源代码被翻译成机器代码时；
也可以执行于 `加载时(load time)` ，也就是在程序被 `加载器(loader)` 加载到内存并执行时；
甚至执行于 `运行时(run time)` ，也就是由应用程序来执行。

在早期的计算机系统中，链接时手动执行的。在现代系统中，链接是由叫做 `链接器(linker)` 的程序自动执行的。

 链接器在软件开发中扮演着一个关键的角色，因为它们是的 `分离编译(spearate com-pilation)` 成为可能。
我们不用将一个大型的应用程序组织委员一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。

当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。

链接通常是由链接器来默默地处理的，但是为什么要学习链接的知识，有以下理由：

* 理解链接器将帮助构造大型程序

  > 构造大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。
  >
  > 除非特别理解链接器是如何解析引用、什么是库以及链接器是如何使用库来解析引用的，否则这类错误将令人感到迷惑和挫败。

* 理解链接器将帮助避免一些危险的编程错误

  > Linux 链接器解析符号引用时所做的决定可以不动声色的影响程序的正确性。
  >
  > 在默认情况下，错误地定义多个全局变量的程序将通过链接器，而不产生任何警告信息。
  >
  > 由此得到的程序会产生令人迷惑的运行时行为，而且非常难以调试。我们将了解这是如何发生的，以及该如何避免它。

* 理解链接将帮助理解语言的作用域规则是如何实现的

  > 例如，
  >
  > 全局和局部变量之间的区别是什么？
  >
  > 当定义一个具有 static 属性的变量或者函数时，实际到低意味着什么？

* 理解链接将帮助理解其他重要的系统概念

  > 链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，
  >
  > 比如，加载和运行程序、虚拟内存、分页、内存映射。

* 理解链接将能够利用共享库

  > 多年依赖，链接都被认为是相当简单和无趣的。
  >
  > 然而，随着共享库和动态链接在现代操作系统中重要性的日益加强，链接成为一个复杂的过程，为掌握它的程序员提供了强大的能力。
  >
  > 比如，许多软件产品在运行时使用共享库来升级压缩包装的(shrink-wrapped) 二进制程序。
  >
  > 还有，大多数 Web 服务器都依赖于共享库的动态链接来提供动态内容。

这一章提供了关于链接各个方面的全面太欧尼，从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。

我们将使用实际示例来描述基本的机制，而且指出链接问题在那些情况中会影响程序的性能和正确性。

为了使描述具体和便于理解，我们讨论是基于这样的环境：

> 一个运行Linux 的 x86-64 系统，使用标准的 ELF-64(此后称为 ELF) 目标文件格式。

不过，无论是什么样的操作系统、ISA或者目标文件格式，**基本的链接概念是通用的**，认识到这一点是很重要的。

**不同系统上，关于链接的细节可能不尽相同，但是概念是相同的**。

#### 7.1 编译器驱动程序

![image-20200620182751906](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620182751906.png)

大多数编译系统提供 `编译驱动程序(compiler driver)` ，它代表用户在需要时调用 `语言预处理器` 、`编译器`、`汇编器` 和 `链接器`。

> 在 1.2 章节，有讲到过编译器流程。

![image-20200620183225376](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620183225376.png)

![image-20200620183235378](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620183235378.png)

#### 7.2 静态链接

像 Linux LD 程序这样的 `静态链接器(static linker)` 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。 

输入的 `可重定位目标文件` 由 `各种不同的代码` 和 `数据节(section)`  组成，每一节都是一个连续的字节序列。

`指令` 在一节中，`初始化了的全局变量` 在另一节中，`而未初始化的变量` 又在另外一节中。

为了构造可执行文件，链接器必须完成两个主要任务：

* 符号解析(sysmbol resolution) 

  > 目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（ 即C语言中任何以 static 属性声明的变量 ）。
  >
  > 符号解析的目的是将每个 `符号引用` 正好和一个 `符号定义` 关联起来。

* 重定位(relocation)

  > `编译器` 和 `汇编器` 生成 从地址0 开始的 `代码` 和 `数据节`。
  >
  > `链接器` 通过把每个 `符号定义` 与 一个 `内存位置` 关联起来，从而 `重定位` 这些节。
  > 然后修改所有对这些符号的引用，使得它们指向这个内存位置。
  >
  > 链接器使用汇编器产生的 `重定位条目(relocation entry)` 的详细指令，**不加甄别**地执行这样的重定位。

接下来的章节将更加详细的描述这些任务，在阅读的时候，要记住关于链接器的一些基本事实：

**目标文件纯粹是字节块的集合**

> 在这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导 `链接器` 和 `加载器` 的数据结构。
>
> 链接器将这些块： 
>
> * 连接起来
> * 确定被连接块的运行时位置
> * 并且修改代码和数据块中的各种位置。

链接器对目标及其了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。

#### 7.3 目标文件

目标文件有三种形式：

* 可重定位目标文件

  > 包含二进制代码和数据，
  >
  > 其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

* 可执行目标文件

  > 包含二进制代码和数据，
  >
  > 其形式可以被直接复制到内存并执行。

* 共享目标文件

  > 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

`编译器` 和 `汇编器` 生成 `可重定位目标文件(包括共享目标文件)`。

`链接器` 生成 `可执行目标文件`。

从技术上来说：
一个 `目标模块(object module)` 就是一个 `字节序列` ，
而一个 `目标文件(object file)` 就是一个 `以文件形式存放在磁盘中的目标模块`。

不过，我们会互换地使用这些术语。

目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。

> 从贝尔实验室诞生的第一个 Unix 系统使用的是 a.out 格式（直到今天，可执行文件仍然称为 a.out 文件）。
>
> Windows 使用可移植可执行（Portable Executable, PE）格式。
>
> MacOS-X 使用 Mach-O 格式。

现代 x86-64 Linux 和 Unix 系统使用可执行链接格式（Executable and Linkable Format, ELF）。

**尽管我们的讨论的`目标文件格式`在 ELF 上，但是不管是哪种格式，基本的概念是相似的**。

#### 7.4 可重定位目标文件

下面 图 7-3 展示了一个典型的 ELF 可重定位目标文件的格式。

![image-20200620190126909](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620190126909.png)

`ELF 头(ELF header)` 以一个 16字节 的序列开始，这个序列描述了生成该文件的系统的 `字的大小` 和 `字节顺序` 。

ELF 头剩下的部分包含帮助 `链接器语法分析` 和 `解释目标文件` 的信息。

其中包括 ：

* ELF 头的大小

* 目标文件的类型（如可重定位、可执行或者共享的）`

* 机器类型（如 x86-64）

* `节头部表(section header table)` 的文件偏移

* 节头部表中条目的大小和数量

不同节的 `位置` 和 `大小` 是由 `头部表` 描述的，

其中 `目标文件` 中 `每个节` 都有一个 `固定大小的条目(entry)`。

夹在 `ELF 头` 和 `节头部表` 之间的都是 `节`。

一个典型的 ELF 可重定位目标文件包含下面几个节：

* .text 

  > 已编译程序的机器代码

* .rodata

  > 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。

* .data

  > 已初始化的全局和静态C变量。
  >
  > 局部 C 变量在运行时被保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中。

* .bss

  > 未初始化的全局和静态C变量，以及所有被初始化为 0 的全局或静态变量。
  >
  > 在目标文件中这个节不占据实际的空间，它仅仅只是一个占位符。
  >
  > 目标文件格式区分已初始化和未初始化变量就是为了空间效率：
  >
  > * 在目标文件中，未初始化变量不需要占据任何实际的磁盘空间
  > * 运行时，在内存中分配这些变量，初始值为0

* .symtab

  > 一个符号表，它存放 `在程序中定义` 和 `引用的函数` 和 `全局变量` 的信息。
  >
  > 一些程序员错误的认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。
  >
  > 实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。
  >
  > 然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。

* .rel.text 

  > 一个 .text 节中位置的列表，
  >
  > **当 `链接器` 把这个 `目标文件` 和 `其他文件` 组合时，需要修改这些位置**。
  >
  > 一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。
  >
  > 另一方面，调用本地函数的指令则不需要修改。
  >
  > 注意：可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
  >
  > 关于三种目标文件的区别，在 7.3 小节。

* .rel.data

  > 被模块引用或定义的所有全局变量的重定位信息。
  >
  > 一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

* .debug

  > 一个调试符号表，其条目是：
  >
  > * 程序中定义的局部变量和类型定义
  > * 程序中定义和引用的全局变量
  > * 原始的C源文件
  >
  > 只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

* .line

  > 原始 C 源程序中的行号 和 .text 节中机器指令之间的映射。
  >
  > 只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

* .strtab

  > 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。
  >
  > 字符串表就是以 null 结尾的字符串的序列。

![image-20200620194208580](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620194208580.png)

#### 7.5 符号和符号表

每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。

在链接器的上下文中，有三种不同的符号：

* `由模块 m 定义` 并能 `被其他模块引用` 的 全局符号。

  > 全局链接器符号对应于 `非静态的C函数` 和 `全局变量`。

* `由其他模块定义` 并 `被模块 m 引用` 的 全局符号。

  > 这些符号称为 `外部符号` ，对应于在 `其他模块中定义` 的 `非静态C函数` 和 `全局变量`。

* `只被模块 m 定义和引用` 的 `局部符号` 。

  > 它们对应于 `带static属性的C函数` 和 `全局变量`。

认识到 本地链接器符号 和 本地程序变量 不同 是很重要的。

`.symtab` 中的 符号表 **不包含** 对应于 `本地非静态程序变量` 的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。

有意思的是，定义为带有 C static 属性的 `本地过程变量` 是 `不在栈中管理的`。
相反，编译器在 `.data` 或 `.bss` 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。

比如，假设在同一模块中的两个函数个自定义了一个静态局部变量 x : 

![image-20200620200153801](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620200153801.png)

![image-20200620200227592](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620200227592.png)

符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。

.symtab 节中包含 ELF 符号表。这张符号表包含一个条目的数组。

下面 图 7-4 展示了每个条目的格式：

![image-20200620202712935](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200620202712935.png)

* name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。

* value 是符号的地址。
  对于可重定位的模块来说，value 是距定义目标的节的起始位置的偏移。
  对于可执行目标文件来说，该值是一个绝对运行时地址。

* size 是目标的大小（以字节为单位）。

* type 通常要么是数据，要么是函数。

  符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。

* binding 字段标识符号是本地的还是全局的。

* 每个符号都被分配到目标文件的某个节，由 section 字段表示，该字段也是一个到节头部表的索引。

  有三个特殊的 `伪节(pseudosection)` ，它们在节头部表中是没有条目的：

  * `ABS` 代表不该被重定位的符号

  * `UNDEF` 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号

  * `COMMON` 表示还未被分配位置的未初始化的数据目标。

    > 对于 COMMON 符号 ，value 字段给出对齐要求，而 size 给出最小的大小。
    >
    > 注意：只有可重定位目标文件中才会有这些伪节，可执行目标文件中是没有的。

  COMMON 和 .bss 的区别很细微。现代的 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 COMMON 和 .bss 中：

  * COMMON   未初始化的全局变量
  * .bss              未初始胡的静态变量，以及初始化为0的全局或静态变量

  采用这种看上去很绝对的区分方式的原因，来自于链接器执行符号解析的方式，我们会在 7.6 节中加以解释。

  `GUN READELF` 程序是一个查看目标文件内容的很方便的工具。

  比如，下面是 图 7-1 中示例程序的可重定位目标文件 main.o 的符号表中的最后三个条目。开始的 8 个条目没有显示出来，它们是链接器内部使用的局部符号。

  ![image-20200621002036093](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621002036093.png)

  在这个例子中，我们看到全局符号 main 定义的条目，它是一个位于 .text 节中偏移量为 0（即value值）处的24字节函数。

  其后跟随者的是全局符号 array 的定义，它是一个位于 .data 节中偏移量为 0 处的 8 字节目标。

  最后一个条目来自于对外部符号 sum 的引用。

  READELF 用一个整数索引来标识每个节。

  Ndx = 1 标识 .text 节，而 Ndx=3 表示 .data 节。

  > 这里的 Ndx 的数值对应什么，是在 节头部表中查看。不一定是 Ndx = 1 标识 .text  节。
  >
  > 使用 `readelf -a xxx`   可以查看详细信息，观察节头，节头的号就是 Ndx 数值。

  在 Ubuntu 1804 上使用 readelf -a xxx 得到的内容（可以跟上述内容相互印证）：

  ```shel
  readelf -a prog 
  ELF 头：
    Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    类别:                              ELF64
    数据:                              2 补码，小端序 (little endian)
    版本:                              1 (current)
    OS/ABI:                            UNIX - System V
    ABI 版本:                          0
    类型:                              DYN (共享目标文件)
    系统架构:                          Advanced Micro Devices X86-64
    版本:                              0x1
    入口点地址：               0x4f0
    程序头起点：          64 (bytes into file)
    Start of section headers:          6472 (bytes into file)
    标志：             0x0
    本头的大小：       64 (字节)
    程序头大小：       56 (字节)
    Number of program headers:         9
    节头大小：         64 (字节)
    节头数量：         28
    字符串表索引节头： 27
  
  节头：
    [号] 名称              类型             地址              偏移量
         大小              全体大小          旗标   链接   信息   对齐
    [ 0]                   NULL             0000000000000000  00000000
         0000000000000000  0000000000000000           0     0     0
    [ 1] .interp           PROGBITS         0000000000000238  00000238
         000000000000001c  0000000000000000   A       0     0     1
    [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254
         0000000000000020  0000000000000000   A       0     0     4
    [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274
         0000000000000024  0000000000000000   A       0     0     4
    [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
         000000000000001c  0000000000000000   A       5     0     8
    [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8
         0000000000000090  0000000000000018   A       6     1     8
    [ 6] .dynstr           STRTAB           0000000000000348  00000348
         000000000000007d  0000000000000000   A       0     0     1
    [ 7] .gnu.version      VERSYM           00000000000003c6  000003c6
         000000000000000c  0000000000000002   A       5     0     2
    [ 8] .gnu.version_r    VERNEED          00000000000003d8  000003d8
         0000000000000020  0000000000000000   A       6     1     8
    [ 9] .rela.dyn         RELA             00000000000003f8  000003f8
         00000000000000c0  0000000000000018   A       5     0     8
    [10] .init             PROGBITS         00000000000004b8  000004b8
         0000000000000017  0000000000000000  AX       0     0     4
    [11] .plt              PROGBITS         00000000000004d0  000004d0
         0000000000000010  0000000000000010  AX       0     0     16
    [12] .plt.got          PROGBITS         00000000000004e0  000004e0
         0000000000000008  0000000000000008  AX       0     0     8
    [13] .text             PROGBITS         00000000000004f0  000004f0
         00000000000001b2  0000000000000000  AX       0     0     16
    [14] .fini             PROGBITS         00000000000006a4  000006a4
         0000000000000009  0000000000000000  AX       0     0     4
    [15] .rodata           PROGBITS         00000000000006b0  000006b0
         0000000000000004  0000000000000004  AM       0     0     4
    [16] .eh_frame_hdr     PROGBITS         00000000000006b4  000006b4
         0000000000000044  0000000000000000   A       0     0     4
    [17] .eh_frame         PROGBITS         00000000000006f8  000006f8
         0000000000000118  0000000000000000   A       0     0     8
    [18] .init_array       INIT_ARRAY       0000000000200df0  00000df0
         0000000000000008  0000000000000008  WA       0     0     8
    [19] .fini_array       FINI_ARRAY       0000000000200df8  00000df8
         0000000000000008  0000000000000008  WA       0     0     8
    [20] .dynamic          DYNAMIC          0000000000200e00  00000e00
         00000000000001c0  0000000000000010  WA       6     0     8
    [21] .got              PROGBITS         0000000000200fc0  00000fc0
         0000000000000040  0000000000000008  WA       0     0     8
    [22] .data             PROGBITS         0000000000201000  00001000
         0000000000000018  0000000000000000  WA       0     0     8
    [23] .bss              NOBITS           0000000000201018  00001018
         0000000000000008  0000000000000000  WA       0     0     1
    [24] .comment          PROGBITS         0000000000000000  00001018
         0000000000000029  0000000000000001  MS       0     0     1
    [25] .symtab           SYMTAB           0000000000000000  00001048
         0000000000000600  0000000000000018          26    43     8
    [26] .strtab           STRTAB           0000000000000000  00001648
         0000000000000200  0000000000000000           0     0     1
    [27] .shstrtab         STRTAB           0000000000000000  00001848
         00000000000000f9  0000000000000000           0     0     1
  Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    l (large), p (processor specific)
  
  There are no section groups in this file.
  
  程序头：
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000001f8 0x00000000000001f8  R      0x8
    INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000810 0x0000000000000810  R E    0x200000
    LOAD           0x0000000000000df0 0x0000000000200df0 0x0000000000200df0
                   0x0000000000000228 0x0000000000000230  RW     0x200000
    DYNAMIC        0x0000000000000e00 0x0000000000200e00 0x0000000000200e00
                   0x00000000000001c0 0x00000000000001c0  RW     0x8
    NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_EH_FRAME   0x00000000000006b4 0x00000000000006b4 0x00000000000006b4
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000000df0 0x0000000000200df0 0x0000000000200df0
                   0x0000000000000210 0x0000000000000210  R      0x1
  
   Section to Segment mapping:
    段节...
     00     
     01     .interp 
     02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 
     03     .init_array .fini_array .dynamic .got .data .bss 
     04     .dynamic 
     05     .note.ABI-tag .note.gnu.build-id 
     06     .eh_frame_hdr 
     07     
     08     .init_array .fini_array .dynamic .got 
  
  Dynamic section at offset 0xe00 contains 24 entries:
    标记        类型                         名称/值
   0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
   0x000000000000000c (INIT)               0x4b8
   0x000000000000000d (FINI)               0x6a4
   0x0000000000000019 (INIT_ARRAY)         0x200df0
   0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
   0x000000000000001a (FINI_ARRAY)         0x200df8
   0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
   0x000000006ffffef5 (GNU_HASH)           0x298
   0x0000000000000005 (STRTAB)             0x348
   0x0000000000000006 (SYMTAB)             0x2b8
   0x000000000000000a (STRSZ)              125 (bytes)
   0x000000000000000b (SYMENT)             24 (bytes)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x200fc0
   0x0000000000000007 (RELA)               0x3f8
   0x0000000000000008 (RELASZ)             192 (bytes)
   0x0000000000000009 (RELAENT)            24 (bytes)
   0x000000000000001e (FLAGS)              BIND_NOW
   0x000000006ffffffb (FLAGS_1)            标志： NOW PIE
   0x000000006ffffffe (VERNEED)            0x3d8
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x3c6
   0x000000006ffffff9 (RELACOUNT)          3
   0x0000000000000000 (NULL)               0x0
  
  重定位节 '.rela.dyn' at offset 0x3f8 contains 8 entries:
    偏移量          信息           类型           符号值        符号名称 + 加数
  000000200df0  000000000008 R_X86_64_RELATIVE                    5f0
  000000200df8  000000000008 R_X86_64_RELATIVE                    5b0
  000000201008  000000000008 R_X86_64_RELATIVE                    201008
  000000200fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
  000000200fe0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000200fe8  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
  000000200ff0  000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
  000000200ff8  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0
  
  The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.
  
  Symbol table '.dynsym' contains 6 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
       2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
       3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
       4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
       5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)
  
  Symbol table '.symtab' contains 64 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000238     0 SECTION LOCAL  DEFAULT    1 
       2: 0000000000000254     0 SECTION LOCAL  DEFAULT    2 
       3: 0000000000000274     0 SECTION LOCAL  DEFAULT    3 
       4: 0000000000000298     0 SECTION LOCAL  DEFAULT    4 
       5: 00000000000002b8     0 SECTION LOCAL  DEFAULT    5 
       6: 0000000000000348     0 SECTION LOCAL  DEFAULT    6 
       7: 00000000000003c6     0 SECTION LOCAL  DEFAULT    7 
       8: 00000000000003d8     0 SECTION LOCAL  DEFAULT    8 
       9: 00000000000003f8     0 SECTION LOCAL  DEFAULT    9 
      10: 00000000000004b8     0 SECTION LOCAL  DEFAULT   10 
      11: 00000000000004d0     0 SECTION LOCAL  DEFAULT   11 
      12: 00000000000004e0     0 SECTION LOCAL  DEFAULT   12 
      13: 00000000000004f0     0 SECTION LOCAL  DEFAULT   13 
      14: 00000000000006a4     0 SECTION LOCAL  DEFAULT   14 
      15: 00000000000006b0     0 SECTION LOCAL  DEFAULT   15 
      16: 00000000000006b4     0 SECTION LOCAL  DEFAULT   16 
      17: 00000000000006f8     0 SECTION LOCAL  DEFAULT   17 
      18: 0000000000200df0     0 SECTION LOCAL  DEFAULT   18 
      19: 0000000000200df8     0 SECTION LOCAL  DEFAULT   19 
      20: 0000000000200e00     0 SECTION LOCAL  DEFAULT   20 
      21: 0000000000200fc0     0 SECTION LOCAL  DEFAULT   21 
      22: 0000000000201000     0 SECTION LOCAL  DEFAULT   22 
      23: 0000000000201018     0 SECTION LOCAL  DEFAULT   23 
      24: 0000000000000000     0 SECTION LOCAL  DEFAULT   24 
      25: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
      26: 0000000000000520     0 FUNC    LOCAL  DEFAULT   13 deregister_tm_clones
      27: 0000000000000560     0 FUNC    LOCAL  DEFAULT   13 register_tm_clones
      28: 00000000000005b0     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux
      29: 0000000000201018     1 OBJECT  LOCAL  DEFAULT   23 completed.7698
      30: 0000000000200df8     0 OBJECT  LOCAL  DEFAULT   19 __do_global_dtors_aux_fin
      31: 00000000000005f0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy
      32: 0000000000200df0     0 OBJECT  LOCAL  DEFAULT   18 __frame_dummy_init_array_
      33: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
      34: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sum.c
      35: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
      36: 000000000000080c     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__
      37: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
      38: 0000000000200df8     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end
      39: 0000000000200e00     0 OBJECT  LOCAL  DEFAULT   20 _DYNAMIC
      40: 0000000000200df0     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start
      41: 00000000000006b4     0 NOTYPE  LOCAL  DEFAULT   16 __GNU_EH_FRAME_HDR
      42: 0000000000200fc0     0 OBJECT  LOCAL  DEFAULT   21 _GLOBAL_OFFSET_TABLE_
      43: 00000000000006a0     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini
      44: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
      45: 0000000000201000     0 NOTYPE  WEAK   DEFAULT   22 data_start
      46: 0000000000201010     8 OBJECT  GLOBAL DEFAULT   22 array
      47: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   22 _edata
      48: 00000000000006a4     0 FUNC    GLOBAL DEFAULT   14 _fini
      49: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
      50: 0000000000201000     0 NOTYPE  GLOBAL DEFAULT   22 __data_start
      51: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
      52: 0000000000201008     0 OBJECT  GLOBAL HIDDEN    22 __dso_handle
      53: 0000000000000614    27 FUNC    GLOBAL DEFAULT   13 sum
      54: 00000000000006b0     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
      55: 0000000000000630   101 FUNC    GLOBAL DEFAULT   13 __libc_csu_init
      56: 0000000000201020     0 NOTYPE  GLOBAL DEFAULT   23 _end
      57: 00000000000004f0    43 FUNC    GLOBAL DEFAULT   13 _start
      58: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start
      59: 00000000000005fa    26 FUNC    GLOBAL DEFAULT   13 main
      60: 0000000000201018     0 OBJECT  GLOBAL HIDDEN    22 __TMC_END__
      61: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
      62: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2
      63: 00000000000004b8     0 FUNC    GLOBAL DEFAULT   10 _init
  
  Version symbols section '.gnu.version' contains 6 entries:
   地址： 00000000000003c6  Offset: 0x0003c6  Link: 5 (.dynsym)
    000:   0 (*本地*)       0 (*本地*)       2 (GLIBC_2.2.5)   0 (*本地*)    
    004:   0 (*本地*)       2 (GLIBC_2.2.5)
  
  Version needs section '.gnu.version_r' contains 1 entry:
   地址：0x00000000000003d8  Offset: 0x0003d8  Link: 6 (.dynstr)
    000000: Version: 1  文件：libc.so.6  计数：1
    0x0010:   Name: GLIBC_2.2.5  标志：无  版本：2
  
  Displaying notes found in: .note.ABI-tag
    所有者             Data size  Description
    GNU                  0x00000010       NT_GNU_ABI_TAG (ABI version tag)
      OS: Linux, ABI: 3.2.0
  
  Displaying notes found in: .note.gnu.build-id
    所有者             Data size  Description
    GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
      Build ID: dd27fca66b73407650207acb585c98bb58ea4ed2
  ```

#### 7.6 符号解析

* 链接器解析符号引用的方法 : 

  将每个 `引用` 与 它输入的 `可重定位目标文件` 的 `符号表` 中的 `一个确定的符号定义` 关联起来。

对那些 `和引用定义在相同模块中` 的 `局部符号` 的 `引用`，`符号解析` 是非常简单明了的。

编译器 只允许 `每个模块` 中 `每个局部符号` 有一个定义。

`静态局部变量` 也会有 `本地链接器符号`，编译器还要 `确保它们拥有唯一` 的名字。

不过，对全局符号的引用解析就会棘手的多。
当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。

比如，如果我们试着在一台 Linux 机器上编译和链接下面的源文件：

![image-20200621013654440](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621013654440.png)

对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。
在这种情况中，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。
Linux 系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦。

##### 7.6.1 链接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标模块。

每个模块定义一组符号，有些是局部的（只对定义该符号的模块可见），有些是全局的（对其他模块也可见）。

* 如果多个模块定义同名的全局符号，Linux 编译系统会采用如下的方法处理：

  在编译时，编译器向汇编器输出每个全局符号，或者是 `强(strong)` 或者是 `弱(weak)`。
  而编译器把这个信息隐含地编码在可重定位目标文件的符号表里。
  函数和已初始化的全局变量是 `强符号` ，未初始化的全局变量是 `弱符号`。

  根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：

  * 规则1 : 不允许有多个同名的强符号。
  * 规则2 ：如果有一个强符号和多个弱符号同名，那么选择强符号。
  * 规则3 ：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

  ![image-20200621015426394](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621015426394.png)

##### 7.6.2 与静态库链接

迄今为止，我们都是假设链接器读取一组克可重定位目标文件，并把它们链接起来，形成一个输入的可执行文件。

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为 `静态库（static library）`，它可以用作链接器的输入。

当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

![image-20200621020617906](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621020617906.png)

![image-20200621020635309](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621020635309.png)

##### 7.6.3 链接器如何使用静态库来解析引用

虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux 链接器使用它们解析外部引用的方式。

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件。）

在这次扫描中，链接器维护了三个集合：

* 一个可重定位目标文件的集合 E （这个集合中的文件会被合并起来形成可执行文件）
* 一个未解析的符号（即引用了但是尚未定义的符号）集合U
* 以及一个在前面输入文件中已经定义的集合 D 。

初始时，E、U、D 均为空。

![image-20200621021436059](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621021436059.png)

#### 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。

此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。

现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。

重定位由两步组成：

* 重定位节和符号定义

  > 在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。
  >
  > 例如，来自所有输入模块的 .data 节全部合并成一个节，这个节成为输出的 可执行目标文件的 .data 节。
  >
  > 然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。

* 重定位节中的符号引用

  > 在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。
  >
  > 要执行这一步，链接器依赖于可重定位目标模块中称为 `重定位条目(relocation entry)` 的数据结构。
  >
  > 代码节和数据节的定义，参考 7.4 小节。

##### 7.7.1 重定位条目

当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。

所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 `重定位条目`，高速链接器在将目标文件合并成可执行文件时如何修改这个引用。

代码的重定位条目放在 .rel.text 中。

已初始化数据的重定位条目放在 .rel.data 中。

![image-20200621023030062](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621023030062.png)

![image-20200621023151603](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621023151603.png)

##### 7.7.2 重定位符号引用（待回顾）

* 1. 重定位PC相对引用
* 2. 重定位绝对引用

略（详细内容见书中-待回顾）

#### 7.8 可执行目标文件

我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。

我们的示例 C 程序，开始时是一组 ASCII 文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。

图 7-13 概括了一个典型的 ELF 可执行文件中的各类信息。

![image-20200621023826153](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200621023826153.png)

可执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格式。

它还包括程序的 `入口点(entry point)` ，也就是当程序运行时要执行的第一条指令的地址。

.text、.rodata 和 .data 节 与可重定位目标文件中的节是相似的，除了这些已经被重定位它们最终的运行时内存地址以外。

.init 节电影了一个小函数，叫做 _init ，程序的初始化代码会调用它。

因为可执行文件是 `完全链接的(已被重定位)`，所以它不再需要 .rel 节。

ELF 可执行文件被设计的很容易加载到内存，可执行文件的连续的片(chunk) 被映射到连续的内存段。

`程序头部表(program header table)` 描述了这种映射关系。

图 7-14 展示了可执行文件 prog 的程序头部表，是由 OBJDUMP 显示的。

![image-20200622230201259](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622230201259.png)

从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。

![image-20200622230631125](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622230631125.png)

#### 7.9 加载可执行目标文件

![image-20200622230727888](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622230727888.png)

因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为 `加载器(loader)` 的操作系统代码来运行它。

任何 Linux 程序都可以通过调用 `execve 函数` 来调用加载器（将在8.4.6节详细描述这个函数）。

* 概念：加载

  >  加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的 `第一条指令` 或 `入口点`  来运行该程序。这个将程序复制到内存并运行的过程叫做 `加载` . 

![image-20200622231132753](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622231132753.png)

每个Linux程序都有一个运行时内存映像，类似于上面 图 7-15 中所示。

在 Linux x86-64 系统中，**代码段总是从地址 0x400000 处开始，后面是数据段**。 

运行时堆在数据段之后，通过调用 malloc 库往上增长。（在 9.9 节中会详细描述 malloc 和堆 ）。

堆后面的区域是为 共享模块 保留的。

用户栈总是从最大的合法用户地址(2^48 - 1) 开始，向较小内存地址增长。
栈上的区域，从地址 2^48 开始，是为 `内核` 中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。

![image-20200622232454896](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622232454896.png)

当加载器运行时，它创建类似于图7-15所示的内存映像。

* **可执行文件加载过程**

> 在程序头部表的引导下，加载器将可执行文件的片(chunk)复制到代码段和数据段。
>
> 接下来加载器跳转到程序的入口点，也就是 _start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。_
>
> start 函数调用系统启动函数 __libc_start_main ，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核。

![image-20200622233049980](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622233049980.png)

#### 7.10 动态链接共享库

 ![image-20200622233551665](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622233551665.png)

`共享库(shared library)` 是致力于解决静态库缺陷的一个现代创新产物。

共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中程序链接起来。这个过程称为 `动态链接(dynamic linking)` ，是由一个叫做 `动态链接器(dyanmic linker)` 的程序来执行的。

共享库也称为 `共享目标(shared object)` ，在 Linux 系统中通常用 .so 后缀来表示。

微软的操作系统大量地使用了共享库，它们称为 DLL(动态链接库)。

共享库是以两种不同的方式来"共享"的：

* 首先，在任何给定的文件系统中，对于一个库只有一个 .so 文件。
  所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据。
  而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中。

* 其次，在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。

  > 在第9章，学习虚拟内存时，将更详细的描述共享库 .text 节的问题。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622234222829.png" alt="image-20200622234222829" style="zoom:50%;" />



图 7-16 概括了下面 图 7-7中示例程序的动态链接过程。

> 图 7-7 和 图 7-6 (出现在7.6.3小节) 

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622235202290.png" alt="image-20200622235202290" style="zoom:67%;" />

为了构造 图 7-6 中示例向量例程的共享库 libvector.so ，我们嗲用编译器驱动程序给编译器和链接器如下特殊指令：

![image-20200622235812374](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200622235812374.png)

这样就创建了一个可执行目标文件 prog21 ，而此文件的形式使得它在运行时可以和 libvector.so 链接。

基本思路是：**静态执行一些链接，然后在程序加载时，动态完成链接过程**。

> 静态执行的链接，应该就是重定位和符号表信息，用来指导后面的动态链接过程。

* 认识到这一点是很重要的：

  > 此时没有任何 libvector.so 的代码和数据节真的被复制到可执行文件 prog21 中。
  > 反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。

当加载器加载和运行可执行文件 prog21 时，它利用 7.9 中讨论过的技术（加载可执行目标的过程），加载部分连接的可执行文件 prog21 。

接着，它注意到 prog21 包含一个 .interp 节，这一节包含动态链接器的路径名，动态连接器本身就是一个共享目标(如在 Linux系统上的 ld-linux.so) 。

加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态连接器。
然后，动态连接器通过执行下面的重定位完成链接任务：

* 重定位 libc.so 的文本和数据到某个内存段。
* 重定位 libvector.so 的文本和数据到另一个内存段。
* 重定位 prog21 中所有对由 libc.so 和 libvector.so 定义的符号的引用。

最后，动态连接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。

> 执行动态链接共享库的过程，其实就是把编译时的重定位目标、符号解析、编译链接，放到了加载执行的过程中。

#### 7.11 从应用程序中加载和链接共享库

![image-20200623000806103](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623000806103.png)

* Linux 为动态连接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库：

  ```c
  #include <dlfcn.h>
  void *dlopen(const char *filename, int flag);
  //返回：若成功则为指向句柄的指针，若出错则为 NULL
  ```

  `dlopen` 函数加载和链接共享库 filename 。用已带 `RTLD_GLOBAL` 选项打开了的库解析 filename 中的外部符号。

如果当前可执行文件是带 `-rdynamic` 选项编译的，那么对符号解析而言，它的全局符号也是可用的。
flag 参数必须：

* 要么包括 `RTLD_NOW` ，该标志告诉链接器立即解析对外部符号的引用，
* 要么包括 `RTLD_LAZY` 标志，该标志指示链接器推迟符号解析直到执行来自库中的代码。

这两个值中的任意一个都可以和 `RTLD_GLOBAL` 标志 取 `或`。

---

```c
#include <dlfcn.h>
void *dlsym(void *handle, char *symbol);
//返回：若成功则为指向符号的指针，若出错则为NULL
```

`dlsym` 函数的输入是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字，如果该符号存在，就返回符号的地址，否则返回 NULL。

---

```c
#include <dlfcn.h>
int dlclose(void *handle);
//返回：若成功则为 0 ，若出错则为 -1 .
```

如果没有其他共享库还在使用这个共享库，`dlclose` 函数就卸载该共享库。

---

```c
#include <dlfcn.h>
const char *dlerror(void);
//返回：如果前面对 dlopen、dlsym 或 dlclose 的调用失败，则为错误消息，如果前面的调用成功，则为NULL。
```

`dlerror` 函数返回一个字符串，它描述的是调用 `dlopen`、`dlsym` 或者 `dlclose` 函数时发生的最近的错误，如果没有错误发生，就返回 NULL。

---

![image-20200623002427622](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623002427622.png)

* 概括一下四个使用动态链接库的重要函数：
  * dlopen : 加载打开动态链接库
  * dlsym : 从上一步打开的动态链接库中，取出指定成员（函数或变量字段）
  * dlclose ：用完了动态链接库，关掉卸载这个动态链接库
  * dlerror :  如果上面步骤中执行出错了，就走这个报错函数，获得报错信息。

![image-20200623002801035](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623002801035.png)

> 明白了 Java 中的 JNI ，其实就是切入了一个 dlopen 的点，将Java代码和本地原生代码结合起来，其余部分是 c 和 java 双方各自实现的。

#### 7.12 位置无关代码

![image-20200623003218612](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623003218612.png)

* 概念：位置无关代码(Position-Independent Code, PIC)

  > 可以加载而无需重新定位的代码称为 `位置无关代码` 。
  >
  > 用户对 GCC 使用 -fpic 选项知识 GUN 编译系统生成 PIC 代码。
  >
  > 共享库的编译必须总是使用该选项。
  >
  > （因为动态链接库/也就是共享库，就是在运行或加载时，可以加载到任意的内存地址）
  >
  > 动态链接库/共享库 的描述在 7.10 小节。

在 X86-64 系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为 PIC 的。

可以用 PC 相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。

然后，对共享模块定义的外部过程和对全局变量的引用需要一些特殊技巧：

* 1. **PIC 数据引用**

     > 无论我们在内存中的何处加载一个目标模块（包括共享目标模块），
     >
     > **数据段与代码段的距离总是保持不变**。
     >
     > 因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存地址是无关的。
     >
     > 生成对全局变量PIC引用的编译器利用了这个事实：它在数据段开始的地方创建了一个表，叫做 `全局偏移量表(Global Offset Table, GOT)` 。
     >
     > 在这个 GOT 中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个 8字节条目。
     >
     > 编译器还为 GOT 中每个条目生成一个重定位记录。
     >
     > 在加载时，动态连接器会重定位 GOT 中的每个条目，使得它包含目标的正确的绝对地址。
     >
     > 每二个引用全局目标的目标模块都有自己的 GOT。

     下面 图 7-18 展示了示例 libvector.so 共享模块的 GOT ：

     ![image-20200623004403377](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623004403377.png)

     ​	addvec 例程通过 GOT[3] 间接地加载全局变量 addcnt 的地址，然后把 addcnt 在内存中加1。

     > 这里的关键思想是：对 GOT[3] 的 PC 相对引用中的偏移量是一个运行时常量。

     ![image-20200623004810719](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623004810719.png)

* 2. **PIC 函数调用**

![image-20200623004855804](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623004855804.png)

​	略（详细内容待看书中-待回顾）

#### 7.13 库打桩机制

Linux 链接器支持一个很强大的技术，称为 `库打桩(libraray interpositioning)` ，它允许截获对共享库函数的调用，取而代之执行自己的代码。

使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入输出值，或者甚至把它替换成一个完全不同的实现。

> 这不就是Java中的动态代理思想？或者反射的使用场景？这种机制为hook打下了基础。

* 库打桩的基本思想：

  给定一个需要打桩的 `目标函数` ，创建一个 `包装函数` ，它的原型与目标函数完全一样。
  使用某种特殊的打桩机制，就可以欺骗系统调用包装函数而不是目标函数了。
  包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

打桩可以发生在编译时、链接时或程序被加载和执行的运行时。

下面图 7-20a 是一个例子，它使用了 C 标准库(libc.so) 中的 `malloc` 和 `free` 函数 :

> 对 `malloc` 的调用从堆中分配一个 32 字节的块，并返回指向该块的指针。
> 对 `free` 的调用把块还回到堆，供后续的 `malloc` 调用使用。 

我们的研究目标是，用打桩来追踪程序运行时对 `malloc` 和 `free` 的调用。

##### 7.13.1 编译时打桩

略-详细见书中

##### 7.13.2 链接时打桩

略-详细见书中

##### 7.13.3 运行时打桩

略-详细见书中

#### 7.14 处理目标文件的工具

在Linux系统中又大量可用的工具可以帮助理解和处理目标文件。

**特别的，GUN binutils 包尤其有帮助，而且可以运行在每个 Linux 平台上**：

* AR ：创建静态库，插入、删除、列出和提取成员
* STRINGS : 列出一个目标文件中所有可打印的字符串
* STRIP : 从目标文件中删除符号表信息
* NM : 列出一个目标文件的符号表中定义的符号
* SIZE : 列出目标文件中节的名字和大小
* READELF : 显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 功能。
* OBJDUMP : 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制指令。

Linux 系统为操作共享库还提供了 LDD 程序：

* LDD : 列出一个可执行文件在运行时所需要的共享库。

#### 7.15 小结

链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态连接器来完成。

连接器处理称为目标文件的二进制文件，它有3种不同的形式：

* 可重定位的
* 可执行的
* 共享的

可重定位的目标文件由静态链接器合成一个可执行的目标文件，它可以加载到内存中并执行。

共享目标文件（共享库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始时执行，或者根据需要在程序调用 dlopen 库的函数时。

链接器的两个主要任务是：

* 符号解析

  > 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义

* 重定位

  > 而重定位确定每个符号的最终内存地址，并修改对那些目标的引用

静态链接器是由像 GCC 这样的编译驱动程序调用的。

它们将多个可重定位目标文件合并成一个单独的可执行目标文件。

多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序汇总引入微妙的错误。

多个目标文件可以被连接到一个单独的静态库中。

链接器用来解析其他目标模块中的符号引用。

许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。

加载器将可执行文件的内容**映射**到内存，并运行这个程序。

链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。

被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。
为了加载、链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。

![image-20200623221511548](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623221511548.png)

### 第8章 异常控制流

![image-20200623221552174](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623221552174.png)

![image-20200623221639334](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200623221639334.png)

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。

> 比如：
>
> 一个硬件定时器定期产生信号，这个事件必须得到处理。
> 包到达网络适配器后，必须存放在内存中。
> 程序向磁盘请求数据，然后休眠，知道被通知说数据已就绪。
> 当子进程终止时，创造这些子进程的父进程必须得到通知。

* 概念：异常控制流(Exceptional Control Flow, ECF)

  **现代系统通过使控制流发生突变来对这些情况作出反应**。

  一般而言，我们把这些突变称为 异常控制流。

  > 异常控制流发生在计算机系统的各个层次。
  >
  > 比如：
  > 在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。
  > 在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。
  > 在应用层，一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。
  > 一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。

作为程序员，理解 ECF 很重要，这有很多原因：

* 理解 ECF 将帮助理解重要的系统概念

  > ECF 是操作系统用来实现 I/O 、进程和虚拟内存的基本机制。
  >
  > 在能够真正理解这些重要概念之前，必须理解 ECF。

* 理解 ECF 将帮助理解应用程序是如何与操作系统交互的

  > 应用程序通过使用一个叫做 `陷阱(trap)` 或者 `系统调用(system call)` 的 ECF 形式，向操作系统请求服务。
  >
  > 比如：向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。
  > 理解基本的系统调用机制将帮助理解这些服务是如何提供给应用的。

* 理解 ECF 将帮助编写有趣的新应用程序

  > 操作系统为应用程序提供了强大的 ECF 机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。
  >
  > 如果理解了这些 ECF 机制，那么就能用它们来编写诸如  Unix shell 和 Web 服务器之类的程序了。

* 理解 ECF 将帮助理解并发

  > ECF 是计算机系统中实现并发的基本机制。
  >
  > 在运行中的并发的例子有：
  >
  > 中断应用程序执行的异常处理程序，
  > 在时间上重叠执行的进程和线程，
  > 以及中断应用程序执行的信号处理程序。
  >
  > 理解 ECF 是理解并发的第一步。在第12章会更详细的研究并发。

* 理解 ECF 将帮助理解软件异常如何工作

  > 像 C++ 和 Java 这样的语言通过 try、catch 以及 throw 语句来提供软件异常机制。
  >
  > 软件异常允许程序进行 `非本地跳转(即违法通常的调用/返回栈规则的跳转)` 来相应错误情况。
  >
  > `非本地跳转` 是一种应用层 ECF ，在 C 中是通过 setjmp 和 longjmp 函数提供的。
  >
  > 理解这些低级函数将帮助理解高级软件异常如何得以实现。

![image-20200624002823308](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624002823308.png)

#### 8.1 异常

**异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现**。

因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。

然后，对于每个系统而言，基本的思想都是相同的。

这节中，我们的目的是对异常和异常处理有一个一般性的了解，揭示现代计算机系统的一个常令人感到迷惑的方面。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624003201840.png" alt="image-20200624003201840" style="zoom:67%;" />

`异常(exeption)` 就是控制流中的突变，用来相应处理器状态中的某些变化。上面 图 8-1 展示了基本的思想。

> 在图中，当处理器状态发生一个重要变化时，处理器正在执行某个当前指令 Icurr。
>
> 在处理器中，状态被编码为不同的位和信号。**状态变化称为 `事件(event)`** 。
>
> 事件可能和当前执行的执行直接相关。
> 比如，发生内存页缺失、算术溢出，或者一条指令试图除以零。
>
> 另一方面，事件也可能和当前指令的执行没有关系。
> 比如，一个系统定时器产生信号或者一个 I/O 请求完成。

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做 `异常表(exeption table)` 的跳转表，进行一个间接过程调用（异常）,到一个专门设计用来处理这类事件的操作系统 子程序（异常处理程序(exception handler)）。

当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况中的一种：

* 1） 处理程序将控制返回给当前指令 Icurr，即当前事件发生时正在执行的指令。
* 2） 处理程序将控制返回给 Inext ，如果没有发生异常将会执行的下一条指令。
* 3）处理程序终止被中断的程序。

> 8.1.2 节将讲述更多关于这些可能性的内容

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624004122283.png" alt="image-20200624004122283" style="zoom:67%;" />

##### 8.1.1 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。

其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。

* 处理器设计者分配的异常号：
  * 被零除
  * 缺页
  * 内存访问违例
  * 断点
  * 算术运算溢出
* 操作系统内核设计者分配的异常号：
  * 系统调用
  * 来自外部 I/O 设备的信号

在系统启动时（当计算机重启或加电时），操作系统分配和初始化一张称为 `异常表` 的跳转表，使得表目 k 包含异常 k 的处理程序地址。

下面图 8-2 展示了异常表的格式：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624232253815.png" alt="image-20200624232253815" style="zoom:67%;" />

在运行时（当系统在执行某个程序时），处理器 检测到发生了一个事件，并且确定了相应的异常号 k 。
随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k ，转到相应的处理程序。

图 8-3 展示了处理器如何使用异常表来形式适当的异常处理程序的地址。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624232716966.png" alt="image-20200624232716966" style="zoom:67%;" />

异常号是到异常表中的索引，异常表的起始地址放在一个叫做 `异常表基址寄存器(exception table base register)` 的特殊 CPU 寄存器里。

异常类似过程调用，但是有一些重要的不同之处：

* 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。
  然后，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。

* 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。

  > 比如，x86-64 系统会将包含当前条件码的 EFLAGS 寄存器和其他内容压入栈中。

* **如果控制从用户程序转移到内核，所有这些项目都被压到内核中，而不是压到用户栈中** 。

  > 这会不会有什么风险，或漏洞？

* 异常处理程序运行在 `内核模式下(见8.2.4节)` ，这意味着它们 `对所有的系统资源都有完全的访问权限`。

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。

在处理程序处理完事件之后，它通过执行一条特殊的 "从中断返回" 指令，`可选地返回到` 被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为 `用户模式(见8.2.4节)` ，然后将控制返回给被中断的程序。

##### 8.1.2 异常的类别

异常分为四类：

* 中断(interrupt)
* 陷阱(trap)
* 故障(fault)
* 终止(abort)

下面图 8-4 的表对这些类别的属性做了小结：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624234027775.png" alt="image-20200624234027775" style="zoom:67%;" />

**1. 中断**

中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。

硬件中断的异常处理程序常常称为 `中断处理程序(interrupt handelr)`。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200624234600299.png" alt="image-20200624234600299" style="zoom:67%;" />

上面图 8-5 概述了一个中断的处理。

> I/O 设备，例如网络适配器、磁盘控制器和定时芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

在当前指令完成执行之后，处理程序注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。
当处理程序返回时，它就将控制返回给下一条指令（也就是如果没有发生中断，在控制流中会在当前指令之后的那条指令）。
结果是程序继续执行，就好像没有发生过中断一样。

剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。这类指令叫做 `故障指令(faulting instruction)` 。 

**2. 陷阱和系统调用**

陷阱是有意的异常，是执行一条指令的结果。

就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。

陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做 `系统调用`。

用户程序经常需要向内核请求服务，比如读一个 文件(read) 、创建一个新的进程(fork)、加载一个新的程序(execve) ，或者终止当前进程(exit)。

为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 `syscall n`  指令，当用户程序想要请求服务 n 时，可以执行这条指令。

执行 `syscall` 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

下面 图 8-6 概述了一个系统调用的处理：

![image-20200625144716190](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625144716190.png)

从程序员的角度看，系统调用和普通的函数调用是一样的。

然后，**它们的实现非常不同** ：

* 普通的函数运行在 `用户模式` ，用户模式限制了函数可以执行的指令的类型，
  而且它们只能访问与调用函数相同的栈。

* 系统调用运行在 `内核模式` 中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。

  > 8.2.4 节会更详细地讨论用户模式和内核模式。

**3. 故障**

故障由错误情况引起，它可能能够被故障处理程序修正。

当故障发生时，处理程序将控制转移给故障处理程序。

如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。
否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。

下面 图 8-7 概述了一个故障的处理：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625145434359.png" alt="image-20200625145434359" style="zoom:67%;" />

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。

就像将在 第9章 看到的，`一个页面就是虚拟内存的一个连续的块（典型的是4KB）`。

缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。
当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。

**4. 终止**

终止是不可恢复的致命错误造成的结果，**通常是一些硬件错误**，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。

终止处理程序从不将控制返回给应用程序。

如 下面 图 8-8 所示，处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。

![image-20200625150005520](../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625150005520.png)

##### 8.1.3 Linux/x86-64 系统中的异常

x86-64 系统中有高达 256 种不同的异常类型：

* 0~31 

  > 对应的是由 Intel 架构师定义的异常。
  > 因此这些异常对任何 x86-64 系统都是一样的。

* 32~255

  > 对应的是操作系统定义的中断和陷阱。

下面 图 8-9 展示了一些示例：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625150541194.png" alt="image-20200625150541194" style="zoom:67%;" />

**1. Linux/x86-64 故障和终止**

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625151311556.png" alt="image-20200625151311556" style="zoom:67%;" />

**2. Linux/x86-64 系统调用**

Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。

下面 图 8-10 给出了一些常见的 Linux 系统调用：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625154054828.png" alt="image-20200625154054828" style="zoom:67%;" />

每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。

> 注意：这个跳转表和异常表不一样。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625154257693.png" alt="image-20200625154257693" style="zoom:67%;" />

在x86-64系统上，系统调用时通过一条称为 `syscall` 的陷阱指令来提供的。

**所有到 Linux 系统调用的参数都是通过 `通用寄存器` 而不是 `栈` 传递的**。

按照惯例，寄存器 `%rax` 包含系统调用号，寄存器 `%rdi` 、`%rsi` 、`%rdx` 、`%r10` 、`%r8` 和 `%r9` 包含最多6个参数。

第一个参数在 `%rdi` 中，第二个在 `%rsi` 中，以此类推。

从系统调用返回时，寄存器 `%rcx` 和 `%r11` 都会被破坏，`%rax` 包含返回值。

`-4095` 到 `-1` 之间的负数返回值表明发生了错误，对应于负的 `errno` 。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625164342783.png" alt="image-20200625164342783" style="zoom:67%;" />

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200625164632750.png" alt="image-20200625164632750" style="zoom:67%;" />

#### 8.2 进程

**异常是允许操作系统内核提供 `进程(process)` 概念的基本构造块**，进程是计算机科学中最深刻、最成功的概念之一。

 现代系统上运行一个程序时，会得到一个假象，就好像程序时系统当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断的一条接一条地执行我们程序中的指令。
最后，我们系统中的代码和数据好像是系统内存中唯一的对象。
这些假象都是通过进程的概念提供给我们的。

进程的经典定义就是 `一个执行中程序的实例`。

系统中的每个进程都运行在某个进程的 `上下文(context)` 中。

**上下文是由程序正确运行所需的状态组成的**。

这个状态包括：

* 存放在内存的程序的代码和数据
* 它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

> 每次用户通过向 shell 输入一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。
>
> 应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。

**进程提供给应用程序的关键抽象有**：

* 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器。
* 一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统。

##### 8.2.1 逻辑控制流

 即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，**好像它在独占的使用处理器**。

如果想用调试器单步执行程序，我们会看到一系列的 `程序计数器（PC的值）` ，这些 `值` `唯一地` 对应于包含在程序的  `可执行目标文件中的指令` ，或是包含在运行时 `动态链接到程序的共享对象` 中的指令。
这个 PC  值的序列叫做 `逻辑控制流` ，或者简称逻辑流。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200628160343146.png" alt="image-20200628160343146" style="zoom:67%;" />

考虑一个运行着三个进程的系统，如 上面 图 8-12 所示。

**处理器的一个物理控制流被分成了三个逻辑流** ，每个进程一个。

每个竖直的条表示一个进程的逻辑流的一部分。

在这个例子中，三个逻辑流的执行是交错的。

> 进程 A 运行了一会，然后是 进程 B 开始运行到完成。
>
> 然后，进程 C 运行了一会，进程 A 接着运行直到完成。
>
> 最后，进程 C 运行到结束。

图 8-12 的关键点在于进程是轮流使用处理器的。

每个进程执行它的流的一部分，然后被抢占（preempted）(暂时挂起)，然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，她看上去就像是在独占的使用处理器。
唯一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU 好像会周期性的停顿。
然而，每次处理器停顿，它随后会继续执行我们的程序，并不改变程序内存位置或寄存器的内容。

##### 8.2.2 并发流

计算机系统中逻辑流有许多不同的形式。

异常处理程序、进程、信号处理程序、线程 和 Java 进程都是逻辑流的例子。

**一个逻辑流的执行在时间上与另一个流重叠，称为 `并发流(concurrent flow)` ，这两个流被称为并发地运行**。

更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后 和 Y 结束之前开始，或者 Y 在 X 开始之后 和 X 结束之前开始。

例如 图 8-12 中，进程 A 和 B 并发的运行，A 和 C 也一样。

另一方面，B 和 C 没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行。

**多个流并发地执行的一般现象被称为 `并发(concurrency)`**。

**一个进程和其他进程轮流运行的概念称为 `多任务(multitasking)`**。

**一个进程执行它的 `控制流` 的 `一部分` 的 `每一时间段` 叫做 `时间片(time slice)`**。

>  例如，上面 图 8-12 中，进程 A 的流由两个时间片组成。



* 注意：并发流的思想与流运行的处理器核数或计算机数无关。

  > 如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。



有时我们会发现确认 `并行流` 很有帮助，它是 `并发流` 的一个真子集。

**如果两个流 `并发的` 运行在 `不同的处理器核或者计算机上` ，那么我们称它们为 `并行流(parallel flow)`**。

它们 `并行地` 运行(running in parallel) ，且 `并行地执行(parallel execution)`。

##### 8.2.3 私有地址空间

进程也为每个程序提供一种假象，好像它 **独占地使用系统地址空间**。

**在一台 n 位地址的机器上，`地址空间` 是 2^n 个可能地址的集合**。

> 如：0,1, ...,  (2^n) - 1

进程为每个程序提供它自己的  `私有地址空间`。

一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。

尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。

比如，下面的 图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200628182447697.png" alt="image-20200628182447697" style="zoom:67%;" />

* 地址空间底部是保留给用户程序的，包括通常的 代码、数据、堆和栈段。

  > 地址空间的底部，地址是最小的，例如 0x00 , 0x400000 开始。
  >
  > 地址空间的顶部，地址是最大的，例如 （2^48） -1  大小

**代码段总是从 地址 `0x400000` 开始**。

地址空间顶部是保留给内核（操作系统常驻内存的部分）。
地址空间的这个部分包含 内核在 `代表进程` 指令执行时（比如当前应用程序执行系统调用时）使用的代码、数据 和 栈。

##### 8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用某个控制寄存器中的一个 `模式位(mode bit)` 来提供过这种功能的。

> 该寄存器描述了进程当前享有的特权。 

当设置了模式位时，进程就运行在 `内核模式` 中（有时叫做 `超级用户模式 root?`）。

一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何位置。

没有设置模式位时，进程就运行在 `用户模式` 中。

用户模式中的进程不允许执行 `特权指令(privileged instruction)`。

> 比如，不会允许 停止处理器、改变模式位，或者发起一个 I/O 操作。
>
> 也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。
>
> 任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。

运行应用程序代码的进程初始时时在用户模式中的。

进程从 `用户模式` 变为 `内核模式` 的唯一方法是通过诸如中断、故障 或者 陷入系统调用这样的异常。

> 当异常发生时，控制传递到异常处理程序，处理器将模式从 `用户模式` 变为 `内核模式`。
>
> 处理程序运行在 `内核模式` 中，当它返回到应用程序代码时，处理器就把模式从 `内核模式` 改回到 `用户模式`。

Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。

/proc 文件系统将许多 `内核数据结构的内容` 输出为一个 `用户程序可以读` 的 `文本文件` 的 `层次结构`。

> 比如，可以使用 /proc 文件系统找出一般的系统属性。
>
> 比如，CPU 类型（/proc/cpuinfo），或者某个特殊的进程使用的内存段（/proc/<process-id> /maps）。
>
> 2.6 版本的 Linux 内核引入 /sys 文件系统，它输出关于系统总线和设备的额外的底层信息。

##### 8.2.5 上下文切换

操作系统内核使用一种称为 `上下文切换(context switch)` 的较高层形式的异常控制流来实现多任务。

上下文切换机制是建立在 8.1 节中已经讨论过的那些 `较低层次异常机制` 上的。

**内核为每个进程维持一个 `上下文(context)`**。

**上下文就是 `内核重新启动` 一个 `被抢占` 的进程 `所需的状态`**。

它由一些对象的值组成，这些对象包括：

* 通用目的寄存器

* 浮点寄存器

* 程序计数器

* 用户栈

* 状态寄存器

* 内核栈

* 各种内核数据结构

  > 比如描述地址空间的 `页表`。
  >
  > 包含有关当前进程信息的 `进程表`。
  >
  > 以及包含进程已打开文件的信息的 `文件表`。

**概念 - 调度：**

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。

这种决策就叫做 `调度(scheduling)`，是由内核中称为 `调度器(scheduler)` 的代码处理的 。

当内核选择一个新的进程运行时，我们说内核调度了这个进程。

在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为 `上下文切换` 的机制来将控制转移到新的进程。

**上下文切换，执行以下操作：**

* 1. 保存当前进程的上下文
* 2. 恢复某个先前被抢占的进程被保存的上下文
* 3. 将控制传递给这个新恢复的进程

> 当内核代表用户执行系统调用时，可能会发生上下文切换。

如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。

> 比如，如果一个read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。
> 比如，sleep 系统调用，它显示地请求让调用进程休眠。

一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。

终端也可能引发上下文切换。

> 比如，所有的系统都有某种产生周期性定时器中断的机制，通常为 每 1毫秒 或 每 10毫秒。
>
> 每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200629161158533.png" alt="image-20200629161158533" style="zoom:67%;" />

上面 图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。

在这例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read 陷入到内核。
内核中的陷阱处理程序请求来自磁盘控制器的 DMA  传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。

> 磁盘取数据要用一段相对较长的事件（数量级为几十毫秒），所以内核执行从 进程A 到 进程B 的上下文切换，而不是在这间歇时间内等待，什么都不做。
>
> 注意在切换之前，内核正代表 进程A 在用户模式下执行指令（即没有单独的内核进程）。
>
> 然后在某一时刻，它开始代表 进程B（仍然是内核模式下）执行指令。
>
> 在切换之后，内核代表 进程B 在用户模式下执行指令。
>
> 随后，进程B 在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。
>
> 内核判定 进程B 已经运行了足够长的时间，就执行一个从 进程B 到 进程A 的上下文切换，将控制返回给 进程A 中紧随在系统调用 read 之后的那条指令。
>
> 进程A 继续运行，直到下一次异常发生，依此类推。

#### 8.3 系统调用错误处理

当 Unix 系统级函数遇到错误时，它们通常会返回 -1 ，并设置全局整数变量 errno 来表示什么出错了。

####  8.4 进程控制

##### 8.4.1 获取进程ID

每个进程都有一个唯一的正数（非零）进程ID(PID) 。getpid 函数返回调用进程的 PID。

getppid 函数返回它的父进程的 PID（创建调用进程的进程）。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706144626089.png" alt="image-20200706144626089" style="zoom:50%;" />

##### 8.4.2 创建和终止进程

从程序员的角度，进程总是处于下面三种状态之一：

* 运行

  > 进程要么在CPU上执行，要么在等待被执行且最终被内核调度。

* 停止

  > 进程的执行被 `挂起(suspended)` ，且不会被调度。
  >
  > 当收到 SIGSTOP、SIGTSTP、SIGTTIN 或者 SIGTTOU 信号时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，在 8.5 节中详细描述）。

* 终止

  > 进程永远地停止了。
  >
  > 进程会因为三种原因终止：
  >
  > 1) 收到一个信号，该信号的默认行为是终止进程
  >
  > 2) 从主程序返回
  >
  > 3) 调用 exit 函数

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706145116808.png" alt="image-20200706145116808" style="zoom:50%;" />

`exit 函数` 以 `status` 退出状态来终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。

父进程通过调用 `fork 函数` 创建一个新的运行的子进程。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706152915943.png" alt="image-20200706152915943" style="zoom:50%;" />

新创建的 `子进程` 几乎但不完全 与 `父进程` 相同。

**子进程得到与父进程用户及虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈**。

子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。

父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。

`fork函数` 很有趣，但也常常令人迷惑，因为 **它只被调用一次，却会返回两次**：

* 一次返回是在调用进程（父进程）中

  > 在父进程中，fork 返回子进程的 PID。

* 一次返回是在新创建的子进程中

  > 在子进程中，fork 返回 0。
  >
  > 因为子进程的 PID 总是为非零，返回值就提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706153634121.png" alt="image-20200706153634121" style="zoom:50%;" />

上面 图 8-15 展示了一个使用 fork 创建子进程的父进程的示例。

当 fork 调用在 第 6 行返回时，在父进程和子进程中 x 的值都为 1。

子进程在 第 8 行 +1 并输出它的 x 的 副本。

相似的，父进程在 第 13 行 -1 并输出它的 x 的副本。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706153836232.png" alt="image-20200706153836232" style="zoom:50%;" />

这个简单的例子有一些微妙的方面：

* 调用一次，返回两次：

  > fork 函数被父进程调用一次，但是却返回两次，
  >
  > ①  一次是返回到父进程，
  >
  > ② 一次是返回到新创建的子进程。
  >
  > 对于只创建一个子进程的程序来说，这还是相当简单直接的。
  >
  > 但是，具有多个 fork 实例的程序，可能就会令人迷惑，需要仔细的推敲。

* 并发执行

  > `父进程` 和 `子进程` 是 `并发运行` 的独立进程。
  >
  > `内核` 能够 `以任意方式交替执行` 它们的逻辑控制流中的指令。
  >
  > 在我们的系统上运行这个程序时，父进程先完成它的 printf 语句，然后是子进程。
  >
  > 然而，在 `另一个系统上可能正好相反`。
  >
  > 一般而言，作为程序员，不能对不同进程中的指令的交替执行做任何假设。

* 相同但是独立的地址空间

  > 如果能够在  `fork 函数` 在 `父进程和子进程中返回后` 立即暂停 这两个进程，
  >
  > 会看到 父进程 和 子进程 拥有的以下内容都是相同的：
  >
  > * 相同的 `地址空间`
  > * 相同的 `用户栈`
  > * 相同的 `本地变量值`
  > * 相同的 `堆`
  > * 相同的 `全局变量值`
  > * 以及相同的 `代码`
  >
  > 因此，在上面的 图 8-15 示例程序中，当 fork 函数在 第6行 返回时，`本地变量 x` 在 `父进程` 和 `子进程` 中都为 1。
  >
  > 然而，因为相同的 `父进程` 和 `子进程` 是 `独立的进程` ，它们都有自己的 `私有地址空间`。
  >
  > **后面，父进程 和 子进程 对 x 所做的任何改变都是独立的** ，不会反映在另一个进程的内存中。
  >
  > 这就是为什么当父进程和子进程调用它们各自的 printf 语句时，它们中的变量 x 会有不同的值。

* 共享文件

  > 当运行上面 图8-15 这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。
  >
  > 原因是 `子进程` 继承了 `父进程` 所有的 `打开文件`。
  >
  > 当 `父进程` 调用 `fork` 时，`stdout` 文件是打开的，并指向屏幕。
  >
  > 子进程继承了这个文件，因此它的输出也是指向屏幕的。

  

**fork 函数的进程图描述**

前趋图网络解释

> 解释一：
>
> 前趋图是一个有向无环图，用于描述进程之间执行的先后顺序。
>
> 图中每个结点可用来表示一个进程或程序段，结点间的有向边则表示两个结点之间存在偏序或前驱关系。
>
> 解释二：
>
> 前趋图，是用于描述进程之间的执行顺序的一种有向无循环图（dag directed acyclic graph）。
>
> 是为了描述一个程序的各个部分间的依赖关系，或者是一个大的计算的各个子任务间的因果关系的图示。
>
> 结点用来描述，一个进程、程序段、乃至一条语句；
>
> 而结点间的有向边用来表示偏序（Partial order）或前驱关系（Precedence relation）

通过画 fork 函数的进程图，能够帮助理解它的运作。

进程图是刻画程序语句的偏序的一种简单的 `前趋图`。

* 本书中结合例子对 前趋图 的解释：

  * 每个顶点 a 对应于一条程序语句的执行。

  * 有向边  a->b 表示语句 a 发生在 语句 b 之前。

  * 边上可以标记处一些信息，例如一个变量的当前值。

    > 对应于 printf 语句的顶点可以标记上 printf 的输出。
    >
    > 每张图从一个顶点开始，对应于调用 main 的父进程。
    > 这个顶点没有入边，并且只有一个出边。
    >
    > 每个进程的顶点序列结束语一个对应于 exit 调用的顶点。
    > 这个顶点只有一条边，没有出边。

  <img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706175138990.png" alt="image-20200706175138990" style="zoom:50%;" />

  上面 图8-16 描述了 图 8-15 中示例程序的进程图。

  > 初始时，父进程将变量 x 设置为 1 。
  >
  > 父进程调用 fork ，创建一个子进程，它在自己的私有地址空间中与父进程并发执行。

  对于运行在单处理器上的程序，对应进程图中所有顶点的 `拓扑排序(topological sort)` 表示程序中语句的一个可行的全序排列。

  * 理解拓扑排序概念的简单方法：

    给定进程图中顶点的一个排列，把顶点序列从左到右写成一行，然后画出每条有向边。

    排列是一个拓扑排列，当且仅当画出的每条边的方向都从左往右的。

  

  因此，在 图 8-15 的示例中，父进程和子进程的 printf 语句可以 `以任意先后顺序执行`，因为 每种顺序都对应于图顶点的某种拓扑排序。

  进程图特别有助于理解带有嵌套 fork 调用的程序。

  <img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706184802802.png" alt="image-20200706184802802" style="zoom:50%;" />

  例如，上图 图 8-17 中的程序源码中两次调用了 fork。对应的进程图可帮助看清这个程序运行了四个进程，每个都调用了一次 printf ，这些 printf 可以以任意顺序执行。

##### 8.4.3 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。

相反，进程被保持在一种 `已终止的状态` 中，直到被它的 **父进程** `回收(reaped)`。

当父进程回收已终止的子进程时，`内核` 将 `子进程` 的 `退出状态` 传递给 `父进程`，然后 `抛弃已终止的进程`，从此时开始，该进程就不存在了。

一个终止了但还未被回收的进程称为 `僵死进程(zombie)`。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706185143130.png" alt="image-20200706185143130" style="zoom:50%;" />

如果一个 `父进程` 终止了，`内核` 会安排 `init 进程` 成为它的 `孤儿进程` 的 `养父`。

**`init进程` 的PID 为 1 ，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先**。

如果 `父进程` 没有 `回收` 它的 `僵死子进程` 就终止了，那么 `内核` 会安排 `init 进程` 去回收它们。

不过，长时间运行的程序，比如 shell 或者 服务器，总是应该回收它们的僵死子进程。

**即使僵死子进程没有运行，它们依然消耗系统的内存资源**。

一个进程可以通过调用 `waitpid 函数` 来等待它的子进程终止或者停止。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706185602927.png" alt="image-20200706185602927" style="zoom:50%;" />

`waitpid 函数` 有点复杂。

默认情况下（当 options = 0）时，waitpid 挂起调用进程的执行，直到它的 `等待集合(wait set)` 中的一个子进程终止。
如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。

在以上这两种情况中，`waitpid` 返回 `导致 waitpid 返回` 的 `已终止子进程的 PID` 。

此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。

**1. 判定等待集合的成员**

等待集合的成员是由参数 pid 来确定的：

* 如果 pid > 0 ，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。
* 如果 pid = -1 , 那么等待集合就是由父进程所有的子进程组成的。

waitpid 函数还支持其他类型的等待集合，包括 Unix 进程组，这里不做讨论。

**2. 修改默认行为**

可以通过将 options 设置为 敞亮 WNOHANG 、WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706190623872.png" alt="image-20200706190623872" style="zoom:50%;" />

**3. 检查已回收子进程的退出状态**

如果 `statusp 参数` 是非空的，那么 `waitpid` 就会在 `status` 中放上关于 `导致返回的子进程` 的 `状态信息`，**`status` 是 `statusp` 指向的值**。

`wait.h` 头文件定义了解释  `status 参数` 的几个宏：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706191153108.png" alt="image-20200706191153108" style="zoom:50%;" />

**4. 错误条件**

如果调用进程没有子进程，那么 waitpid 返回 -1 ，并且设置 errno 为 ECHILD 。

如果 waitpid 函数被一个信号中断，那么它返回 -1 ，并设置 errno 为 EINTR。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706191628225.png" alt="image-20200706191628225" style="zoom:50%;" />

**5. wait 函数**

wait 函数是 waitpid 函数的简单版本：

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706191815638.png" alt="image-20200706191815638" style="zoom:50%;" />

调用 `wait(&status)` 等价于调用 `waitpid(-1, & status, 0)`。

**6. 使用 waitpid 的示例**

略（必要时，需要使用再来翻看书中内容，或待补充）

##### 8.4.4 让进程休眠

`sleep 函数` 将一个 `进程挂起` 一段 `指定的时间`。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706192150545.png" alt="image-20200706192150545" style="zoom:50%;" />

如果请求的时间量已经到了，`sleep` 返回 0 ，否则返回还剩下的要休眠的秒数。
如果因为 `sleep 函数` 被一个 `信号中断` 而过早的返回，就会出现后一种情况。

∂在 8.5 节中会详细讨论信号。

另一很有用的函数是 `pause 函数` ，该函数让 `调用函数休眠`，`直到该进程收到一个信号`。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706192358834.png" alt="image-20200706192358834" style="zoom:50%;" />

##### 8.4.5 加载并运行程序

`execve 函数` 在 `当前进程` 的 `上下文中` 加载并 `运行一个新程序`。

<img src="../images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200706192630149.png" alt="image-20200706192630149" style="zoom:50%;" />

