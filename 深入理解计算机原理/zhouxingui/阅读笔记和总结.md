
2020.06.01
# 第一章
## 读后感：
	看完，有一些听过的概念，比如 计算机硬件组成：输入输出设备、寄存器、储存器、进程、线程。当然还有很多第一次接触的概念。对于计算机有了初步的认识。

2020.06.02

## 1.信息就是位+上下文
		a.文本文件和二进制文件的区别：文本给我们看的(#<hello.h>)，二进制是存储的时候给计算机看的（1010100011101）。(文件展示和存储的区别？)
		b.上下文：是否可理解为不同的编码，如ASII，unicode编码等？
		
## 2.程序被其他程序翻译成不同的格式
		a.高级语言（c）被其他程序转化为低级机器语言。
		b.Unix的编译系统：	预处理器，编译器，汇编器，链接器？
		
## 3.了解系统是如何工作的大有益处
		a.程序性能优化：
		b.链接出错，静态和动态？
		c.安全漏洞，理解数据和控制信息存储在程序栈原理，缓冲区溢出错误。
		
## 4.处理器读并解释内存中的指令(这章概念都了解过，所以读起来更流畅)

		等等其他未列列举.....
		
# 第一部分： 程序结构和执行
	
## 2.0 信息的表示和处理
### 1.三种数字表示：无符号编码、补码、浮点数
		
### 2.整数和浮点数做数学运算的差异

		a.整数：计算的时候值不会变
		b.浮点数：不同计算值可能不同
				能表示更大的值，但是只是近似的表示
### 3.C语言和c++简介

## 2.1 信息存储
	1.计算机使用8位的 byte（字节）作为最小的可寻址内存单位。而不是位（bit）

	2.虚拟内存：机器级程序将内存视为一个非常大的字节数组。

	3.地址：内存的每个字节都由一个唯一的数字来表示

	4.虚拟地址空间：所有可能的地址的集合

	5.C语言中指针的作用，指针有两个方面
		值表示某个对象的地址
		类型表示那个位置上所存储对象的类型（整数或浮点数）

### 2.1.1 十六进制表示法
	1.为什么使用16进制？位模式什么意思?
		知乎文章：什么是位模式？ https://zhuanlan.zhihu.com/p/46317118
		总结：
		“位模式”是计算机表达数学中“数”的概念的权宜之计。
		由于十六进制的效率较高，最后采用了十六进制作为计算机位模式的标准。
	（注：作者竟然在看的是 CSAPP 英文版！）

	2.进制转换的练习题是否重要？
		时间不够，是否需要练习？

----06.02 到此处----
## 06.02读后感：第二天，为了看懂很多概念性的东西，和查资料，阅读速度很慢 p22-p27,1个小时看了6页。 

----06.03开始 ----
早：30分钟 p27-p31

### 2.1.2 字数据大小
	1.每台计算机都有一个字长（word size），指明指针数据的标称大小(nominal size)
		指针数据：
		标称：

	2.从32位字长机器到64位字长机器的迁移
		32位最大内存4GB
		32位最大内存16EB
		EB单位：
		1MB可储存1024×1024=1048576字节（Byte）。
		字节（Byte）是存储容量基本单位，1字节（1Byte）由8个二进制位组成。
		位（bit）是计算机存储信息的最小单位，二进制的一个“0”或一个“1”叫一位。
		通俗来讲，1MB约等于一张网络通用图片（非高清）的大小。
		1GB=1024MB，约等于下载一部电影（非高清）的大小。
		1TB=1024GB，约等于一个固态硬盘的容量大小，能存放一个不间断的监控摄像头录像（200MB/个）长达半年左右。
		1PB=1024TB，容量相当大，应用于大数据存储设备，如服务器等。
		1EB=1024PB，目前还没有单个存储器达到这个容量。

	3.字长决定虚拟地址空间的最大大小
	虚拟地址空间：
	**虚拟地址空间**是什么意思？
	32位字长限制虚拟地址空间为4GB。
	解释：http://c.biancheng.net/view/1727.html
	当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory）。

	硬盘中开辟的一块区域就是虚拟内存。


	4.c语言中的有符号和无符号的概念？

	5.单精度和双精度概念

	*git问题：
	 1,如果你还没有commit  这样操作  git pull ，git add,  git commit -m "" , git push

	2:如果你已经commit了  这样操作  git pull,  git commit(这个commit是把你刚才pull的内容合并）,git push
	
### 2.1.3 寻址和字节顺序
	1.跨越多字节的程序对象，这句话的多字节如何理解？

	2.C语言，
	int a = 100; //定义一个int值
    int *ap ;//定义一个int类型的指针
    ap=&a;//ap是一个地址，*ap是一个值

	printf("%p\n",&a);//输出的是a变量的地址
    printf("%p\n",ap);//通过指针变量ap输出a变量的地址
    printf("%p\n",&ap);//指针变量ap本身自己的地址
    printf("%d\n",*ap);//输出：100
    printf("%p\n",&*ap);//

   	那ap本身也有地址，也可以定义指针指向这个地址。无限循环？？？

   	3.大端法和小端法
   		小端法：
   		  某些机器选择按照最低的有效字节到最高的有效字节的顺序存储对象
  		大端法：
   		 而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。

	4.字节顺序造成的问题：网络传输中从小端法机器，传输到大端法机器，接收的结构对于大端来说是反的，需要反转。

	5.C语言基础：
		指针：
		地址：
		printf格式化输出：
		数组：C语言中可以用数组表示法来引用指针

	6. C整数的不同进制表示有什么用？
	int val = 0x123456;	//16进制
	int val = 123456;	//10进制
	int val = 0123456;	//8进制

	十六进制、八进制、十进制、二进制，只是表示方法而已，在计算机里面用的都是二进制的，而十六进制恰好是2的4倍，表示一个字节的时候仅仅需要2个十六进制数就可以表示出来，因此多数用2个十六进制来表示一个字符，看上去比较清晰

	例如：
	二进制:		0010 0010
	十六进制：  22
	十六进制在可能牵扯到位操作的时候，更加直观，因为一个数字代表4位二进制0或1
	例如 0x02 相当于 00000010 ，而十进制就没有那么直观

	7.进制转换？
	二进制，八进制，十进制，十六进制

### 2.1.4 表示字符串
	1.C中字符串被编码为一个以null（值为0）字符结尾的字符数组。

### 2.1.5 表示代码
	1.二进制代码是不兼容的，很少能在不同机器和操作系统之间移植。

 ## 读后感：p27-p34,7页，一个半小时，查阅了大量的概念性的东西，对于进制还是有一定的不理解，应该是没有实际运用的原因导致。

---- 06.03 结束 ----

---- 06.04 开始 ----

### 2.1.6 布尔代数
	1.概念：二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。这起源于1850年前后乔治·布尔的工作，所以叫做布尔代数。

	2. 二进制1和0表示逻辑值TRUE和FALSE

	3.运算符含义：
	  ~	非，取反？
	  &	同时为真
	  |	有一个为真
	  ^	如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

	4.位向量：固定长度位w、由0和1组成的串

	5.练习题2.9，答案是正确的
		A.补代表打开关闭的，关闭打开的，那么8种颜色的补：就是0变1，1变0？
		比如黑色：000变为111，红色：100变为011.

		B.蓝色 | 绿色 = 001 | 010 = 011.
		  红色 ^ 红紫色 = 100 ^ 101 = 001. (两个位不同才是1)

### 2.1.7 C语言中的位级运算
	1.C语言支持布尔运算

	2.确定一个位级表达式的最好方法，就是将十六进制的参数扩展成二进制表示，并执行二进制运算，然后再转换回十六进制。

	3.位运算的一个常见用法是掩码运算。
	什么是掩码？

	4.原码反码补码
	掩码：是一个位模式，表示从一个字中选出的位的集合。

	5.

### 2.1.8 C语言中的逻辑运算
	1. || && ！ 运算符

	2.逻辑运算符和位运算符很容易混淆，有什么区别？
		a.针对数据类型不同：逻辑针对boolean值
		b.逻辑运算符存在短路现象
		c.表现形式不同：
			位运算：&、|、~、！
			逻辑运算： && 、|| 、！
		d.功能是完全不同的

## 逻辑和位运算符这个问题还要继续搞明白，学习C语言的时候吧。

	3.十六进制和二进制的转换：对应的表格。
		0x66		0110 0110
		解析：6对应0110

		0x6F		0110 1111
		解析：6对应0110 F是十进制的15转二进制8+4+2+1 刚好对应1111.
		书中有对应的表格！！！

### 2.1.9 C语言中的位移运算
	1.c语言提供位移运算，向左或者向右移动位模式。
		C的左移：x << k,x左移k位，则x像左移动k位，丢弃最高的k位，并在右端补上k个0.
		c的右移：分两种情况
			a.逻辑右移
				右移k位，并在左端补k个0
			b.算术右移
				右移k位，并在左端补上k个最高有效位的值（最高位那个值）
			举例：10010101 算术右移4位， 则先右移4位变1001，然后再左边补上1111（最高位是1，所以补1），结果是11111001

			01101100 算术右移4位，先右移4位变0110，再补上4个最高位那个值0000，结果是 00000110.

	2.java比较简单，就一种移动多少位，就补上多少个0

	3.如果是超大数，c用w组成的数据，移动k为（k>w）,也就是超过了本身的位数，就只需要求模 k % w 的位数，
		java也是求模！

	4.k mod w  ，mod就是求模！！
		log(2)w 的含义，数学问题！！就是2的多少次方等于w

	5.c语言中优先级位移低于加法或减法
	如 1<<2+3<<4 ，本意是 (1<<2)+(3<<4),实际执行结果却是：
	(1<<(2+3))<<4，所以c语言中加上括号就可以解决优先级的问题。
## 0604感想，p34-p41页，做了课后习题，学习3小时左右。      今天读的是 位移、布尔运算、逻辑运算等大量运算相关的概念。         	尽量让阅读有延续性！！还需要多次重复回看笔记才能看懂。另外c语言没有基础也是硬伤！！  										有收获，以前很多不懂的概念性问题都找到了答案，继续加油！！

---- 06.04 结束 ----

---- 06.05 开始 ----
### 2.2 整数的表示
	1.整数的数据与算术操作术语。看书中的表格：p42

### 2.2.1 整形数据类型
	1.C语言支持多种整形数据类型：表示有限范围的整数

	2.[signed] char	 有符号char  范围：-128~127
	  unsigned char	 无符号char  范围：0~127
	注意：有符号数据类型取值范围，负数比整数会大1，并不是对称的。学习负数的表示的时候就知道了为什么这样。

	3.唯一一个与及其有关的long，在32位和64位的机器上，典型取值范围是不同的。

	4.unsigned 非负数需要声明
	  或者默认是有符号负数（默认）
	
	5.C语言的典型取值范围和保证取值范围的区别？
	典型取值范围：针对不同的机器字长，
	如32位 long 的典型取值范围是 -2147483648 ~ 2147483647
	  64位 long 的典型取值范围是 -9223372036854775808 ~ 
	  9223372036854775807
	
	保证取值范围：就是C语言标准要求这些数据类型必须至少具有这样的取值范围。
	long 取值范围：-2147483647 ~ 2147483647 （对称的和不对称的都有）

	6.c和c++都支持有符号（默认）和无符号数。
		java只支持有符号数。

### 2.2.2 无符号数的编码
	1.∑ 读作Sigma，表示求和符号
	B2Uw（x向量）将一个长度为w的0、1串映射到非负整数

	0001 = 0·2·2·2 + 0·2·2 + 0·2 + 1·2(0) = 1;//二进制转化为整数。原来可以有公式的！！
		p44页

	2.原理：无符号数编码的唯一性
		解释：十进制的数11，只有一个4位的表示方式1001。
	
	3. B2Uw是一个双射， y=f(x) 也可以表示为 x = f(-1)(y),-1次方表示反过来。！！

	唯一性：B2Uw 和 U2Bw 都具有唯一性的表示。
	二进制转无符号数，无符号数转二进制都是唯一

### 2.2.3 补码编码
	1.补码定义：
	最常见的有符号数的计算机表示方式就是补码

	2.通过补码公式：B2Tw 二进制转补码
	
	 第一位  -x(w-1)位·2(w-1)次方
	因为前面是负号，所以负数的最高位是1，整数的最高位是0.来表示有符号数。

	3.最高有效位也称为符号位

	4.补码的计算,公式、表、图都能看懂，但是不知道为什么这样写?

	5.补码彪马具有唯一性
		公式的表示的意思都在p42图2-8

	6.整数的补码是它本身，负数的补码 等于？

	7.补码的取值范围 TMinw ~ TMaxw
	以长度为4为例：Tmin4 = B2T4([1000]) = -2^3 = -8
				  Tmax4 = B2T4([0111]) = 4+2+1 = 7

		
	
（1个小时，无符号、无符号数编码，才看了3页，很多数学符号）
## 高数很重要呀！！！

今天看到练习题 2.1.7，未看完，明天继续


## 阅读感受：高数对于看懂公式还是很重要的，比如求和，向量等等,还有以前碰到的log对数

---- 06.05 结束 ----


---- 06.06 开始 ----

	8.今天继续练习题 2.1.7 做完了
	十六进制 对应的二进制，转无符号数/转补码

	9.表格 2-14解释

	关于字长：8位，UMax(8)  最大值就是 8个二进制最大值 [1111 1111] = 128+64+32+16+ 8+4+2+1 = 255,十六进制 表示就是0xFF,一个十六进制代表4个二进制位。

	TMin(w): 补码最小值，为什么是，8位的： 0x80

	答案：0x80=10000000,0xF0=11110000,根据有符号数的定义或者运算算一下就知道啦  0x80 会比0xF0更小。！！

	10.补码中TMin没有与之对应的正数。因为补码能表示的正数比负数少一个。这会造成程序中细微的错误。

	11.最大的无符号数值刚好比补码的最大值的两倍大一点。
	UMax(w) = 2TMax(w) +1; 从表中看出来的结论

	13.负一（-1） 和 UMax(w) 有相同的表示 
	比如 8字节 -1 的十六进制表示：0xFF

	14.所有现代机器都使用补码。

	15. 练习题 2.1.8 没看懂答案！！

	指令名 （32位补码表示的）十六进制值 转换为等价的10进制：


	16.使用宏能保证：不论代码是如何被编译的，都能生成正确的格式字符串。


### 2.2.4 有符号数和无符号数之间的转换
	1.C语言允许在各种不同的数字类型之间做强制类型转换。
	2.c语言强制类型转换，会改变数值，但是不会改变位表示。
	3.无符号数和补码之间的互相转换的结果：
	 0 <= x <= TMax(w) ,相互转换是本身。
	 范围外的数 ，需要加上或者减去 2^w .

	个人思考：公式暂时不用记着，先直接推倒---先转为二进制，再转成对应的目标值。
	比如 -1 ,补码转有符号数，-8+4+2+1 = [1111] = 8+4+2+1 = 15

### 2.2.5 C语言中的有符号数和无符号数
	1.几乎所有的机器，有符号数都采用补码的形式计算。
	2.要创建无符号数，后面需要加上u，如12345u
	3.显式的强制类型转换会导致转换的发生
		int tx,ty;
		unsigned ux,uy;
		tx = (int) ux;	//无符号数转有符号数
		uy = (unsigned) ty;//有符号数转无符号数

		或者下面这种隐式转换
		int tx,ty;
		unsigned ux,uy;
		tx = ux;	//无符号数转有符号数
		uy = ty;//有符号数转无符号数

	4.%d 有符号十进制
	  %u 无符号十进制
	  %x 十六进制

	5.如果无符号数和有符号数进行运算，C语言会强制有符号变成无符号数，并假设这两个数都是非负的。

	0 == 0U  ，左边的0会变成无符号数，1;

### 2.2.6 扩展一个数字的位表示
	1.一个无符号数转换为更大的数据类型，只要在开头添加0，这就叫做零扩展(zero extension)

	2.一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展(sign extension),在表示中添加最高有效位的值。前面补上几位
	![avatar](zhouxingui/字数据大小.png)

## 阅读感受：周六三个小时看书，连续性的时间看书效率更高，当然 也更累一些。还是基础不牢。加油！！

---- 06.06结束 ----
---- 06.07开始 ----
 ## 今天周日下午，路哥直播链表的实现，手把手敲代码，对我这种没基础的人很有用，很生动。感受：思路是第一位的，还有正确率，手速、敲键盘速度什么的放在其次。

	3.