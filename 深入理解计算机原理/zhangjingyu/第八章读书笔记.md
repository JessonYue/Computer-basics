##异常控制流  
系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流  

###异常  
异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的  
异常（exception)就是控制流中的突变，用来响应处理器状态中的某些变化。当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 在处理器中，状态被编码为不同的 位和信号。状态变化称为事件（event)。事件可能和当前指令的执行直接相关（比如除0，算术溢出）。也可能和当前指令的执行没有关系（比如一个I/O信号）。当处理器检测到有事 件发生时，它就会通过一张叫做异常表 (exception table)的跳转表，进行一个间接过程调用（异常)，到一个专门设计用 来处理这类事件的操作系统子程序  
当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：  
1、返回当前指令 2、执行下一条指令 3.终止程序  

###异常处理  
系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号。在系统启动时（当计算机重启或者加电时)，操作系统分配和初始化一张称为异常表的跳转 表，使得条目k包含异常k的处理程序的地址。在运行时（当系统在执行某个程序时)，处理 器检测到发生了一个事件，并且确定了相应的异常号。随后，处理器触发异常，执行间接 过程调用，通过异常表的条目转到相应的处理程序。异常号是到异常表中 的索引，异常表的起始地址放在一个叫做异常表 基址寄存器（exception table base register)的特殊CPU寄存器里  
•过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中  
•处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序 会需要这些状态  
•如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到 用户栈中。  
•异常处理程序运行在内核模式下（见8.2.4节)，这意味着它们对所有的系统资源都有完全 的访问权限。  

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之 后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的 状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用 户模式，然后将控制返回给被中断的程序  

###异常的类别  
1.中断

中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条

专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序  

处理器注意到中断引脚的电压变 高了，就从系统总线读取异常 号，然后调用适当的中断处理程 序。当处理程序返回时，它就将 控制返回给下一条指令（即如果 没有发生中断，在控制流中会在 当前指令之后的那条指令）。结 果是程序继续执行，就好像没有 发生过中断一样  

2.陷拼和系统调用

陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制 返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫 做系统调用。  

用户程序经常需要向内核请求服务，比如读一个文件（read)、创建一个新的进程 (fork)、加载一个新的程序（execve),或者终止当前进程（exit)。为了允许对这些内核服 务的受控的访问，处理器提供了一条特殊的“syscallw”指令，当用户程序想要请求服务《 时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序 对参数解码，并调用适当的内核程序

3.故障  

故障由错误情况引起,它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移 给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从 而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序

4.终止

终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位 被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序

##进程  

当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当 前运行着的唯一的程序。我们的程序好像是独占地使用处理器和存储器。处理器就好像是无间断 地一条接一条地执行程序中的指令。最后，我们程序中的代码和数据好像是系统存储器中唯一的 对象。这些假象都是通过进程的概念提供给我们的。

进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上 下文（context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器 中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件 描述符的集合

关注进程提供给 应用程序的关键抽象：

•一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。

•一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。

###逻辑控制流  

进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（preempted)(暂时挂起），然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占时间地使用处理

###并发流  

一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrentflow),这两个流被称 为并发地运行  
多个流并发地执行的一般现象称为并发（concurrency)。一个进程和其他进程轮流运行的 概念称为多任务。每个进程执行它的控制流的一部分的每一时间段叫做时间片 (time slice)。因此，多住务也叫做时间分片  

###私有地址空间

进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。一个进程为每个程序提供它自己的 私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读 或者写的，从这个意义上说，这个地址空间是私有的。

###用户模式和内核模式

处理器必须提供一种机制，限制一个应 用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用某个控制寄存器中的一个模式位（modeWt)来提供这种功能的,该寄存器 描述了进程当前享有的特权

###进程控制  

从程序员的角度，我们可以认为进程总是处于下面三种状态之一：

•运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。

•停止。进程的执行被挂起（suspend),且不会被调度。当收到SIGSTOP、SIGTSTP、 SIDTTIN或者SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个SIGCONT 信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中详细 描述。）

•终止。进程永远地停止了。进程会因为三种原因终止：1)收到一个信号，该信号的默认 行为是终止进程，2)从主程序返回，3)调用exit函数。

父进程通过调用fork函数创建一个新的运行子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同 的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程 任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中 打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。

在父进程中,fork返回子进程的 PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方 法来分辨程序是在父进程还是在子进程中执行。  

####回收子进程  

如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排init进程来回收它们。（可以利用这个机制在安卓中使用一个进程crash异常报告） 

####进程休眠

sleep函数将一个进程挂起一段指定的时间。如果请求的时间量已经到了，sleep返回0,否则返回还剩下的要休眠的秒数。很有用的另一个函数是pause函数，该函数让调用函数休眠，直到该进程收到一 个信号

####加载并运行程序  

execve函数在当前进程的上下文中加载并运行一个新程序。execve函数加载并运行可执行目标文件filename,且带参数列表argv和环境变量列表 envp。只有当出现错误时，例如找不到filename, execve才会返回到调用程序。所以，与 fork—次调用返回两次不同，execve调用一次并从不返回 

###信号 

我们将研究一种更高层的软件形式的异常，称为Unix信号，它允许 进程中断其他进程。

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。

每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常 情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比 如，如果一个进程试图除以0,那么内核就发送给它一个SIGFPE信号  

在任何时刻，一种类型至多只会有 一个待处理信号。如果一个进程有 一个类型为A的待处理信号，那么 任何接下来发送到这个进程的类型 为灸的信号都不会排队等待，它们只是被简单地丢弃

###发送信号  

Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group)这个概念的。

每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。getpgrp函数 返回当前进程的进程组ID。setpgid函数将进程pid的进程组改为pgid。如果pid是0,那么就使用当前进程的PID。 如果pgid是0,那么就用pid指定的进程的PID作为进程组ID

用/bin/kill程序发送信号

/bin/kill程序可以向另外的进程发送任意的信号。

从键盘发送信号

Unix外壳使用作业（job)这个抽象概念来表示为对一个命令行求值而创建的进程。在任何 时刻，至多只有一个前台作业和0个或多个后台作业。比如，键入

unix> Is I sort

创建一个由两个进程组成的前台作业，这两个进程是通过Unix管道连接起来的：一个进程运行 Is程序，另一个运行sort程序。

用kill函数发送信号

进程通过调用kill函数发送信号给其他进程（包括它们自己)。


