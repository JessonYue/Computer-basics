#  链接

链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文 件可被加载(复制)到内存并执行。

##  编译驱动是怎么工作的

创建了两个c程序源文件：main.c和swap.c，先是由预处理器（cpp）将main.c翻译成中间文件：main.i，接下来是编译器（cc1）将main.i翻译成汇编文件main.s。然后是汇编器（as）将main.s翻译成一个可重定位的目标文件main.o。最后由链接器（ld）将main.o和swap.o以及一些系统目标文件组合起来，创建可执行目标文件p，链接的在这个过程的主要工作就是符号的解析和重定位。

## 链接器操作的目标文件ELF

.text：已编译程序的机器码；.rodata：只读数据（read-only-data）；

.data：已初始化的全局C变量；.bss：未初始化的全局C变量（better save space）;

.symtab：一个符号表（定义和引用的函数和全局变量信息）；

.rel.text：代码重定位条目， 一个.text节中位置的列表，需要修改的位置;

.rel.data: 被模块引用或定义的任何全局变量的重定位信息；

.debug：一个调试符号表； .line：原始C源程序中的行号和.text机器指令的映射；

.strtab: 一个字符串表

在.symtab中的是一个符号表，其是定义和引用函数和全局变量的信息。有三种不同类型的符号：全局符号（不带static），外部引用（external）和本地符号。如果是带有static符号的就会在.data和.bss中为每个定义分配空间，并在.symtab中创建一个唯一名字的本地符号。

##  链接器工作的流程

### 1、符号解析

符号解析任务简单的说，就是链接器使得所有模块中的每个符号只有一个定义。链接器在这一个阶段的主要任务就是把代码中的每个符号引用和确定的一个符号定义联系起来。对于本地符号，这个任务相对来说是简单的。复杂的就是全局符号，编译器（cc1）遇到不是在当前模块中定义的符号时，会假设该符号的定义在其他模块中，生成一个链接器符号交给链接器处理。如果链接器ld在所有的模块中都找不到定义的话就会抛出异常。

### 2、链接器解析多重定义的全局符号

使用3个规则：规则一：不允许多个强符号；规则二：如果有一个强符号和多个弱符号，那么选择强符号；规则三：如果有多个弱符号，那么这些弱符号中任意选择一个。

### 3、链接和解析静态库

像printf等一些常用的函数，都是在libc.a静态库中，静态库以一种存档的特殊文件（.a）格式，将可以定位的目标文件集合成一个.a文件。解析静态库的过程是按照命令行标识的文件顺序从左到右解析，如果输入文件是一个目标文件(.o)，那么将文件添加到集合E（合并成执行文件）；如果f是一个存档文件（.a），那么就尝试解析集合U（未解析的符号），能够解析的话就将其加载到集合E中去；重复这样的过程直到都解析完毕。

### 4、重定位

完成了符号解析以后，链接器的第二个任务就是合并输入模块，并为每个符号分配运行时的地址。重定位节和符号定义：在这一步中，链接器将所有模块中的.data节合并成一个文件的.data节，运行时存储器的地址也会赋给新的聚合节。然后就是，重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。重定位的步骤分为：1、重定位条目。2、重定位符号引用。

## 链接器工作后生成的目标文件ELF

ELF是一个典型的可执行文件，ELF头部是描述文件总体格式，标注出程序入口点；.init：定义了初始化函数，段头部表是可执行文件是一个连续的片，段头部表中描述了这种映射关系。

对于ELF的文件在段头部表中，我们会看到程序初始化为两个存储器字段，行1和行2是代码段，有读和执行的权限（flags：r-x），开始于存储器地址0x08048000处（vaddr/paddr），该字段大小为0x448（memsz），并且初始化为可执行目标文件的头0x448个字节（filesz）；行3和行4是数据段，有读写的权限（flags），开始于存储器地址：0x08049448处，总大小0x104个字节（memsz），从文件偏移0x448（off）处开始的0xe8（filesz）个字节初始化。

## ELF是怎样被加载的

当加载器运行时，就先创建一个存储器映像，在ELF可执行文件头部表的指示下，加载器将可执行文件的代码和数据段拷贝到0x0804800处向上的两个段中，然后跳转到程序入口点_start（在ctrl.o中定义）开始执行。

## 为什么需要动态链接共享库

静态库需要定期的维护和更新，调用的代码还会拷贝到每个运行的进程中去，这是对存储器系统资源的极大浪费。为了弥补这样的缺陷，我们发明了共享库。共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，节约资源。以(.so)结尾的文件，在运行时被加载到任意存储器地址，并和存储器中的程序链接起来，以后的进程要用到这个库就从这个固定的位置开始访问。





