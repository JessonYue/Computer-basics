# 第四章：处理器体系结构

阅读第四章的时候自己一个快读，基本就是看了一下大体的概念：
1、了解了Y86-64处理器架构的实现，，由取指阶段，译码阶段，执行阶段，访存阶段，写回阶段以及更新PC阶段。
2、介绍了流水线的原理，通过流水线方法提高了处理器执行指令的速度，并且可以通过HCL语言描述来控制逻辑。
3、觉得这章是不是就是把程序代码最终编译的字节序列转换为Y86-64指令然后让电脑硬件进行执行。



# 第五章：优化程序性能

##  为什么要性能优化？
我的理解是虽然计算机在不断的发展，我们通过硬件设备可以进行性能的一些提升，但是如果我们对软件层进行优化的话，有一些性能的提升是很有显著的效果的。在就编译器的局限可能会使运行的结果不同，我们写代码的时候没有注意到一些细节想循环中多次取值复制等操作，如果次数越多效果越明显。

### 1、编译器的局限性

函数 twiddle2 效率更高一些。它只要求3次内存引用(读*xp, 读*ypÿ 写*Xp), 而twiddlel需要6次(2次读*xp, 2次读 *ypÿ 2 次写*xp)ÿ 因此，如果要编译器编译过程 twiddlelÿ 我们会认为基于 twiddle2 执行的计算能产生更有效的代码。在就是两个指针可能指向同一个内存位置的情况称为内存别名使用，可能会造成运算结果的而不同。这就是编译器的局限性

### 2、不良好代码的逻辑使度量标准CPE增大。

psum2核心的思想就是每次循环计算两个元素p[i]和p[i+1]从而减少了循环的次数，进行提高了程序的性能。

###  3、现代处理器的制约

## 怎么样进行性能优化？

### 1、移动代码消除循环的低效率

​	像在for（i=0;i<length;i++）我们完全可以把长度提出去没必要每次都循环。

### 2、减少函数的调用。

### 3、消除不必要的内存引用。

###  4、理解现代处理器制约性能的关键在哪

###  5、循环展开

​	循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。

###  6、提高并行性

​		因为我们将累积变量放在一个单独的acc中，在前面的计算完成前，不能计算新的acc值。combine6通过将acc = (acc OP data[i]) OP data[i+1];  **转变为：**acc0 = acc0 OP data[i];  和  acc1 = acc1 OP data[i+1];两次循环展开使两路循环并进。而combine6使用了结合的方式将acc = (acc OP data[i]) OP data[i+1]  **变成了** acc = acc OP （data[i] OP data[i+1]），combine7将关键的路径变成了n/2个操作。总的来说通过我们发现**循环展开和并行累积值**在多个变量中，是可靠的提高程序性能的方法。

##  限制程序性能的因素

###  1、寄存机溢出

​	当并行度超过了可用的寄存器数量，那边编辑器就会溢出，将某些临时值存放到内存中，通常是在

运行时堆栈上分配空间，这样的话数据访问时间会更长，性能就会下降，

###  2、分支预测和预测错误处罚

​	 不要过分关心可预测的分支在就是书写适合用条件传送实现的代码。

##  理解存储器性能

### 1、为什么要理解存储器性能

​	我们都是在长度小于 1000 个元素的向量上测试这些合并函数，数据量不会超过 8000 个字节。所有的现代处理器都包含一个或多个高 速缓存(cache)存储器，以对这样少 量的存储器提供快速的访问。研究加载(从内存读到寄存器)和存储(从 寄存器写到内存)操作的程序的性能，来编写高效的代码。

### 2、怎么样理解存储器性能

 1、加载的性能：通过对链表的操作访问，可以看出加载函数对性能的影响。在标号3中，使用movq指令，加载值到rdi寄存器中，而加载操作又依赖于rdi来计算加载的位置，也就是说，必须要等到前一次加载完成才能进行下一次循环。这个函数的CPE等于4也就是说加载的延迟为4.

 2、存储的性能：存储操作并不影响任何寄存器值。因 此，就其本性来说，一系列存储操作不会产生数据相关。只有加载操作会受存储操作结果 的影响，因为只有加载操作能从由存储操作写的那个位置读回值

##  总结

​	我觉得对于我们程序员来说该怎么去优化程序的性能：适当的算法和数据结构，减少函数的连续调用，将一些计算的函数移除循环体的外边，在就是消除不必要的存储器的引用。在就是对于提高并行性的理解，通过并行是这样是我的代码的执行效率更高，以及注意一些限制并行性的因素。

​		