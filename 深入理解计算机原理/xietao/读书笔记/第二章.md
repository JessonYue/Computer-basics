# 第二章
## 2.1信息存储
### 2.1.1
	* 十六进制的表示，理解之所以引入16进制就是因为16进制和二进制之间互相转化的遍历。
### 2.1.2
	* 从32位到64的转变，是指虚拟地址空间变大了，就是指针的最大大小变大。基本数据大小在32位和64位的存在差异。
### 2.1.3
	* 对象存在地址是连续的，分为大端法和小端法，如果是小端法的话对象的地址就是字节中最小的地址。然后就是在网络传输中
	   小端法的字节排序有可能会排成大端法。	
### 2.1.4
	* C语言在编码字符串的时候，会在其尾部添加00以表示这个字符串结束。
### 2.1.5
	* 在不同的机器不同的操作系统上，机器编译的指令编码是不同的。
### 2.1.6
	* 布尔代数的运算中true是1，false是0.然后再就是&，|等一些操作符的用法。还有位向量的用法。
### 2.1.7
	* C语言支持位运算，在位运算中常见的用法就是掩码运算了。
### 2.1.8
	* 需要注意C语言的逻辑运算和位级运算的差异。
### 2.1.9
	* C语言中的移位运算中左移的就是丢弃左边最高位，右端补零。右移运算中分为逻辑右移和算术右移
		逻辑右左端补零，算术右移左端补最高位有效值。


## 2.2整数的表示
### 2.2.1
	* 定义了整数在在32位和62位的取值范围，其中负数的范围比整数范围大1（目前不知道为什么）。在就是c语言也定义了整数的大小的取值范围。
### 2.2.2
	* 无符号编码的是唯一的就是一个无符号的二进制对应一个值，该值也对应一个无符号编码，在就是无符号的编码的具体换算函数。
### 2.2.3
	* 在补码中最高位是1表示负数，0表示负数，以及补码值的函数运算。
### 2.2.4
	* 在计算机中有符号和无符号之间的转化过程中他们的值可能会改变，但是他们的位模式不变。
### 2.2.5
	* 在C语言中允许无符号和有符号之间的转换，但是大多数系统遵循的原则是整数的位表示保持不变。而且在C语言运算中如果有一个数有符号而另一个数
		没有符号，那么C语言会会将有符号的参数转为无符号的进行运算。
### 2.2.6
	* 扩展数字的位，无符号数的用零填充扩展，补码数用的是符号位进行扩展。
### 2.2.7
	* 数字的截断，无符号数就是直接抛弃高位，补码数也是一样的。
### 2.2.8
	*  无符号和有符号之间的由于隐试的强制类型转换导致某些错误，而且这些错误是很难发现的，建议避免这类错误是绝不使用无符号数。

## 2.3整数运算

### 2.3.1 
	* 无符号加法可能会出现算术的移除，例如两个4位长的数相加可能需要5位数进行表示，但是为了显示4位只能丢弃了最高位。
### 2.3.2
    * 补码加法可能出现证溢出出和负溢出，如果是正溢出截断的结果是从和中减去2的w次幂，如果是负溢出截断的结果是和加上2的w次幂。
### 2.3.3
    * 对于一个w位的补码来加法来说，他的最小是取值就是他自己加法的逆（我不知道这个逆是什么意思）。	
### 2.3.4
    * 无符号乘法不用担心会出现位溢出，因为C语言的无符号乘法会产生W为的值，虽然需要2w来表示但是只用低w位的值来表示。
### 2.3.5
    * 补码的乘法截断为W位，就是先计算这个值的摸，然后再把无符号数转换成补码。
### 2.3.6
    * 由于乘法指令在机器上运行太慢了，所以编译器试着用移位和加法组合起来代替乘法。
### 2.3.7
    * 在机器上整数除法更慢，除以2的幂是通过右移来实现的，无符号和补码数分别使用逻辑移位和算术移位来达到目的的。
### 2.3.8
    * 我们在平时的开发无法避免C语言的某些规定，需要我们在整数的运算中，知道无符号和补码的一些运算。
	
## 2.4浮点数
	
### 2.4.1
    * 学习了二进制小数的概念。	
### 2.4.2
    * 介绍了IEEE浮点数表示的一些概念，（这一小节完全是不明白这些概念）。
##  总结：
	* 第二章 让我对计算机中的信息的表示以及一些逻辑运算，对象存在存储时他的地址是怎么表示的，还有一些补码和无符号的一些逻辑运算，还有整数的运算，
			这块我只能知道一些概念，但是具体自己确实没有理解多少，尤其是浮点数完全把我打蒙了。   
	


	
