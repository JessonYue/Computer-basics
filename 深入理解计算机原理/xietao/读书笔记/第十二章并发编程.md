# 并发编程

## 如何实现并发编程

### 1、使用进程实现并发

父进程为客户端 1 创建了子进程之后，它接受一个新的客户端 2 的连接请 求，并返回一个新的已连接描述符(比如描述符 5)，然后，父进程又派生另 一个子进程，这个子进程用已连接描述符 5 为它的客户端提供服务，此时， 父进程正在等待下一个连接请求，而两个子进程正在并发地为它们各自的客户端提供服务。可以同时为多个客服端提供服务，实现进程并发。

进程级并发的一个明显的缺点：各个进程都有独立的地址空间，使得共享信息相当困难而且慢速需要IPC。

### 2、使用IO多路复用实现并发

 I/O 多路复用(I/O multiplexing)技术基本的思 路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O事件发生后，才将 控制返回给应用程序。

优点：1、它比基于进程的设计给了程序员更多的对程序行为的控 制。2、一个基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中 的，因此每个逻辑流都能访问该进程的全部地址空间。

缺点：编码复杂

## 

### 3、使用线程

#### 1、线程执行模型

每个线程在开始的时候都是单一的主线程，这个主线程可以创建对等线程，然后两个线程并发执行，不断的切换上下文，分别执行一段时间。与进程之间不同的是线程的上下文切换要小的多，还有就是线程之间是完全对等的关系，也就是一个线程可以杀死它的对等线程。

#### 2、创建线程

int pthread_create(pthread_t *tid， pthread_attr_t *attr， func *f， void *arg);其中调用成功后tid是运行中的线程ID，attr设置线程默认属性，f是线程函数，arg是传递参数可以使用：pthread_t pthread_self（void）函数获取当前线程的ID。

#### 3、终止线程

原型：int pthread_cancel(pthread_t tid); 终止当前线程

原型：void pthread_exit(void *thread_return);等待所有对等线程终止

#### 4、回收已终止线程的资源

原型：int pthread_join(pthread_t tid， void **thread_return);函数会阻塞，直到线程tid终止并回收所有存储器资源。与wait不同的是该函数只能回收一个特定的线程。

#### 5、分离线程

原型：int pthread_detach(pthread_t tid); 

#### 6、初始化线程

原型：int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

## 多线程程序中的共享变量

### 1、线程内 存模型

寄存器是不共享的，虚拟存储器总是共享的。

### 2、将变量映射到内存

​	1、全局 变量。全局变量是定义在函数之外的变量。在运行时，虚拟内存的读/写区域 只包含每个全局变量的一个实例，任何线程都可以引用。	

​	2、本地自动变量。本地自动变量就是定义在函数内部但是没有 static属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。

​	3、本地静 态变量。本地静态变量是定义在函数内部并有 static 属性的变量。和全局 变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。

	### 3、共享变量

我们说一个变量 是共享的，当且仅当它的一个实例被一个以上的线程引用。

## 用信号量同步线程

### 1、进度图

进度图(progress graph)将 n 个并发线程的执行模型化为一条 n 维笛卡儿空间中的轨 迹线。每条轴々对应于线程々的进度。每个点aÿ 12, ⋯，I,)代表线程々a=i， •，w) 已经完成了指令 h这一状态。

### 2、信号量：非负整数全局变量

信号量s其实就是一个非负整数的全局变量，对这一变量有两个操作：P（s）使得s减1，而V（s）使得s加1。我们操作信号量s的时候，通常的情况是将其初始化为1，执行P操作的时候为加锁，执行V操作的时候为解锁。

### 3、信号量调度共享资源

## 使用线程提高并行性

现在的机器CPU往往是多核的，我们如何利用这个特性变得相当重要。我们这里所的并行是并发的一个子集，代表的是在多核处理器上运行的并发程序。

举个例子：如果我们要计算1,2,3…… 100各个数字相加的和，我们知道经典的答案是：（1+100）*50=5050，我们使用多线程求一个集合数字的和的方法，就是将100个数字分成5个区域，这样每个区域有20个数字，每个对等线程求出5个区域20个数字的和，然后由主线程将不同的和相加，就会得到这100个数字的和。

## 其他并发问题

### 1、线程安全

一个函数被称为线程安全的(thread-safe), 当且仅当被多个并发线程反复地调用 时，它会一直产生正确的结果。如果一个函数不是线程安全的，我们就说它是线程不安全 的(thread-unsafe)。

定义出四个(不相交的)线程不安全函数类：

第 1 类:不 保护共 享变量的函数 。

第 2 类:保持跨越多个调用的 状态的 函数。

第 3 类:返回指向静 态变量的指针的函数。

第 4 类:调用线程不安全函数的函数。

### 2、可 重入性

有一类重要的线程安全函数，叫做可重入函 数(reentrant function), 其特点在于它们具有这 样一种属性:当它们被多个线程调用时，不会引 用任何共享数据。

### 3、在线程化的程序中使用已存在的库函数

大多数 Linux函数，包括定义在标准 C库中的函数(例如 mallocÿprintf和 scanf)都是线程安全的，只有一小部分是例外。

###  4、竞争

当一个程序的正确性依赖于一个线程要在另一个线程到达 点之前到达它的控制流中的 I 点 时，就会发生竞争(race)ÿ 通常发生竞争是因为程序员假定线程将按照某种特殊的轨迹线穿过执行 状态空间，而忘记了另一条准则规定:多线程的程序必须对任何可行的轨迹线都正确工作。

### 5、死锁

信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁(deadlock), 它指的是一 组线程被阻塞了，等待一个永远也不会为真的条件。





​	



