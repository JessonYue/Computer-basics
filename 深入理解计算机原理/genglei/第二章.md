#### 2.1信息存储

机器级程序将内存视为一个非常大的字节数组，成为虚拟内存，内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就成为虚拟地址空间，只是一个展现给机器级程序的概念性映像。
##### 2.1.2 字数据大小
这块有点迷糊，网上查阅了一些信息。
1、字长：在同一时间中处理二进制数的位数叫字长。通常称处理字长为8位数据的CPU叫8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。二进制的每一个0或1是组成二进制的最小单位,称为一个比特（bit）。
　 　一般说来，计算机在同一时间内处理的一组二进制数称为一个计算机的“字”，而这组二进制数的位数就是“字长”。字长与计算机的功能和用途有很大的关系， 是计算机的一个重要技术指标。字长直接反映了一台计算机的计算精度，为适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算， 即机内可实现半字长、全字长（或单字长）和双倍字长运算。在其他指标相同时，字长越大计算机的处理数据的速度就越快。早期的微机字长一般是8位和16 位，386以及更高的处理器大多是32位。目前市面上的计算机的处理器大部分已达到64位。
　　字长由微处理器（CPU）对外数据通路的数据总线条数决定。
2、最小可寻址单位：内存的最小可寻址单位通常都是字节。也就是说一个指针地址值可对应内存中一个字节的空间。
3、寻址空间：寻址空间一般指的是CPU对于内存寻址的能力。CPU最大能查找多大范围的地址叫做寻址能力 ，CPU的寻址能力以字节为单位 （字节是最小可寻址单位），如32位寻址的CPU可以寻址2的32次方大小的地址也就是4G，这也是为什么32位寻址的CPU最大能搭配4G内存的原因 ，再多的话CPU就找不到了。
　　这里CPU的寻址位数是由地址总线的位数决定，32位CPU的寻址位数不一定是32位，因为32位CPU中32的意义为字长。
　　有关寻址范围计算解释，对于32位寻址的CPU，其地址值为32位的二进制数，所以可以表示的最大地址为2的32次方(即4G，最大内存空间为4GB，这里G表示数量、GB表示容量)。同时我们不难看出，一个指针的值就是一个32位的二进制数，32位对应4字节(Byte)。所以，指针的大小实际上是由CPU的寻址位数决定，而不是字长。

　再来分析一下如下的情况：
　　32位处理器上32位操作系统的32位编译器，指针大小4字节。
　　32位处理器上32位操作系统的16位编译器，指针大小2字节。
　　32位处理器上16位操作系统的16位编译器，指针大小2字节。
　　16位处理器上16位操作系统的16位编译器，指针大小2字节。
　　这从结果看起来指针的大小和编译器有关？？
　　实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下：
　　Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节
　　Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节
　　编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。

　　综上可得：
　　指针大小是由当前CPU运行模式的寻址位数决定！

4.有些数据类型的确切字节数依赖于程序是如何编译的。
#### 2.1.3寻址和字节顺序
&x   地址表达式
对象的地址是对应地址数组中最小的地址。

#### 2.2整数
##### 2.2.4有符号和无符号之间的转换
保持位置不变，改变解释行为。
#### 2.4浮点数
此处记录一个转换的方法
将数（20.59375）10转换成754标准的32位浮点数的二进制存储格式。
解：首先分别将整数和小数部分转换成二进制数：
20.59375 = 10100.10011
然后移动小数点，使其在第1、2位之间
10100.10011 = 1.010010011 X 2^4 e = 4
于是得到
S = 0， E = 4 + 127 = 131， M = 010010011
最后得到32位浮点数的二进制存储格式为
0100 0001 1010 0100 1100 0000 0000 0000 = （41A4C000）16

