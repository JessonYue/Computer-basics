# 总结
## 第一章
这一章给出的问题，首先说一下为什么我们需要有这些问题在前，这个地方我们需要带着问题去看书，这就是为什么很多书在第一章给出了各种各样的问题，包括编译提速，编码解码、存储体系、链接原理等等、这一章也是概述的一章、首先给出的问题就能看出来、其次也用简单的语句来表达了整本书的概念
## 第二章(编码和进制)
补码、反码、原码等等是这一章的新概念、2、8、10、16进制也是这一章的主要介绍、首先我们知道计算机是以2进制来表达事物的、所谓1生2，2生3，3生万物，这也是计算机用来表示事物的最好表示、因为所有的事物都能用1、2来表示，这里的3其实是10因为2+1=10，然而对于我们人类来说我们最常用的是10进制，这也让我们并不能理解计算机的2进制，除了这两种还有8进制16进制，还有其他进制，这里不做赘述，在本章中我们需要了解进制之间的转换，原码、补码、反码之间的相互转换、然而这些是什么东西我们需要去了解、这里不做赘述
## 第三章(机器级代码)
在本章中我们需要去了解机器级代码的各方面的观点，其实这个问题，我们知道计算机只能认识0101，这些其实就是我们所熟知的机器码，但是计算机是怎么去区分他们的呢，这里就涉及到一个上下文的问题了，比如一个文本文件，它本身是存在一个上下文的，他的编码格式统一，这样就能识别，我用c语言中的数据类型来举例，比如64位的机器c的int是4个自己也就是32位，指针表示他的地址也就是从哪里开始读，数据类型表示它需要读多长。然而在第三章中也提到了一些相关操作，比如操作数指令符、数据传送指令、压入和弹出栈的数据、算术逻辑操作、有效加载地址、一元二元操作、移位操作、特殊算术操作、控制（条件分支跳转），循环、选择条件语句switch、运行时栈、过程、递归、数组、指针运算、浮点运算等等、还介绍了一些安全方面的知识。在这里也有一个符号表的概念，也就是说不管有文字表还有符号表、还有各种编码表、其实是对照表来生成相应的0101段，在这里我们需要提到的就是特殊字符，比如Java中的public就是一个特殊字符，这个字符并不能当成变量名，这是因为符号表里面存在，如果名字相同则会冲突，在本章中我们需要去了解机器码、甚至了解各种语句翻译出来的机器码
## 第四章(cpu)
在本章中，我们应该去了解各个指令的运作流程，其实我们的cpu是一个寄存器，他用相当复杂的运算来执行各种指令操作，比如汇编的mov、add等等、在这里我们其实不需要过度的了解各个指令的运作，我们需要了解的是arm指令的运作、因为这个能使得我们去了解Android程序的运作流程
## 第五章(优化)
其实本章是对于想进阶架构和测开的人的一个非常感兴趣的一个点，为什么，其实在我们工作当中大多数时候我们会下意识的去检测程序的性能，这个时候在程序性能很糟糕，却束手无策的时候我们是多么需要去了解怎么提升性能，第一这里我们优化程序性能、需要我们真实去了解函数的运行时间、第二、我们需要了解什么函数最省时间、怎样的操作最省时间、最能提升性能。首先就是消除低效率的循环，其次减少过程调用，第三消除不必要的内存引用，第四消除功能单元的性能浪费:整数到浮点数性能增加等等一系列的功能上出现的性能延迟，第五循环展开:增加每次迭代计算的元素数量，减少循环迭代次数，第六提高并行性:并行地去执行程序，第七多个变量累积，第八重新结合变换，最后就是了解各方性能:寄存器、分支、加载、存储。这样我们才能去消除性能瓶颈，所以我们需要在本章中去更加的了解性能的优化，去对比我们函数的执行时间，来增强自己的程序性能
## 第六章(存储)
随机访问存储器:静态、动态、传统的ram，内存模块、增强的ram、非易失性存储器、主存访问，磁盘存储:了解磁盘构造:磁盘由盘片构成，每个盘片有两面、覆盖着记录材料、盘片中有一个主轴、使得盘片以五千四到一万五每分钟的速率转动、就像电视剧里面的留声机一样，了解磁盘容量，了解磁盘操作，逻辑磁盘块，链接io设备，
访问磁盘，固态硬盘:是一种基于闪存的存储技术

存储器层次结构:

↑寄存器(保存从高速缓存中取出的行)

↑高速缓存(L1,高速缓存从L2取出的缓存行) |

↑高速缓存(L2,高速缓存从L3取出的缓存行) |是一块小而快速的存储设备,为更大更慢的设备中的缓冲区域,高速缓存过程称为缓存(缓存命中:当程序需要某个对象时,这个对象正好在缓存中;缓存不命中:查找需要对象,缓存中没有这个对象)

↑高速缓存(L3,高速缓存从主存中取出的缓存行) |

↑主存(DRAM,高速缓存从本地磁盘取出的磁盘块)

↑本地二级存储(本地磁盘,存储着从网络服务器上取出的文件)

↑远程二级存储(服务器)

高速缓存存储器
本章中其实对于这部分存储其实我们现在不是需要特别的了解，大致了解一下他们的存储层次其实就可以了
## 第七章(链接)
链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，编译器驱动程序GCC，链接:静态链接:分两个步骤:符号解析,重定位，目标文件:分三种:可重定位目标文件，可执行目标文件，分享目标文件，符号、符号表:由模块定义并能被其他模块引用的成为全局符号,由其他模块定义并被当前模块引用的全局符号称为外部符号,只被当前模块定义和引用的称为局部符号。这里还需要提到一个概念就是重定向，其实这个词解释很简单，重新定义方向，那这个方向是从哪里来的，其实就是链接的作用，他们链接什么，其实是链接的符号表等等，所以重定向其实就是更改链接地址吧，我是这样理解的，什么是位置无关代码，位置无关，也就是说和他的指针没有关系，所以任何地方读到他那么都是能解释他的意思的，因为这个代码可以用相对寻址找到
## 第八章(异常)
这一章我们需要去了解程序的异常类别，分四种，中断、陷阱、故障、终止，我们在写代码的时候最多的就是终止、因为程序异常了、程序就崩了、故障其实可以理解为警告、陷阱是别人入侵你的时候出现的异常、中断可以理解为usb设备的异常，这里还有一个概念就是进程，进程就是运行中的程序，线程是程序的执行路径、程序是一段规定好的执行路径，在本章中我们还需要了解程序调用的系统错误和回收机制，信号等等的处理，信号其实就是消息
## 第九章(虚拟内存)
首先我们第一章其实就知道了程序在启动过程中会有一个假象，这个假象就是程序好像独立占有一个主存、这个假象就是虚拟内存，虚拟内存有4G，最上面的是内核代码不可修改，下面3G内容分别是堆栈静态常量代码区，这五个区存放着代码中的各种变量常量，这些变量并不是在主存中，但是我们执行需要在主存中，所以在内存需要各个程序的变量的地址时，会从虚拟内存里面来找到这些变量进而利用起来，在本章中我们需要去了解五个区的作用，以级fork函数等的作用
## 第十章(I/O)
我们知道不管是网络还是设备都是文件、这些文件组成了I/O文件，说白了本质上这些就是i/o文件，所以在输出输入这一块我们我们需要去了解文件担任的角色以及文件的操作、i/o函数的相关使用
## 第十一章(网络)
其实本章中在很多地方也有使用，比如Java里面，这个时候我们需要客户端-服务端来做交互，这也是我们这些初级成需要做的最多的一件事情，但是我们还需要来了解其实网络本质上是文件，以及网段和连接函数的使用
## 第十二章(并发)
首先并发是一起触发、有一个相关概念是并行、意为一同执行、这两个虽然意思看上去相同、其实本质上不同，在本章中我们需要了解并发在各个领域的作用以及运作流程