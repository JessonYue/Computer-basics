**信息的表示和处理**

这一章重点讲述了信息的存储方式，整数的表示，整数的运算和浮点数

* 其中整数的表示里包括：

    1、无符号编码

    2、有符号编码

	3、无符号和有符号之间的转换

	4、C语言中有符号数和无符号数

	5、对数字位的扩展和截断

* 整数和运算包括：

	1、无符号数加法

	2、补码加法

	3、补码的非

	4、无符号、补码乘法

	5、乘以常数

	6、除以2的幂

* 浮点数包括：

	1、二进制小数

	2、IEEE浮点数表示

	3、舍入

	4、浮点运算


**程序的机器级表示**

* C代码、汇编代码与机器代码的关系，重申了汇编的承上启下的重要作用

* 介绍了IA32的细节

* 程序编码的过程：
 
     1、C预处理器扩展源代码，插入所有用#include命名指定的文件，并扩展所有用#define声明指定的宏

     2、编译器产生汇编代码（.s文件）

     3、汇编器将汇编代码转化成二进制目标文件（.o文件）

     4、链接器将目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件

* 机器级代码两种重要的抽象：

     1、由指令集体系结构或指令集架构来定义机器级程序的格式和行为

     2、机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组


* 程序内存：
 
     1、程序的可执行机器代码

     2、操作系统需要的一些信息

     3、用来管理过程调用和返回的运行时栈

	 4、用户分配的内存块（比如说用malloc库函数分配的）


**处理器体系结构**

这一章主要讲述了指令系统、硬件控制语言（hcl）、以及流水线的通用原理。

然后我们自己动手实现一个我们自己的86处理器。

其中主要内容包含以下几点：

* Y86指令集：各种状态、指令集、编码、异常处理；

* 逻辑设计和硬件控制语言：逻辑门，集合关系，组合电路

* 流水线通用原理，计算流水线；如何操作流水线，如何处理冒险与冲突

* 动手实现我们自己的Y86：分为顺序实现和流水线实现

# 这一章看的有些懵，感觉便向和硬件打交道方面，所以感觉看完后还是很多不懂，回头看了下大纲，总体梳理了下，只是觉的有一个粗略的印象，细节方面没有掌握 #


# **优化程序性能** #

这一章通篇讲述如何编写出运行快的程序，总的概括下来，主要有三方面的要素：

	1、选择合适的数据结构和算法

	2、充分利用编译器，用有效的方式让编译器进行优化

	3、对于大的程序，可以进行分解

本章的主要内容如下：

* 编译器的局限性

* 表示程序的性能CPE（每元素的周期数）

* 程序的优化过程：
	
	1、原始版本combine1

	2、消除循环的低效率combine2

	3、减少过程调用combine3

	4、消除不必要的内存引用combine4

* 现代编译器的瓶颈

* 循环展开combine5

* 提高并行性combine6

* 理解内存性能

本章的优化程序性能，可以总结以下几点：

	1、选择适当的算法和数据结构

	2、基本编码原则：

		* 消除连续的函数调用，有可能的时候将计算移动到循环体外
		
		* 消除不必要的存储器引用，引入临时变量保存中间值
		
	3、低级优化：

		* 展开循环
		
		* 提高并行，使用多个累积变量或者重新结合


# *存储器层次结构** #

在本章中，我们了解到了：

* 目前已有的存储技术，这些存储器是如何被组织成层次结构的

* 什么是拥有良好局部性的程序以及编写这样的程序需要注意的问题

* 为什么说拥有良好局部性的程序会执行的更快

* 引出高速缓存，并介绍几种高速缓存

1、存储技术：

* 随机访问存储器：静态RAM和动态RAM

* 磁盘存储
	
	1、磁盘构造

	2、磁盘容量

	3、磁盘操作	

	4、连接IO设备

	5、访问磁盘

2、局部性

* 对程序数据访问的局部性

* 取指令的局部性

3、存储器层次结构

* 基本缓存原理

* 缓存命中：当程序需要第k+1层数据块14的时候，程序会在当前存储的k层，寻找块14的数据，刚好14在k层的话，就是一个缓存命中，这比从k+1层读取的速度要快很多

* 缓存不命中：当程序需要访问到块12的时候，在k层没有该数据块，就是一个缓存不命中，这时候就会从k+1层中读取块12将其替换到k层的一个数据块（覆盖或驱逐一个已有的数据块）。程序还是从k层访问块12。

4、高速缓存存储器

* 通用高速缓存存储器内部结构

*　直接映射高速缓存（每个组只有一行的简单访问模式）

	１、组选择：地址位中的组索引匹配高速缓存中的组

	２、行匹配

	３、字选择

*　组相连高速缓存（每组多于1行的高速缓存）

* 全相连高速缓存（只有一个组）：只适合小规模的高速缓存

* 结构剖析

5、编写高速缓存友好的代码

	1、让最常见的情况运行的快

	2、尽量减小每个循环内部的缓存不命中数量

6、高速缓存对程序性能的影响

* 存储器山：存储器的性能不能简单的用一个数字来描述，如果实在要形容的话，是一座时间局部性和空间局部性构成的山

* 排列循环以提高空间局部性


# **链接** #

链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。

这一章主要学习链接器工作的详细原理，这有助于理解一些危险的编程错误、分离编译的过程、作用域的实现以及如何利用共享库等。

* 编译驱动程序

  编译的过程：
	① 由预处理器（cpp）将main.c翻译成中间文件：main.i

	② 编译器（cc1）将main.i翻译成汇编文件main.s

	③ 汇编器（as）将main.s翻译成一个可重定位的目标文件main.o

	④ 最后由链接器（ld）将main.o和swap.o以及一些系统目标文件组合起来，创建可执行目标文件

* 链接器的主要工作:

	① 符号解析。目标文件定义和引用符号，符号解析的目的是将每个符号引用和一个符号定义联系起来；

	② 重定位：把每个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，是的他们指向这个存储器位置，从而实现重定位

* 目标文件

  目标文件一般是由汇编器生成的.o后缀的文件，大概有三种不同的形式：可重定位目标文件；可执行目标文件和共享目标文件

* 符号和符号表

  保存于.symtab中的是一个符号表，其是定义和引用函数和全局变量的信息。有三种不同类型的符号：全局符号（不带static），外部引用（external）和本地符号。如果是带有static符号的就会在.data和.bss中为每个定义分配空间，并在.symtab中创建一个唯一名字的本地符号

* 符号解析

  符号解析任务简单的说，就是链接器使得所有模块中的每个符号只有一个定义。链接器在这一个阶段的主要任务就是把代码中的每个符号引用和确定的一个符号定义联系起来。对于本地符号，这个任务相对来说是简单的。复杂的就是全局符号，编译器（cc1）遇到不是在当前模块中定义的符号时，会假设该符号的定义在其他模块中，生成一个链接器符号交给链接器处理。如果链接器ld在所有的模块中都找不到定义的话就会抛出异常。

* 可重定位
	
	1、重定位条目：.rel.text代表代码重定位条目；.rel.data是已经初始化数据的重定位条目

	2、重定位符号引用

* 可执行目标文件

	1、ELF可执行文件格式：

		ELF头部：描述文件总体格式，标注出程序入口点；.init：定义了初始化函数

		段头部表：可执行文件是一个连续的片，段头部表中描述了这种映射关系；

	2、如何加载可执行目标文件

* 动态链接共享库

	1、编译时加载

	2、运行时加载共享库

* 与位置无关的代码

	1、PIC数据引用

	2、PIC函数调用


# **异常控制流** #

现代系统通过使控制流发生突变来对一此突发情况做出反应，一般而言，我们把这些突变称为异常控制流ECF

* 异常

	1、异常处理

	2、异常类别：中断、陷阱、故障、终止

* 进程

	1、逻辑控制流：程序计数器值的序列

	2、并发流：一个逻辑流的执行在时间上与另一个流重叠

	3、私有地址空间：进程为每个程序提供它自己的私有地址空间

	4、用户模式和内核模式

	5、上下文切换

* 进程控制

	1、获取进程ID：唯一的正数进程ID

	2、创建和终止进程：三种状态：运行、停止、终止

	3、回收子进程：进程由于某种原因终止时，被保持在一种已终止的状态中，直到被父进程回收

	4、主进程休眠：sleep

	5、加载并运行程序

	6、利用fork和execve运行程序

* 信号

	1、信息术语：发送信号和接收信号

	2、发送信号：进程组、用/bin/kill程序发送信号、从键盘发送信号、用kill函数发送信号、用alarm函数发送信号

	3、接收信号

	4、阻塞和解除阻塞信号：隐式阻塞机制、显示阻塞机制

	5、编写信号处理程序：安全的信号处理、正确的信号处理、可移植的信号处理

	6、同步流以避免讨厌的并发错误

	7、显式地等待信号


# **虚拟内存** #

现在的操作系统普遍都支持了虚拟内存，这样做是因为我们同时运行着太多的程序了，就目前我电脑的状态来看，我既要打开浏览器，又要听歌，可能同时还登陆的有QQ，如果不使用虚拟内存4G的内存空间很快就会被耗尽，而一旦没有了内存空间，其他程序就无法加载了。

虚拟内存的出现就是为了解决这个问题，当一个程序开始运行的时候，其实是为每个程序单独创建了一个页表，只将一部分放入内存中，以后根据实际的需要随时从硬盘中调入内容。当然虚拟内存不仅仅只有这个功能，我们的操作系统也是在内存中运行着的，虚拟内存同时还提供了一种保护，这样做其他进程就不会损坏掉系统的内存空间。

* 物理寻址和虚拟寻址

虚拟内存主要是一种地址扩展技术，主要是建立和管理两套地址系统：物理地址和虚拟地址。由虚拟地址空间（硬盘上）装入进程，其实际执行是在物理地址空间（内存上）承载进程的执行。虚拟地址空间比物理地址空间要大的多，操作系统同时承担着管理者两套地址空间的转换。

	1、物理寻址：主存的每个地址都是唯一的，第一个字节地址为0，接下来为2，以此类推。CPU使用这种访问方式就是物理寻址

	2、虚拟寻址：地址总线也不是无限大的，如32位系统，地址总线只能最多访问到4GB的地址内容，于是提出了虚拟寻址

* 虚拟存储器的工作原理

	1、页表：页表是一个存放在内存中的数据结构，MMU就是通过页表来完成虚拟地址到物理地址的转换。这个数据结构每一个条目称为PTE（Page Table Entry），由两部分组成：有效位和n位地址段。有效位如果是1，那么n位地址就指向已经在内存中缓存好了的地址；如果为0，地址为null的话表示为分配，地址指向磁盘上的虚拟内存（pagefile.sys）的话就是未缓存。

	2、命中

	3、缺页：不命中，就是缺页的情况

*　地址翻译

	１、加入高速缓存

	２、加入翻译后备缓冲器TLB：TLB是一个小的、虚拟寻址的缓存，其中每一行都保存一个PTE块，高度相连。主要是提供虚拟地址到物理地址的翻译速度

	３、加入多级页表

*　内存映射

	１、共享对象：一个对象被映射到虚拟存储器的一个区域，这个区域要么是共享对象，要么是私有对象

	２、fork函数：当前进程调用fork函数的时候，内核为新进程创建各种数据结构，并分配PID。

	3、execve函数

	4、mmap函数

* 动态存储分配

  动态存储器分配指的是在程序运行的时候分配额外的存储空间，分配器维护着虚拟存储器中的堆实现这种分配。

	1、显式分配：程序调用malloc和free函数

	2、分配器基础知识

		① 碎片：内部和外部

		① 隐式空闲链表


# **系统级IO** #

Input是指从设备拷贝数据到内存，而Output是从内存拷贝数据到外部设备的过程，我们平时使用的都是语言提供的标准IO库，如printf和scanf，这些是通过内核提供的系统级IO函数来实现的。我们学习系统级的IO，有助于我们理解其他概念，在读取元数据的时候也需要用到系统级的IO。

*　操作文件

	1、打开文件：一个应用程序通过要求内核打开相应的文件，内核将返回一个非负整数，称为描述符，记录打开文件的所有信息：标准输入（描述符0）、标准输出（描述符1）、标准错误（描述符2）

	2、改变当前文件位置：内核保持一个文件的位置k，初始为0，表示从文件开始处偏移的字节数。通过seek操作。

	3、读写文件：读操作就是从文件拷贝n个字节到存储器，如果是从k处开始，就是拷贝k+n为止。文件的大小为m，如果k≥m就会触发（EOF），所有就不需要明确的EOF字符了。写操作就是从存储器拷贝n个字节到文件当前位置k处。

	4、关闭文件：内核释放打开文件时创建的数据结构，释放所有的存储器资源

*　RIO包健壮地读写

	１、无缓冲输入输出：二进制与网络的直接读写

	２、带缓冲的输入输出

*　读取文件元数据

　　文件元数据是指文件本身的一些信息，包含：访问模式、大小和创建时间

*　共享文件

　　理解父子进程共享文件

*　IO重定向

　　重定向允许我们把本来输出到终端的内容，从新定位到磁盘文本中去


# **网络编程** #

网络应用集成了我们已经学到的很多概念：进程、信号、字节顺序、存储器映射、动态分配等，同时客服端-服务器模型是一个新的知识，我们将所有的这些结合起来，创建一个微小的Web服务器，提供浏览器静态和动态的访问。

*　客户端--服务器模型

*　网络

　　网络是连接客户端与服务器之间的通路，对于单个的主机而言，网络只是插在IO总线上的一种，从网络上接收的数据经过适配器-IO总线-桥-存储器总线-主存

*　全球IP因特网

	１、IP地址：IP地址是一个无符号的32位整数

	２、域名：域名是一种将IP地址映射为一组人性化的字符串的机制

	３、因特网的连接：

*　套接字接口

　　客户端：

		１、socket函数：创建一个套接字描述符

		２、connect函数：客服端建立同服务器的连接

　　服务端：

		１、bind函数：高数内核将my_addr中的服务器套接字地址和套接字描述符sockfd联系起来

		２、listen函数：被动的监听，告诉内核被服务端使用

		３、accept函数：等待客户端的连接，创建已连接描述符

*　echo客服端与服务端

*　Web服务器相关知识

	１、基础：Web客户端（浏览器）与服务器之间的交互是基于一个HTTP协议，同常规的FTP协议不同，传输的是超文本标记语言（HTML）

	２、Web服务器发送的内容：是一个MIME类型的序列

	３、HTTP事务：请求和响应

	4、服务动态内容：

		① 浏览器如何将参数传递给服务器

		① 服务器如何将参数传递给子进程

		③ 服务器如何将其他信息传递给子进程

		④ 子进程将输出发送到哪里

* TINY Web服务器

# **并发编程** #

* 使用进程实现并发

	在第十一章里提到实现一个echo服务器，但是只能为一个客户端服务，那么如果想为多个客户提供服务，那么就需要这个服务端在接受客户端的连接请求时，创建相应的新的子进程来为每个客户端提供服务，这就是基于进程的并发。

* 基于I/O多路复用的并发编程

    应用程序在一个进程的上下文中显示的调度它们的逻辑流，逻辑流被模型化为状态机，数据到达文件描述后，主程序显示的从一个状态切换到另一个状态。

	1、响应键盘输入和客服端连接

	2、多路复用实现并发

* 基于线程的并发

	线程是一个运行在进程上下文中的逻辑流，由内核自动调度，集成了多进程与多路复用的优点

	1、执行模型：每个线程在开始的时候都是单一的主线程，这个主线程可以创建对等线程，然后两个线程并发执行，不断的切换上下文，分别执行一段时间。与进程之间不同的是线程的上下文切换要小的多，还有就是线程之间是完全对等的关系，也就是一个线程可以杀死它的对等线程。

	2、创建线程：int pthread_create(pthread_t *tid， pthread_attr_t *attr， func *f， void *arg);

	3、终止线程：
	
		int pthread_cancel(pthread_t tid); 终止当前线程

		void pthread_exit(void *thread_return);等待所有对等线程终止

	4、 回收已经终止的线程：int pthread_join(pthread_t tid， void **thread_return);

	5、分离线程：int pthread_detach(pthread_t tid)

	6、初始化线程：int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

	7、基于线程的并发服务器

* 多线程中的共享变量

	1、线程内存模型：寄存器是不共享的，虚拟存储器总是共享的

	2、将变量映射到存储器：

		全局变量：如ptr，可以使得本地变量msgs变成了共享

		本地自动变量：如myid是不能共享的，每个线程的myid都不一样

		本地静态变量：加入static如cnt，只有一个实例，两个对等线程访问的是同一个地方

	3、共享变量：被1个以上的线程访问过的变量，如cnt

* 用信号量同步线程

	1、进度图

	2、信号量：非负整数全局变量

	3、信号量调度共享资源：

		生产者——消费者问题

		读者——写者问题

	4、实现预线程化的并发服务器


* 使用线程提高并行性

* 其他并发问题

	1、线程安全：
		
		不保护共享变量的函数；

		保持跨越多个调用状态的函数（rand、srand）

		返回指向静态变量指针的函数（ctime）；

		调用线程不安全函数的函数；

	2、竞争

	3、死锁

# **整本书，总算看完了，但是对于有些章节的内容，还要看第二遍第三遍，以达到真正掌握。读书是一个贵在坚持的过程，如逆水行舟，不进则退，所以在接下来的时间里，更加督促自己和组内的其他学员，克服困难，共同进步。** #

