# **第十二章 并发编程** #

* 使用进程实现并发

	在第十一章里提到实现一个echo服务器，但是只能为一个客户端服务，那么如果想为多个客户提供服务，那么就需要这个服务端在接受客户端的连接请求时，创建相应的新的子进程来为每个客户端提供服务，这就是基于进程的并发。

* 基于I/O多路复用的并发编程

    应用程序在一个进程的上下文中显示的调度它们的逻辑流，逻辑流被模型化为状态机，数据到达文件描述后，主程序显示的从一个状态切换到另一个状态。

	1、响应键盘输入和客服端连接

	2、多路复用实现并发

* 基于线程的并发

	线程是一个运行在进程上下文中的逻辑流，由内核自动调度，集成了多进程与多路复用的优点

	1、执行模型：每个线程在开始的时候都是单一的主线程，这个主线程可以创建对等线程，然后两个线程并发执行，不断的切换上下文，分别执行一段时间。与进程之间不同的是线程的上下文切换要小的多，还有就是线程之间是完全对等的关系，也就是一个线程可以杀死它的对等线程。

	2、创建线程：int pthread_create(pthread_t *tid， pthread_attr_t *attr， func *f， void *arg);

	3、终止线程：
	
		int pthread_cancel(pthread_t tid); 终止当前线程

		void pthread_exit(void *thread_return);等待所有对等线程终止

	4、 回收已经终止的线程：int pthread_join(pthread_t tid， void **thread_return);

	5、分离线程：int pthread_detach(pthread_t tid)

	6、初始化线程：int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

	7、基于线程的并发服务器

* 多线程中的共享变量

	1、线程内存模型：寄存器是不共享的，虚拟存储器总是共享的

	2、将变量映射到存储器：

		全局变量：如ptr，可以使得本地变量msgs变成了共享

		本地自动变量：如myid是不能共享的，每个线程的myid都不一样

		本地静态变量：加入static如cnt，只有一个实例，两个对等线程访问的是同一个地方

	3、共享变量：被1个以上的线程访问过的变量，如cnt

* 用信号量同步线程

	1、进度图

	2、信号量：非负整数全局变量

	3、信号量调度共享资源：

		生产者——消费者问题

		读者——写者问题

	4、实现预线程化的并发服务器


* 使用线程提高并行性

* 其他并发问题

	1、线程安全：
		
		不保护共享变量的函数；

		保持跨越多个调用状态的函数（rand、srand）

		返回指向静态变量指针的函数（ctime）；

		调用线程不安全函数的函数；

	2、竞争

	3、死锁

