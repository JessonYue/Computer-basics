## 深入理解计算机系统总结

### 第一章 计算机系统漫游



##### 计算机数据含义

​	计算机信息基本都是使用0,1二进制进行数据保存，本身不具有特殊含义。这些数据的解析需要配合上下文环境，比如：**ascII码**，就是用固定的二进制转换成的10进制代表不同字符含义。比如：java字节码，每一个class文件，也都是二进制组成，如果要 解析就要按字节码文件格式按长度解析。elf文件开头也是固定16字节魔术内容。开头都是讲述文件重要的信息内容。



##### C程序文件的编译过程

![1](https://upload-images.jianshu.io/upload_images/1829481-f6bc11d4254c5c5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 源程序文件通过预处理器进行文件内容引用的替换后生成 点 i 程序文件
2. 点 i 文件通过编译器编译生成点 a 的汇编文件
3. 点 a 文件通过汇编器生成点 o 的可重定位目标程序
4. 点 o 文件最后通过链接器生成最终的目标可执行程序



##### 计算机系统抽象

- 进程是操作系统对一个正在运行的程序的一种抽象。一个进程可以由多个线程执行单元组成。
- 虚拟内存是一个抽象的概念，它为每一个进程提供了一个抽象，即每个进程都在独占的使用主存。
- 文件是一个简单而精致的概念非常强大，它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。



### 第二章 信息的表示和处理



##### 信息的存储

- 大多数计算机都是以8位的块表示一个字节，作为最小的可寻址内存单元，而不是直接访问位。
- 机器级程序将内存当成一个非常大的字节数组，称为虚拟内存。
- 虚拟内存具体实现为，存储器，闪存，磁盘，特殊硬件和操作系统软件的结合，为程序提供一个很大的数组。

**寻址和字节顺序**

![](https://upload-images.jianshu.io/upload_images/1829481-0a5718c8ba4e08ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





##### c**语言中的逻辑运算**

![/image/9.png](https://upload-images.jianshu.io/upload_images/1829481-5807ddae57a0a236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<!--重点要看文字中true和false的表示-->

因为表示方式限制了浮点数的范围和精度，所以只能近似的表示实数，一般都会进入舍入。舍入四种方式：

![/image/13.png](https://upload-images.jianshu.io/upload_images/1829481-72e6dda00f3feb19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<!--向偶数舍入，感觉类似四舍五入-->



### 第三章 程序的机器级表示



##### c语言中数据表示

![/image/14.png](https://upload-images.jianshu.io/upload_images/1829481-d905eafdbee4f6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### x86寄存器介绍

![/image/15.png](https://upload-images.jianshu.io/upload_images/1829481-9797923bc964a5ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



**当参数过多，寄存器无法存放时，使用栈保存在程序数据区里，栈通过栈指针进行控制。**



##### 循环的汇编类似goto语句方式

![](https://upload-images.jianshu.io/upload_images/1829481-6654549d336f0408.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 数组分配和结构体

在内存中分配时类似，都是连续地址存放。（此处内存指虚拟内存）



### 第四章 处理器体系结构

##### **本章讲解处理器体现结构，关键知识点：**

- 精简指令集RISC和复杂指令集CISC.他们的区别主要是指令数量上有所不同，详情参考书中表格，各有优缺点。
- 处理器流水线操作。
- 处理器流水工作原理，以实现并行效果。
- 处理器如何处理流水线过程中出现的冒险问题。数据冒险解决方式：1.暂停方式，2.数据转发，3.暂停加数据转发。控制冒险解决方式：通过插入气泡的方式。
- 在解决控制冒险的过程中，一般处理器会进行预判，如果预判错误就会造成时间惩罚。个人理解这个时间惩罚是指插入气泡，但是没有进行实践的运算导致的时间性能上的浪费，并不是会照成时间延迟。



### 第五章 优化程序性能



**本章的核心思想就是在编写代码时劲量写出编译器可以进行优化的写法。**



##### 1.消除循环中的低效率

比如for循环中，长度的判断，不要写在判断表达式中，在循环之前计算一次，后面直接使用，能提高很多效率。



##### 2.减少过程调用

过程调用会带来开销 ，而且妨碍大多数形 式的程 序优化



##### 3.消除不必要的内存引用

书中例子为每次循环时都给指针赋值，如果用一个临时变量代替在循环中赋值，等待循环完成后再最后赋值，这样可以减少赋值过程中的内存引用



##### 4.循环展开

现代处理器一般都是多线程的，在循环中适当的进行并行计算可以提高效率。



##### 5.应用性能提高技术

*1.高级 设计*。为遇到的问题选择适 当的算 法和数 据结构 。要特 别警觉 ，避免使用那些会 渐进地 产生糟 糕性能 的算法 或编码 技术。

*2.基本编 码原则* 。避 免限制 优化的 因素， 这样编 译器就 能产生 高效的 代码。

- 消除连 续的函 数调用 。在 可能时 ，将计 算移到 循环外 。考 虑有 选择地 妥协程 序的模块性 以获得 更大的 效率。
- 消除不必 要的内 存引用 。引 人临时 变量来 保存中 间结果 。只有 在最后 的值计 算出来时 ，才 将结果 存放到 数组或 全局变 量中。

*3.低级优化* 。结构化代码以利用硬功能。

- 展 开循环 ，降低 开销， 并且使 得进一 步的优 化成为 可能。
- 通过使 用例如 多个累 积变量 和重新 结合等 技术， 找到方 法提高 指令级 并行。
- 用功能性 的风格 重写条 件操作 ，使 得编译 采用条 件数据 传送。



### 第六章 存储器的层次结构



##### 局部性

一 个编写 良好的 计算机 程序常 常具有 良好的 局部性 （locality)。 也就是 ，它 们倾 向于引用 邻近于 其他最 近引用 过的数 据项的 数据项 ，或 者最近 引用过的数据 项本身 。这 种倾向性 ，被称 为局部 性原理 （principle of locality).*. 是一 个持久 的概念 ，对 硬件和 软件系 统的设计 和性能 都有着 极大的 影响。

**局部性通常有两 种不同 的形式 ：时间 局部性（temporal locality) 和空间局部性（spatiallocality)**



##### 编写高速缓存友好的代码

**高速缓存：**紧靠近cpu读写速度也接近cpu速度。但是由于成本原因空间比较小，只能存放少量数据。所以当cpu从高速缓存中读取数据时，如果数据不存在就会导致需要去底层存储读取数据，会耗费时间。

所以如果能让cpu每次读取数据时劲量都有数据就会提高效率。

通过局部性的概念和高速缓存的性质，编写合理的代码劲量符号局部性就可以相对提高工作效率。

比如：如果顺序读取数组就符合空间局部性。如果在循环中通过重复利用局部变量就符合时间局部性。



### 第七章 链接



##### 为了构 造可执 行文件 ，链接 器必须完成两个主要任务

- 符号解析
- 重定位

##### 目标文件的三种形式

*1.可重定位目标文件*

包含二进制代码和数据 ，其形式可以在编译时与其他可重定位目标文件合并起来， 创建一个可执行目标 文件。

*2.可执行目标文件*

包含二进 制代码和数据 其形式可以被直接 复制到内存并执行

*3.共享目标文件*

 一种特殊类型 的可重定位目标文件 ，可以在加载或者运行时被动态地 加载进内存并链接。



##### 静态连接，静态库，动态库

链接过程中与顺序有关，如果顺序不对可能导致对应的信息找不到。

静态链接库在链接时并不是把全部内容都赋值拷贝到目标可执行文件，只拷贝引用到的数据，没有引用的数据不进行拷贝。

在生成静态库时并没有拷贝引用到的内，而是在链接时才回去做。静态库是一组可重定位文件，用来与目标可执行文件进行链接使用，链接后就不需要了

为了解决静态库的缺点，发明了动态链接库。在linux中是。so文件

动态链接库在生成的时候就拷贝了引用的东西。目标程序运行时需要动态库才能正常加载运行

动态链接库在程序执行时动态链接编译，并且可以同时给多个目标可执行文件进行共享使用。

优点，方便库文件更新。多个共享一个库文件，节省磁盘空间。



### 第八章 异常控制流



##### 异常流控制

从给处理器加 电开始 ，直到你断电为止 ，程序计数 器假设 一个值 a1,a2,a3...的序列其中 ，每个 ak 是某 个相应 的指令 Ik 的地址 。每 次从 ak 到 ak+1 的过渡 称为控制转移（controltransfer) 。 这样的控制转移序列叫做处理器的控制流 （flow of control 或 control flow) 。

现代系统通过使控制流发生 突变来对这些 情况做出反应.。—般而言 ，我们把这些突变称为异常 控制流 （ ECF) 。 异常控制 流发生 在计算机系统 的各个层次 。

异常是异常 控制流 的一种 形式，它一部分由硬 件实现 ，一部分由 操作系 统实现 。因为它们 有一部 分是由硬件实 现的， 所以具体细节将随系统的不同而有所不同 。然而 ，对 于每个系 统而言 ，基本的思想都是 相同的 。异常 ( exception ) 就是控制流 中的突变 ，用来响应处理器状态中的某些 变化。

![](https://upload-images.jianshu.io/upload_images/1829481-3eafb6cb4b6104be.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



##### 异常处理

异常可能会难 以理解 ，因为处理异 常需要 硬件和 软件紧 密合作 。

系统中 可能的 每种类 型的异 常都分 配了一 个唯一 的非负 整数的 异常号 （exceptionber)。其中一 些号码 是由处 理器的 设计者 分配的 ，其 他号 码是由 操作系 统内核 （操 作系统常驻 内存的 部分） 的 设计者 分配的 。

前者的示 例包括 被零除 、缺页 、内 存访问违例 、断点以及 算术运 算溢出 。后者的示 例包括 系统调 用和来 自外部 I/O 设备的 信号。

![](https://upload-images.jianshu.io/upload_images/1829481-8f467d593d672073.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

linux中分系统内核和用户模式。通过陷阱，从用户模式进入内核模式。





##### 进程

异常是 允许操 作系统 内核提 供进程 (process) 概念的 基本构 造块， 进程是 计算机 科学中最深刻 、最成功的概念 之一。

系统 中的每 个程序 都运行 在某个 进程的上下文 （context) 中 。上 下文是 由程序 正确运 行所需 的状态 组成的 。这 个状态 包括存 放在内存中的 程序的 代码和 数据， 它的栈 、通 用目的 寄存器 的内容 、程序 计数器 、环 境变 量以及打开 文件描 述符的 集合。

*操作 系统内 核使用 一种称 为上下 文切换 (context switch) 的较 高层形 式的异 常控制 流来实现 多任务 。*

![](https://upload-images.jianshu.io/upload_images/1829481-a35ee324d2b13236.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



##### 信号 

一 种更髙 层的软 件形式 的异常 ，称为 Linux 信号 ，它允许 进程和 内核中 断其他 进程。
一个 信号就 是一条小消息 ，它通 知进程 系统中 发生了 一个某 种类型 的事件 。



### 第九章 虚拟内存

##### 虚拟内存

![](https://upload-images.jianshu.io/upload_images/1829481-42012c8d9b9ee344.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

CPU 通 过生成 一个虚 拟地址 （Virtual AddressÿVA) 来访 问主存 ，这个虚拟 地址在 被送到 内存之 前先转 换成适 当的物 理地址 。将一 个虚拟 地址转 换为物 理地址的任务 叫做地 址翻译 （address translation)ÿ 就像异 常处理 一样， 地址翻 译需要 CPU 硬件和 操作系 统之间 的紧密 合作。 CPU 芯片 上叫做 内存管 理单元 （Memory ManagementUnit,MMU) 的专用 硬件， 利用存 放在主 存中的 查询表 来动态 翻译虚 拟地址 ，该表 的内容 由操作系统 管理。

虚拟内 存被组 织为一 个由存 放在磁 盘上的 JV 个连 续的字 节大小 的单元组成 的数组 。每字 节都有 一个唯 一的虚 拟地址 ，作为 到数组 的索引 。磁 盘上 数组的 内容被缓存在 主存中 。和 存储 器层次 结构中 其他缓 存一样 ，磁盘 （较 低层） 上的数 据被分 割成块 ，这 些块作 为磁盘 和主存 (较 高层） 之间 的传输 单元。 VM 系统通 过将虚 拟内存 分割为 称为虚拟页 （Virtual Page, VP) 的大小 固定的 块来处 理这个 问题。

在任 意时刻 ，虚 拟页面 的集合 都分为 三个不 相交的 子集：

- 未分配的： VM 系统还 未分配 (或者 创建） 的页。 未分配 的块没 有任何 数据和 它们相关联 ，因此 也就不 占用任 何磁盘 空间。
- 缓存的 ：当前 已缓存 在物理 内存中 的已分 配页。
- 未缓存的： 未缓存 在物理 内存中 的已分 配页。

 **VM 简化 了链接 和加载 、代码 和数据 共享， 以及应 用程序 的内存 分配。**



##### 内存映射

Linux 通过 将一个 虚拟内 存区域 与一个 磁盘上 的对象 （object) 关 联起来 ，以初 始化这个 虚拟内 存区域 的内容 ，这 个过程 称为内 存映射 （memory mapping)。虚拟内存区域可以映射到 两种类 型的对 象中的 一种：

1) Linux 文件 系统中 的普通 文件： 一个区 域可以 映射到 一个普 通磁盘 文件的 连续部分 ，例如 一个可 执行目 标文件 。文 件区 （section) 被分 成页大 小的片 ，每一 片包含 一 个虚拟页 面的初 始内容 。因 为按需 进行页 面调度 ，所 以这些 虚拟页 面没有 实际交 换进人 物理内存 ，直到 CPU 第一 次引用 到页面 （ 即发射 一个虚 拟地址 ，落在 地址空 间这个 页面的 范围之内 ）。 如 果区域 比文件 区要大 ，那么 就用零 来填充 这个区 域的余 下部分。

2) 匿名文 件：一 个区域 也可以 映射到 一个匿 名文件 ，匿名 文件是 由内核 创建的 ，包含的全 是二进 制零。 CPU 第一次 引用这 样一个 区域内 的虚拟 页面时 ，内核 就在物 理内存中找到 一个合 适的牺 牲页面 ，如 果该 页面被 修改过 ，就 将这个 页面换 出来， 用二进 制零覆盖 牺牲页 面并更 新页表 ，将 这个页 面标记 为是驻 留在内 存中的 。注意 在磁盘 和内存 之间并没有实 际的数 据传送 。因 为这 个原因 ，映 射到匿 名文件 的区域 中的页 面有时 也叫做 请求二进制 零的页（demand-zero page)。

无论 在哪种 情况中 旦一个 虚拟页 面被初 始化了 ，它就 在一个 由内核 维护的 专门的交 换文件 （swap file) 之间换 来换去 。交换 文件也 叫做交 换空间 （swap space) 或者交 换区域需 要意识 到的很 重要的 一点是 ，在任 何时刻 ，交 换空间 都限制 着当前 运行着的 进程能 够分配 的虚拟 页面的 总数。

一个对 象可以 被映射 到虚拟 内存的 一 个区域 ，要么 作为共 享对象 ，要 么作为 私有对象 。如 果一个 进程将 一个共 享对象 映射到 它的虚 拟地址 空间的 一个区 域内， 那么这 个进程对这个 区域的 任何写 操作， 对于那 些也把 这个共享对象 映射到 它们虚 拟内存 的其他 进程而言 ，也是 可见的 。而且 ，这 些变化 也会反 映在磁 盘上的 原始对 象中。

另 一方面 ，对 于一个 映射到 私有对 象的区 域做的 改变， 对于其 他进程 来说是 不可见的 ，并 且进程 对这个 区域所 做的任 何写操 作都不 会反映 在磁盘 上的对 象中。 一个映 射到共享对 象的虚 拟内存 区域叫 做共享 区域。 类似地 ，也 有私有 区域。

***私有 对象使 用一种 叫做写 时复制 （copy-on-write) 的巧 妙技术 被映射 到虚拟 内存中 。***



##### 动态内存分配

动态 内存分 配器维 护着一 个进程 的虚拟 内存区域， 称为堆 （heap) 。

分配器 将堆视 为一组 不同大 小的块 （block) 的集合来维护 。每 个块 就是一 个连续 的虚拟 内存片 （chunk),要么 是已分 配的， 要么是 空闲的 。已分 配的块 显式地保 留为供 应用程 序使用 。空闲 块可用 来分配 。空 闲块保持 空闲， 直到它 显式地 被应用 所分配 。一个 已分配的块保 持已分 配状态 ，直 到它被 释放， 这种释 放要么是应 用程序 显式执 行的， 要么是 内存分 配器自 身隐式执 行的。

![](https://upload-images.jianshu.io/upload_images/1829481-63e5c9cfe5860e3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



分 配器有 两种基 本风格 。两 种风格 都要求 应用显式地 分配块 。

- 显式 分配器 （explicit allocator), 要 求应用 显式地 释放任 何已分 配的块 。例如 ， C 标准库 提供一 种叫做 mall0C 程 序包的 显式分 配器。 C 程序通 过调用 malloc 函数来.分配 一个块 ，并通 过调用 free 函数来 释放一 个块。 C++ 中的符与 C 中的 malloc 和 f ree 相当。
- 隐式 分配器 （implicit allocator)ÿ 另 一方面 ，要求 分配器 检测一 个已分 配块何 时不再被程序 所使用 ，那么 就释放 这个块 。隐 式分配 器也叫 做垃圾 收集器 , 而自 动释放 未使用 的已分 配的块 的过程 叫做垃 级收集 （garbage collection)ÿ例如 ，诸如 Lispÿ ML 以及 Java 之类 的高级 语言就 依垃 圾收集 来释放 已分配的块。

**使用动态内存的原因：**

程序 使用动 态内存 分配的 最重要 的原因是经常 直到程 序实际 运行时 ，才 知道 某些数据结构 的大小 。

**隐式空 闲链表：**

通过标记来标记出当前块是空闲还是使用，因 为空闲 块是通 过头部 中的大 小字段 隐含地 连接着的 。分 配器可 以通过 遍历堆 中所有 的块， 从而间 接地遍 历整个 空闲块 的集合 。

**显式空 闲链表：**

明确通过某种数据结构来连接空闲块。



**垃圾收集**

垃圾 收集器 （garbage collector) 是一 种动态 内存分 配器， 它自动 释放程 序不再 需要的已 分配块 。这些 块被称 为垃圾 （garbage) (因 此术语 就称之 为垃圾 收集器 ）。 自动回 收堆存储 的过程 叫做垃 圾收集 （garbage collection)ÿ 在 一个支 持垃圾 收集的 系统中 ，应用 显式分配堆块 ，但是 从不显 示地释 放它们 。

收集方式分两种：

1.引用计数

2.可达性分析，*书中介绍的这种*



### 第十章 系统级IO

输入 / 输出 （I/O) 是在主 存和外 部设备 (例 如磁盘 驱动器 、终端 和网络 ) 之间 复制数 据的过程。 输人操 作是从 I/O 设备复 制数据 到主存 ，而输 出操作 是从主 存复制 数据到 I/O 设备。

每个 Linux 文件 都有一 个类型 （type) 来表明 它在系 统中的 角色：

- 普通文件 （regular file) 包含任 意数据 。应 用程序 常常要 区分文 本文件 （text file) 和二进 制文件 （binary file), 文本 文件是 只含有 ASCII 或 Unicode 字符 的普通 文件； 二进制文 件是所 有其他 的文件 。对内 核而言 ， 文本文 件和二 进制文 件没有 区别。
- 目录 （directory) 是 包含一 组链接 （link) 的文件 ，其 中每个 链接都 将一个 文件名(filename) 映射 到一个 文件， 这个文 件可能 是另一 个目录 。每 个目录 至少含 有两个条目 ： 是 到该目 录自身 的链接 ，以及 是到 目录层 次结构 （见 下文） 中父目录 （parentdirectory) 的链接 。你 可以用 mkdir 命令 创建一 个目录 ，用 Is 查 看其内容 ，用 rmdir 删除该目录。
- 接字 （socket) 是 用来与另一个 进程进 行跨网 络通信 的文件

目录 层次结 构中的 位置用 路径名 （pathname) 来指定 。路 径名 是一个 字符串 ，包 括一个可 选斜杠 ，其后 紧跟一 系列的 文件名 ，文 件名之 间用斜 杠分隔 。路径 名有两 种形式 ：

- 绝对 路径名 （absolute pathname) 以 一个 斜 杠开始 ，表示 从根节 点开始 的路径 。
- 对 路径名 （relative pathname) 以文件 名开始 ，表 示从 当前工 作目录 开始的 路径。

每个文件打开后都会得到一个描述符，描述符为一个无符号int数字，存储在一张描述符表中。**同一文件多次被打开描述符不同。**

**描述符：**

每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向[内核](https://baike.baidu.com/item/内核)为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于[UNIX](https://baike.baidu.com/item/UNIX)、[Linux](https://baike.baidu.com/item/Linux)这样的操作系统。

习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。尽管这种习惯并非[Unix](https://baike.baidu.com/item/Unix)内核的特性，但是因为一些 shell 和很多应用程序都使用这种习惯，因此，如果内核不遵循这种习惯的话，很多应用程序将不能使用。

POSIX 定义了 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO 来代替 0、1、2。这三个[符号常量](https://baike.baidu.com/item/符号常量)的定义位于头文件 unistd.h。

文件描述符的有效范围是 0 到 OPEN_MAX。一般来说，每个进程最多可以打开 64 个文件（0 — 63）。对于 FreeBSD 5.2.1、Mac OS X 10.3 和 Solaris 9 来说，每个进程最多可以打开文件的多少取决于[系统内存](https://baike.baidu.com/item/系统内存)的大小，int 的大小，以及系统管理员设定的限制。Linux 2.4.22 强制规定最多不能超过 1,048,576 。

文件描述符是由[无符号整数](https://baike.baidu.com/item/无符号整数)表示的句柄，进程使用它来标识打开的文件。文件描述符与包括相关信息（如文件的打开模式、文件的位置类型、文件的初始类型等）的文件对象相关联，这些信息被称作文件的上下文。

*描述符解释来自百度百科*



内核 用三个 相关的 数据结 构来表 示打开 的文件 ：

- 描述符表 （descriptor table)每个 进程都 有它独 立的描 述符表 ，它的 表项是 由进程打开的 文件描 述符来 索引的 。每 个打开 的描述 符表项 指向文 件表中 的一个 表项。
- 文 件表 (file table) 打开文 件的集 合是由 一张文 件表来 表示的 ，所有 的进程 共享这张表 。每 个文件 表的表 项组成 （针对 我们的 目的） 包括当 前的文 件位置 、引 用计数(reference count)( 即当前 指向该 表项的 描述符 表项数 ）， 以及 一 个指向 v-node 表中对 应表项 的指针 。关 闭一个 描述符 会减少 相应的 文件表 表项中 的引用 计数。 内核不会 删除这 个文件 表表项 ，直到 它的引 用计数 为零。

- v-node 表 (v-nodetable)同文件 表一样 ，所 有的 进程共 享这张 v-node 表。 每个表项包含 stat 结构中 的大多 数信息 ，包括 st_mode 和 st_size 成员。

![](https://upload-images.jianshu.io/upload_images/1829481-54fb62c7a1d1b9af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/1829481-e6727b53846a14a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Linux shell 提供了 I/O 重定向 操作符 ，允 许用户 将磁盘 文件和 标准输 人输出 联系起来 。可重定向也是基于这三张表进行相应的操作

![](https://upload-images.jianshu.io/upload_images/1829481-f21f25da4a0d4dd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 第十一章 网络编程



网络应用都是 基于客 户端- 服务器 模型的 。采 用这个 模型， 一个应 用是由 一个服务器进 程和一 个或者 多个客 户端进 程组成 。服 务器 管理某 种资源 ，并 且通过 操作这 种资源来 为它的 客户端 提供某 种服务 。

客户端 -服务 器模型 中的基 本操作 是事务 （transaction) (见图 11-1)。 一个 客户端 -服务器事 务由以 下四步 组成。

1) 当一 个客户 端需要 服务时 ，它向 服务器 发送一 个请求 ，发 起一 个事务 。例如 ，当Web 浏览 器需要 一个文 件时， 它就发 送一个 请求给 Web 服 务器。

2) 服务器 收到请 求后， 解释它 ，并 以适当 的方式 操作它 的资源 。例如 ，当 Web 服务器收到 浏览器 发出的 请求后 ，它 就读一 个磁盘 文件。

3) 服 务器给 客户端 发送一 个响应 ，并等 待下一 个请求 。例 如， Web 服 务器将 文件发送回客 户端。

4) 客户 端收到 响应并 处理它 。例如 ，当 Web 浏览 器收到 来自服 务器的 一页后 ，就在屏幕 上显示 此页。



对主 机而言 ，网 络只是 又一种 I/O 设备 ，是 数据源 和数据 接收方。一 个插到 I/O 总线 扩展槽 的适配 器提供 了到网 络的物 理接口 。从 网络上 接收到 的数据从适配 器经过 I/O 和 内存总 线复制 到内存 ，通常 是通过 DMA 传送。 相似地 ，数据 也能从内存 复制到 网络。

套接 字接口 （socket interface) 是一组 函数， 它们和 Unix I/O 函数结 合起来 ，用 以创建网 络应用 。大 多数现 代系统 上都实 现套接 字接口 ，包括 所有的 Unix 变种、 Windows 和Macintosh 系统 。

![](https://upload-images.jianshu.io/upload_images/1829481-0787f07cc07ce33a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### Web 服务器

Web 客户端 和服务 器之间 的交互 用的是 一个基 于文本 的应用 级协议 ，叫做 HTTP超 文本传 输协议 。 HTTP 是一 个简单 的协议 。一个 Web
客户端 （即浏 览器） 打开 一个到 服务器 的因特 网连接 ，并且 请求某 些内容 。服 务器响 应所请求 的内容 ，然 后关闭 连接。 浏览器 读取这 些内容 ，并 把它显 示在屏 幕上。

Web 服务 器以两 种不同 的方式 向客户 端提供 内容：

- 取一 个磁盘 文件， 并将它 的内容 返回给 客户端 。磁 盘文件 称为静 态内容 （static con¬tent), 而返 回文件 给客户 端的过 程称为 服务静 态内容 （serving static content)
- 运行一 个可执 行文件 ，并 将它 的输出 返回给 客户端 。运 行时可 执行文 件产生 的输出称为动 态内容 （dynamic content), 而运行 程序并 返回它 的输出 到客户 端的过 程称为服务动 态内容 （serving dynamic content) 。



### 第十二章 并发编程



使用应 用级并 发的应 用程序 称为并 发程序。 现代 操作系 统提供了三种 基本的 构造并 发程序 的方法 ：

- 进程 。用这 种方法 ，每 个逻辑 控制流 都是一 个进程 ，由 内核来 调度和 维护。 因为进程有 独立的 虚拟地 址空间 ，想要 和其他 流通信 ， 控制流 必须使 用某种 显式的 进程间communication, IPC) 机制。
- I/0 多 路复用 。在这 种形式 的并发 编程中 ，应用 程序在 一个进 程的上 下文中 显式地调 度它们 自己的 逻辑流 。逻辑 流被模 型化为 状态机 ，数 据到达 文件描 述符后 ，主程序显 式地从 一个状 态转换 到另一 个状态 。因为 程序是 一 个单独 的进程 ，所以 所有的流都共 享同一 个地址 空间。
- 线程 。线程 是运行 在一个 单一进 程上下 文中的 逻辑流 ，由 内核进 行调度 。你 可以把线程看 成是其 他两种 方式的 混合体 ，像 进程流 一样由 内核进 行调度 ，而像 I/O 多路复用 流一样 共享同 一个虚 拟地址 空间。



##### *进程方式

通过接收到信息后创建多个进程，每个进程单独处理一个请求。

*进程的优劣：*

对 于在父 、子进 程间共 享状态 信息， 进程有 一个非 常清晰 的模型 ：共享 文件表 ，但 是不共享用 户地址 空间。 进程有 独立的 地址空 间既是 优点也 是缺点 。这样 一来， 一个进 程不可 能不小心 覆盖另 一个进 程的虚 拟内存 ，这就 消除了 许多令 人迷惑 的错误 —— 这 是一个 明显的 优点。另 一方面 ，独立 的地址 空间使 得进程 共享状 态信息 变得更 加困难 。为 了共 享信息 ，它们必 须使用 显式的 IPC (进程 间通信 ） 机制 。（参 见下 面的旁 注。） 基于 进程的 设计的 另一个缺点是 ，它 们往往 比较慢 ，因 为进程 控制和 IPC 的开销 很高。

![](https://upload-images.jianshu.io/upload_images/1829481-1cc2a99aa7de703d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



##### 基于I/O多路复用的并发编程

基 本的思路就 是使用 select 函数 ，要求 内核挂 起进程 ，只有 在一个 或多个 I/O 事件 发生后 ，才将控制返 回给应 用程序。（个人理解想系统内IO处理方式）



事 件驱动 设计的 一个优 点是， 它比基 于进程 的设计 给了程 序员更 多的对 程序行 为的控制 。例如 ，我们 可以设 想编写 一个事 件驱动 的并发 服务器 ，为 某些客 户端提 供它们 需要的服务 ，而这 对于基 于进程 的并发 服务器 来说， 是很困 难的。另一个 优点是 ，一 个基于 I/O 多路复 用的事 件驱动 服务器 是运行 在单一 进程上 下文中的 ，因 此每个 逻辑流 都能访 问该进 程的全 部地址 空间。 这使得 在流之 间共享 数据变 得很容易 。一个 与作为 单个进 程运行 相关的 优点是 ，你 可以 利用熟 悉的调 试工具 ，例如 GDBÿ来调 试你的 并发服 务器， 就像对 顺序程 序那样 。最后 ，事 件驱 动设计 常常比 基于进 程的设计要高 效得多 ， 因为它 们不需 要进程 上下文 切换来 调度新 的流。事 件驱动 设计一 个明显 的缺点 就是编 码复杂 。我 们的事 件驱动 的并发 echo 服务器 需要的代码 比基于 进程的 服务器 多三倍 ，并且 很不幸 ，随 着并 发粒度 的减小 ，复 杂性还 会上升 。这里的 粒度是 指每个 逻辑流 每个时 间片执 行的指 令数量 。



**基于线 程的并 发编程**

线程 （thread) 就是运 行在进 程上下 文中的 逻辑流 。在本 书里迄 今为止 ，程 序都 是由每个进程 中一个 线程组 成的。 但是现 代系统 也允许 我们编 写一个 进程里 同时运 行多个 线程的程序 。线 程由内 核自动 调度。 每个线 程都有 它自己 的线程 上下文 （thread context), 包括一个唯 一的整 数线程栈、 栈指针 、程序 计数器 、通用 目的寄 存器和条件码 。所有 的运行 在一个 进程里 的线程 共享该 进程的 整个虚 拟地址 空间。基于线 程的逻 辑流结 合了基 于进程 和基于 I/O 多路复 用的流 的特性 。同进 程一样 ，线程由 内核自 动调度 ，并 且内核 通过一 个整数 ID 来识别 线程。 同基于 I/O 多 路复用 的流一样 ，多 个线程 运行在 单一进 程的上 下文中 ，因此 共享这 个进程 虚拟地 址空间 的所有 内容，包括它 的代码 、数据 、堆 、共 享库和 打开的 文件。

![](https://upload-images.jianshu.io/upload_images/1829481-23d9c965e8003958.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Posix 线程 (Pthreads) 是在 C 程序中 处理线 程的一 个标准 接口。

线程通 过调用 pthread_create 函 数来创 建其他 线程。

![一 个线程 是以下 列方式 之一来 终止的](https://upload-images.jianshu.io/upload_images/1829481-efe580e653407694.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**回收已终止线程的资源。**线程通 过调用 pthreadjoin 函数 等待其 他线程 终止。

**分离线程** ：在任何 一个时 间点上 ，线 程是可 结合的 （joinable) 或者是 分离的 （detached)。 一 个可结合 的线程 能够被 其他线 程收回 和杀死 。在被 其他线 程回收 之前， 它的内 存资源 （例 如栈） 是不 释放的 。相反 ，一 个分离 的线程 是不能 被其他 线程回 收或杀 死的。 它的内 存资源 在它终止 时由系 统自动 释放。

默认情况下 ，线 程被创建成可结合的 。为了避免内存泄漏 ，每个可结合线程都应该要么被其他线程 显式地收回， 要么通过调用 pthreacLdetach 函数被 分离。

**初始 化线程**：pthread_once 函 数允许 你初始 化与线 程例程 相关的 状态。

![](https://upload-images.jianshu.io/upload_images/1829481-aa4007dde30b7d23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/1829481-5acf9419d8dd9ace.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



**线程间同步使用信号量**

典型的同步模型，消费者与生产者