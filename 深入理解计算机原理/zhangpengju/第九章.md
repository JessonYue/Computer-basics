虚拟内存
1，虚拟内存实现了进程独立，为每个进程提供了大的，一致的，私有的地址空间
2，早期计算器使用最基础的物理寻址，现代使用虚拟寻址(cpu生成虚拟地址来访问主存，在送到主存之前，转换成适当的物理地址)
3，虚拟内存包含三种时态：未分配，缓存的，未缓存的
4，页表：负责将虚拟页映射到物理页
5，缺页：缓存不命中，会开辟新空间，幷加到缓存上
6，良好的局部性，可以避免页换进换出，防止出现抖动
7，虚拟内存还有个优点是保护物理内存，防止被滥用
8，利用TLB寻址表缓存翻译过的物理内存，加速翻译
9，linux虚拟内存区域：一个区域是连续的已分配的虚拟内存连续片，一个linux虚拟内存包含多个区域，区域之间可以有间隔
10，缺页异常：1，是否在区域内和读写权限问题，2，是否是用户模式可访问的地方，（非法访问内核）
11，Linux内存映射的两种情况：普通文件和匿名文件（由内核创建，全部是二进制）
12，使用mmap可以新建内存映射（用户级别），munmap删除映射区域，删除后，在引用会报错
13，动态内存分配
   1，显式分配器，主动malloc() 主动分配
   2，隐式分配器，例如jvm 垃圾回收
14,显示分配器的要求：
   可以处理任意请求序列；
   立即响应，返回结果，不可以有缓冲
   只使用堆（非标量），保证扩展性
   对齐块，提高内存使用效率
   不允许修改已经分配的块
15，内存碎片
    1，内部碎片，比如开辟的某个块，没有全完存满数据，剩余的浪费（注意合理申请内存的大小，按需申请）
    2，外部碎片，在申请时，没有足够大的空间，（因为每个内存是连续的），所以，很多小的空闲空间没法用。分配器器使用启发式策略，找最相近的大小空闲块进行分配。
16，垃圾回收
   1，垃圾回收器是动态内存分配器，主动释放不需要的分配块
   2，内存视为一张有向可达图，包含一组根节点和一组堆节点（可达性算法）
   3，标记位垃圾回收，通过标记加减，记录内存是否需要清理，c语言中，使用平衡二叉树，来检索某个指针是否指向地址
17,常见的引用指针错误
   1，间接引用坏指针，传入的是数据，而不是地址值
   2，读没有初始化的内存，在堆中，要主动赋值，才能读取正确
   3，没有限制输入的大小，导致栈缓冲溢出
   4，错误的认为对象和对象指针大小相同，sizeof 时，传入对象 而不是指针
   5，错误的使用指针运算
   6，引用不存在的变量
   7，没有free ，导致泄漏
