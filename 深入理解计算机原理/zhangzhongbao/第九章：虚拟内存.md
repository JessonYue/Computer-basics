

一个系统中的进程是与其他进程共享 CPU 和主存资源。   

虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。

虚拟内存三个重要的能力：  
- 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
- 它为每个进程提供了一致的地址空间，从而简化了内存管理。
- 它保护了每个进程的地址空间不被其他进程破坏。

学习虚拟内存的原因：
- 虚拟内存是核心的
- 虚拟内存是强大的  
虚拟内存给予应用程序强大的能力，可以创建和销毁内存片
(chunk)将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存
- 虚拟内存是危险的
如果使用错误指针经常会碰到“段错误”、“保护错误”

### 9.1 物理和虚拟寻址
计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有 一 个唯 一 的物 理地址（Physical Address，PA)  

CPU 通过生成一个虚拟地址（Virtual Address VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。

**【560 图 9-2 —个使用虚拟寻址的系统】**
CPU 从一个有 N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space)  

主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。

### 9.3 虚拟内存作为缓存的工具
虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。

VM 系统通过将虚拟内存分割为称为虚拟页（Virtual Page, VP)的大小固定的块来处理这个问题
#### 9.3.1 DRAM 缓存的组织结构
DRAM 比 SRAM 要 慢大约 10 倍，而磁盘要比 DRAM 慢大约 100 000 多倍.   

从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节要慢大约100 000 倍。     

因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是 4KB〜2MB。

因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写。

#### 9.3.2 页表
虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM 中的某个地方。  
- 命中：系统还必须确定这个虚拟页存放在哪个物理页中。  
- 不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。

页表将虚拟页映射到物理页。  
每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。

页表就是一个页表条目（Page Table Entry,PTE)的数组。  


在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换（swapping)或者页面调度（paging)。页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页 面调度（demand paging)
#### 9.3.6 又是局部性救了我们
尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部
性原则保证了在任意时刻，程序将趋向于在一个较小的活动雨面(active page)集合上工作，这个
集合叫做工作集(working set)或者常驻集合(resident set),在初始开销，也就是将工作集页面调
度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量.

### 9.4 虚拟内存作为内存管理的工具
操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。  
多个虚拟页面可以映射到共享物理页面上。 

VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配
- 简化链接 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。对于64位机器，代码段从虚拟地址 0x400000 开始。
- 简化加载 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。  
将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping)。
- 简化共享 独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。
- 简化内存分配 虚拟内存为向用户进程提供一个简单的分配额外内存的机制。  
操作系统没有必要分配是个连续的物理内存页面。页面可以随机地分散在物理内存中。

### 9.5 虚拟内存作为内存保护的工具
- 不应该允许一个用户进程修改它的只读代码段。
- 而且也不应该允许它读或修改任何内核中的代码和数据结构。
- 不应该允许它读或者写其他进程的私有内存，
- 不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做（通过调用明确的进程间通信系统调用）。

在页表中创建许可位。如果一条指令违反了许可条件，CPU就会触发一个一般保护故障，将控制传递给一个内核中异常处理程序。一般称为**段故障**

### 9.6 地址翻译
![使用页表的地址翻译](images\使用页表的地址翻译.png)
将页表条目中物理页号(Physical Page Number, PPN)和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。

#### 9.6.1 结合高速缓存和虚拟内存
高速缓存无需处理保护问题，因为访问权限的检査是地址翻译过程的一部分。
#### 9.6.3 多级页表
一个 32 位的地址空间、4KB 的页面和一个4字节的PTE那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。   
解决此问题，我们可以使用虚拟地址空间构造多级页面层次结构。  

从两个方面减少内存需求：
- 第一，如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在。
- 第二，只有一级页表才需要总是在主存中；  
虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存
的压力；只有最经常使用的二级页表才需要缓存在主存中

### 9.7 Linux 虚拟内存系统
Linux 为每个进程维护了一个单独的虚拟地址空间

内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。  

内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的找，以及记录虚拟地址空间当前组织的各种数据结构。  

![—个 Linux 进程的虚拟内存](images\—个 Linux 进程的虚拟内存.png)
Linux 缺页异常处理

 - 虚拟地址 A 是合法的吗？  
 如果这个指令是不合法的，那么缺页处理程序就触发一个段 误，从而终止这个进程
- 试图进行的内存访问是否合法？  
如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。
- 内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。  
选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换
出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU 重新启动引起缺页的指令，这
条指令将再次发送 A 到 MMU。这次，MMU 就能正常地翻译 A，而不会再产生缺页中断了

### 9.8 内存映射
Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping)
虚拟内存区域可以映射到两种类型的对象中
- Linux 文件 系统中的普通文件   
因为按需进行页面调度，所以这些虚拟页面没有实际交换进人物理内存
-  匿名文件  一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包
含的全是二进制零。

#### 9.8.1 再看共享对象
进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。不过，许多进程有同样的只读代码区域。  
内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。    
一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。
- 如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程
对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而
言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。（Logan使用mmap可以参照这个）
- 另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程而言是不可见的，并且进程所做的改变不会反应到磁盘上。


私有对象使用一种叫做**写时复制（copy-on-write)**的巧妙技术被映射到虚拟内存中。

##### 私有对象的写时复制：  

其中两个进程将一个私有对象映射到它们虚拟内存的不同区域，但是共享这个对象同一个物理副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。  
只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。  
然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。  
当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限

#### 9. 8. 2 再看 fork 函数
fork创建进程，会复制父进程的mm_struct/区域结构/页表的副本，而且设置两个进程每个页面为只读.  
当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间
#### 9. 8. 3 再看 execve 函数
加载a.out需要的步骤
- 删除已存在的用 户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。
- 映射私有区域。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些
新的区域都是私有的、写时复制的。代码和数据区域被映射为 a.out 文件中的.text
和.data 区。bss 区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈
和堆区域也是请求二进制零的，初始长度为零。
- 映射共享区域。如果 a.out 程序与共享对象（或目标）链接，比如标准 C 库 libc.
那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中
的共享区域内。
- 设置程序计数器（PC)。序计数器，使之指向代码区域的人口点。

![加载器是如何映射用户地址空间的区域的](images\加载器是如何映射用户地址空间的区域的.png)

#### 9.8.4 使用 mmap 函数的用户级内存映射
Linux 进程可以使用 _P函数来创建新的虚拟内存区域

```
//创建虚拟内存
void *mmap(void *staxt, size_t length, int prot, int flags,int fd, off_t offset);
返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(—1)  

//删除虚拟内存
int munmap(void *staxt, size_t length);
返回：若成功则为 0, 若出错则为 一1,
```
### 9.9 动态内存分配
分配器将堆视为一组不同大小的块（block)的集合
来维护。每个块就是一个连续的虚拟内存片（chunk),
要么是已分配的，要么是空闲的。   
两种风格的分配器
- 显式分配器（explicit allocator), 要求应用显式地释放任何已分配的块。  
 C 程序通过调用 malloc 函数来
.分配一个块，并通过调用 free 函数来释放一个块。C++ 中的
符与 C 中的 malloc 和 f ree 相当。
- 隐式分配器（implicit allocator)，要求分配器检测一个已分配块何时不再
被程序所使用，那么就释放这个块。  
隐式分配器也叫做垃圾收集器（garbage collector), 而自动释放未使用的已分配的块的过程叫做垃级收集（garbage collection)，例如java就是依赖垃圾收集。

#### 9.9. 1 malloc 和 free 函数

```
void *malloc(size_t size);
返回：若成功则为已分配块的指针，若出错则为 NULL
```
返回的块可能做了内存对齐。在 32 位模式中，malloc 返回的块的地址总
是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数。    

malloc 不初始化它返回的内存。  
那些想要已初始化的动态内存的应用程序可以使用 calloc，calloc 是一个基于 malloc 的瘦包装函数，仓将分配的内存初始化为零。  
想要改变一个以前已分配块的大小，可以使用 realloc 函数。

```
//释放
void free(void *ptr);
```



### 9.11 C 程序中常见的与内存有关的错误
- 间接引用坏指针，
- 读取未初始化的内存，
- 允许栈缓冲区溢出，
- 假设指针和它们指向的对象大小相同，
- 引用指针而不是它所指向的对象，误解指针运算，引用不存在的变量，以及引起内存泄漏。





