每次从 〜到〜H的过渡称为控制转移（control
transfer)。这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow)。  

系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕
获的，而且也不一定要和程序的执行相关。
比如：
- 一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中
- 程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪
- 当子进程终止时，创造这些子进程的父进程必须得到通知
上面这些突变称为异常控制流

异常控制流发生在计算机系统的各个层次
- 在硬件层 硬件检测到的事件会触发控制突然转移到异常处理程序  
- 在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程
- 在应用层，个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。 

### 8. 1 异常
异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
异常(exception)就是控制流中的突
变，用来响应处理器状态中的某些变化。


当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception table)的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序（exception handler):)

#### 8.1.1 异常处理
系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception
ber)其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。
- 前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。
- 后者的示例包括系统调用和来自外部 I/O 设备的信号

异常表的起始地址放在一个叫做异常表基址寄存器《exception table base register)的特殊 CPU 寄存器里

异常与过程调用有一些重要的不同：
- 过程调用时在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）
- 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。
- 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用
户栈中。
- 异常处理程序运行在内核模式下这意味着它们对所有的系统资源都有完全的访问权限

#### 8.1.2 异常的类别
中断（interrupt)、陷牌（trap)、故障（fault)和终止（abort)
### 8.2 进程 

进程的经典定义是一个执行中的实例。  
上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内
存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。
#### 8.2.1 逻辑控制流
进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（preempted)(暂时挂起）， 然后轮到其他进程。
#### 8.2.2 并发流   
一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow)。  
多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运行的概念称为多任务（multitasking)。  

并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上
重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。  

如果两个流并发地运行在不同的处
理器核或者计算机上，那么我们称它们为并行流（parallel flow), 它们并行地运行（runninging parallel),且并行地执行（parallel execution).
#### 8.2.3 私有地址空间
地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。  
代码段总是从地址 0x400000开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。 地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。

![进程地址空间.png](images\进程地址空间.png)

#### 8.2.4 用户模式和内核模式
处理器通常是用某个控制寄存器中的一个模式位（mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用 户模式）。  

一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。  
没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令。  
进程从用户模式变为内核模式：中断、故障、系统调用。


#### 8.2.5 上下文切换
上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表
### 8.3 系统调用错误处理
当 Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量errno
来表示什么出错了。（大部分unix系统函数会错误会返回-1，是一种规范）
### 8.4 进程控制

```
pid_t getpid(void);
pid_t getppid(void);

```
#### 8.4.2 创建和终止进程

在编程的角度看进程的状态：
- 运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。
- 停止。进程的执行被挂起（suspended), 且不会被调度。
- 终止。进程永远地停止了。进程会因为三种原因终止：1)收到一个信号，该信号的
默认行为是终止进程，2)从主程序返回，3)调用 exit 函数
```
void exit(int status);
```
父进程通过调用 fork 函数创建一个新的运行的子进程。

```
pid_t fork(void);
返回：子进程返回 0，父进程返回子进程的 PID, 如果出错，则为 一1。
```
父子进程的不同：
新创建的子进程几乎但不完全与父进程相同。
- 子进程得到与父进程用户级虚拟地址空间相括代码和数据段、堆、共享库以及用户栈。
- 子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件（共享文件）
- 父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。

#### 8.4.3 回收子进程
当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped)。一个终止的进程未被回收旧变成了僵死进程。

```
pid_t waitpid(pid_t pid, int *statusp, int options);
返回：如果成功，则为子进程的 PID, 如果 WNOHANG,则为 0，如果其他错误，则为 一1。
```
#### 8.4.5 加载并运行程序

```
int execve(const char *filename, const char *argv[],
const char *envp[]); 如果成功，则不返回，如果错误，则返回一1。
```

execve 调用一次并从不返回。
### 8.5 信号
Linux 信号允许进程和内核中断其他进程。  
一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件  
低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。  
![linux信号](images\linux信号.png)

#### 8.5.1 信号术语
传送一个信号到目的进程两个步骤：
- 发送信号  
内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。  
发送信号的原因：1、内核检测到系统事件；2、一个进程调用了kill函数，显示终结另一个进程。
- 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。


一个发出而没有被接收的信号叫做待处理信号（pending signal)在任何时刻，一种类型至多只会有一个待处理信号。当第二个这种类型的待处理信息过来之后，直接被丢弃掉。这也是为什么回收子进程的时候用while，而不是if。
#### 8.5.4 阻塞和解除阻塞信号

```
int sigprocmask(int how, const sigset_t *set, sigsetÿt *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
返回：如果成功则为 0，若出错则为一1。
int sigismember(const sigset_t *set, int signum); 返回：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 一1
```













