虚拟内存

- 一个系统中的进程是与其他进程共享 CPU 和主存资源的
- 为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)
- 虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间

虚拟内存三个作用：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏

理解虚拟内存**作用**：

1. 虚拟内存是核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。理解虚拟内存将帮助你更好地理解系统通常是如何工作的
2. 虚拟内存是强 大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片(chunk)，将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。
3. 虚拟内存是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如 malloc 这样的动态分配程序时，它就会和虚拟内存发生交互。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。



9.1 物理和虚拟寻址

- 计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。
- 每字节都有 一 个唯 一 的物 理地址，第一个字节的地址为 0, 接下来的字节地址为 1，再下一个为 2, 依此类推。
- 给定这种简单的结构，CPU 访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-1.png)

早期的 PC 使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及 Cray 超级计算机这样的系统仍然继续使用这种寻址方式。然而，现代处理器使用的是一种称为**虚拟寻址的寻址形式**

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-2.png)

**说明**：

使用虚拟寻址，CPU 通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译 就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做内存管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理



9.2 地址空间

- 地址空间（address space)是一个非负整数地址的有序集合

- 地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。 一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址

  

9.3 虚拟内存作为缓存的工具

每个虚拟页的大小为 P=2^p字节。类似地，物理内存被分割为物理页,大小也为 **P** 字节（物理页也被称为页帧（page frame))

在任意时刻，虚拟页面的集合都分为**三个不相交的子集**：

- 未分配的：**VM** 系统还未分配(或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间
- 缓存的：当前已缓存在物理内存中的已分配页
- 未缓存的：未缓存在物理内存中的已分配页

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-3.png)

**说明**：

展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、S 和 7 已经被分配了，但是当前并未缓存在主存中



9.3.1 DRAM 缓存的组织结构

DRAM 比 SRAM 要 慢大约 10 倍，而磁盘要比 DRAM 慢大约 100 000 多倍



9.3.2 页表

1. 操作系统软件、MMU(内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页
2. 页表就是一个**页表条目的数组**。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-4.png)

9.3.3 页命中

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-5.png)

9.3.4 缺页

在虚拟内存的习惯说法中，DRAM 缓存不命中称为缺页（page fault)

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-6.png)



![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-7.png)

9.3.5 分配页面

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-8.png)

9.4 虚拟内存作为内存管理的工具

**实际上，操作系统为每个进程提供了一个独立的页表**

**VM** 简化了链接和加载、代码和数据共享，以及应用程序的内存分配：

- 简 化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处

- 简化加载。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 **.text** 和 **.data** 节加载到一个新创建的进程中，**Linux** 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的）， 将页表条目指向目标文件中适当的位置

- 简 化共享。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面

  

9.5 虚拟内存作为内存保护的工具

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-10.png)

提供独立的地址空间使得区分不同进程的私有内存变得容易。但是，地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE，所以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问



9.6 地址翻译

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-11.png)



9.6.1 结合高速缓存和虚拟内存

在任何既使用虚拟内存又使用 **SRAM** 髙速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问 **SRAM** 高速缓存的问题

了一个物理寻址的高速缓存如何和虚拟内存结合，如下：

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-14.png)

9.6.2 利用 **TLB** 加速地址翻译

- 每次 **CPU** 产生一个虚拟地址，**MMU** 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址
- 它们在 **MMU** 中包括了一个关于 **PTE** 的小的缓存，称为翻译后备缓冲器
- **TLB** 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 **PTE** 组成的块。TLB 通常有高度的相联度。



9.7.2 **Linux** 虚拟内存系统

**Linux** 为每个进程维护了一个**单独的虚拟地址空间**

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-26.png)

**内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的找，以及记录虚拟地址空间当前组织的各种数据结构**：

- **Linux** 虚拟内存区域，Linux 将虚拟内存组织成一些区域（也叫做段）的集合，一个区域（area)就是已经存在着的（已分配的）虚拟内存的连续片（chunk), 这些页是以某种方式相关联的
- Linux 缺页异常处理



9.8 内存映射

Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射

内存映射两种类型：

- Linux 文件 系统中的普通文件
- 匿名文件



9.9 动态内存分配

动态内存分配器维护着一个进程的虚拟内存区域，称为**堆（heap)**

每个进程，内核维护着一个变量 brk(读做break) 它指向堆的顶部

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-33.png)

**分配器**：

1. 分配器将堆视为一组不同大小的块（block)的集合来维护。每个块就是一个连续的虚拟内存片（chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的
2. 分配器有两种基本风格。两种风格都要求应用显式地分配块：
   - 显式分配器（explicit allocator), 要求应用显式地释放任何已分配的块。
   - 隐式分配器（implicit allocator)， 另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector), 而自动释放未使用的已分配的块的过程叫做垃级收集（garbage collection)



9.9. 1 **malloc** 和 **free** 函数

**malloc** 函数返回一个指针，指向大小为至少 **size** 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。实际中，对齐依赖于编译代码在 32 位模式(gcc-m32)还是 64 位模式（默认的）中运行。在 32 位模式中，**malloc** 返回的块的地址总是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数



9.9.2 为什么要使用动态内存分配

程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些**数据结构的大小**。



9.9.3 分配器的要求和目标

显式分配器必须在一些相当严格的约束条件下工作：

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-88.png)



9.9.4 碎片

造成堆利用率很低的主要原因是一种称为碎片（fragmentation)的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象

两种形式：

1. 内部碎片,是在一个已分配块比有效载荷大时发生的。很多原因都可能造成这个问题
2. 外部碎片，是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的



9.9.9 获取额外的堆内存

分配器就会通过调用 **sbrk 函数**，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块,将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中



9.9.10 合并空闲块

当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做假碎片（fault fragmentation), 就是有许多可用的空闲块被切割成为小的、无法使用的空闲块

**解决假碎片问题**：

- 任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并(coalescing)，这就出现了一个重要的策略决定，那就是何时执行合并。
- 分配器可以选择立即合并（immediate coalescing), 也就是在每次一个块被释放时，就合并所有的相邻块。或者它也可以选择推迟合并（deferred coalescing), 也就是等到某个稍晚的时候再合并空闲块



9.9.12 综合：实现一个简单的分配器

- 通用分配器设计
- 操作空闲链表的基本常数和宏
- 创建初始空闲链表
- 释放和合并块
- 分配块



9.10 垃圾收集

**未能释放已分配的块是一种常见的编程错误**

1. 垃圾收集器（garbage collector)是一种动态内存分配器，它自动释放程序不再需要的已分配块。

2. 这些块被称为垃圾（garbage)(因此术语就称之为垃圾收集器）。

3.  自动回收堆存储的过程叫做垃圾收集（garbage collection)

   

9.10.1 垃圾收集器的基本知识

垃圾收集器将内存视为一张**有向可达图**

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-49.png)

节点被分成一组根节点（root node)和一组堆节点（heap node)， 每个堆节点对应于堆中的一个已分配块

**保守垃圾回收器**：

收集器通常不能维持可达图的精确表示。这样的收集器也叫做保守的垃圾收集器， 从某种意义上来说它们是保守的，即每个可达块都被正确地标记为可达了，而一些不可达节点却可能被错误地标记为可达

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/9-50.png)

9.11 **C** 程序中常见的与内存有关的错误

- 间接引用坏指针
- 读未初始化的内存
- 允许栈缓冲区溢出
- 假设指针和它们指向的对象是相同大小的
- 造成错位错误
- 引用指针，而不是它所指向的对象
- 误解指针运算
- 引用不存在的变量
- 引用空闲堆块中的数据
- 引起内存泄漏