typora-copy-images-to: upload

32 位机器只能使用大概4GB(232 字节）的随机访问存储器

64 位机器能够使用多达256TB(248字节）的内存空间，而且很容易就能扩展至16EB(264 字节）

3.1历史版本处理器比较



3.2

linux> gcc -0g -o p pi .c p2.c

编译过程

​	

3.3

(1)程序计数器

a.整数寄存器文件包含16 个命名的位置

b.条件码寄存器保存着最近执行的算术或逻辑指令的状态信

c.一组向量寄存器可以存放一个或多个整数或浮点数值



**

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调
用和返回的运行时栈，以及用户分配的内存块（比如说用malloc 库函数分配的）

**

例如，X86-64 的虚拟地址是由64 位的字来表示的。在目前的实现中，
这些地址的高16 位必须设置为0, 所以一个地址实际上能够指定的是248 或64TB 范围内
的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责'管理
虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

(2)

linux> gcc -0g -c mstrore.c

产生目标代码文件mstore.o, 它是二进制格式的

**

1368 字节
的文件mstore.o 中有一段14 字节的序列，它的十六进制表示为：
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只
是一个字节序列，它是对一系列指令的编码



3.2.3 关于格式的注解

以"."开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行

***

c程序和汇编结合

在C 程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进
一个独立的汇编代码文件中，让汇编器和链接器把它和用C 语言书写的代码合并起来。
第二种方法是，我们可以使用GCC 的内联汇编（inline assembly)特性，用asm伪指令可
以在C 程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。

***

3.3数据格式

16 位体系结构扩展成32 位的，

Intel 用术语“字（word)”表示16 位数据类型。

因此，称32 位数为“双字（double words)

称64 位数为“四字（quad words)”

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-1_test.png)

浮点数主要有两种形式：单精度（4 字节）值，对应于C 语言数据类型float; 双精度(8 字节)值，对应于C 语言数据类型double



***

数据传送指令有四个变种：movb(传送字节）、movw(传送字）、movl(传送双字)和movq(传送四字）。后缀‘1’用来表示双字，因为32 位数被看成是“长字（longword)

注意，汇编代码也使用后缀来表示4 字节整数和8 字节双精度浮点数。

***

3.4访问信息

一个X86-64 的中央处理单元（CPU)包含一组16 个存储64 位值的通用目的寄存器。

IA32 架构,寄存器也扩展成32位寄存器，标号从％eax到％ebp。

x86-64,8 个寄存器扩展成64 位，标号从%rax到红%rbp, 还增加了**8 个新的寄存器**，它们的标号是按照新的命名规则制定的：从％18到红15。

3.4.1操作数指示符

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-3.png)

3.4.2数据传输指令

最简单形式的数据传送指令—— MOV 类

MOV 类由四条指令组成：movb，movw，movl，movq

大小分别为1，2,  4，8

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-4.png)

**

X86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令—— 第一条指令将源值加载到寄存器中，第二条将该寄存器值写人目的位置

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-5.png)

两类数据移动指令，如下两图



![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-5-1.png)

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-5-2.png)

**理解数据传递如何改变目的寄存器**

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-5-3.png)

**字节传送指令的比较**

![3-5-4](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-5-4.png)

3.4.4 压入和弹出栈数据

找是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则

通过push 操作把数据压人栈中，通过pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插人和删除元素。这一端被称栈顶

**

X86-64 中，程序栈存放在内存中某个区域

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-8.png)

3.5.1加载有效地址

加栽有效地址（load effective address)指令leaq 实际上是movq 指令的变形。它的指
令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。



3.6.1条件码

除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code)寄存器，它们
描述了最近的算术或逻辑操作的属性

CF: 进位标志。最近的操作使最高位产生了进位。可用来检査无符号操作的溢出。
ZF: 零标志。最近的操作得出的结果为0。
SF: 符号标志。最近的操作得到的结果为负数。
OF: 溢出标志。最近的操作导致一个补码溢出—— 正溢出或负溢出。



3.7

不同编程语言中，过程的形式多样：函数(function)，方法(method) ，子例程(subroutine)， 处理函数(handler)等等，但是它们有一些共有的特性。



3.7.1运行栈

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-25.png)

**

为了提髙空间和时间效率，X86-64 过程只分配自己所需要的栈帧部分

实际上，许多函数甚至根本不需要栈帧

当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构）时，就可以这样处理



3.8.2指针运算

指针运算，计算出来的值根据该指针引用的数据类型的大小进行伸缩	

单操作数操作符‘&’和‘*’可以产生指针和间接引用指针



3.9.3数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地(址必须是某个值K(通常是2、4 或8)的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计



一个处理器总是从内存中取8 个字节，则地址必须为8的倍数。如果我们能保证将所有的double 类型数据的地址对齐成8 的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8 字节内存块中。



Intel 还是建议要对齐数据以_ 提高内存系统的性能

原则如下：

![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-9-3.png)

**强制对齐情况**

![image-20200612170615546](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/image-20200612170615546.png)



3.10.1 理解指针

- 每个指针都对应一个类型。这个类型表明该指针指向的是哪一类对象

- 指针是C 语言提供的一种抽象，帮助程序员避免寻址错误

- 每个指针都有一个值。这个值是某个指定类型的对象的地址。特殊的NULL(O)值表示该指针没有指向任何地方。

- 指针用‘&’运算符创建

- 操作符用于间接引用指针        

- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值

- 指针也可以指向函数

  

  **函数指针**    

  ![](https://gitee.com/andylinchuanxin/bookimage/raw/master/img/3-10.0.png)

  

  