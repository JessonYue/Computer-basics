系统级 **I/O**

- 输入/输出（I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程
- 输人操作是从 **I/O** 设备复制数据到主存，而输出操作是从主存复制数据到 **I/O** 设备



10. 1 Unix I/O:

     **I/O** 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行

    输人和输出统一且一致的方式来执行:

    - 打开文件
    - Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出（描述符为 1)和标准错误
    - 改 变当前的文件位置
    - 读写 文件
    - 关闭文件

10.2 文件

每个 Linux 文件都有一个类型（type)来表明它在系统中的角色:

- 普通文件（regular file)包含任意数据
- 目录（directory)是包含一组链接（link)的文件，其中每个链接都将一个 文件名(filename)映射到一个文件，这个文件可能是另一个目录
- 套接字（socket)是用来与另一个进程进行跨网络通信的文件

linux文件**层次结构**：

Linux 内核将所有文件都组织成一个目录层次结构（directory hierarchy), 由名为/(斜杠）的根目 录确定。系统中的每个文件都是根目录的直接或间接的后代

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/10-1.png)

**每个进程都有一个当前工作目录，来确定其在目录层次结构中的当前位置**

路径名有两种形式：

1. 绝对路径名（absolute pathname)以一 个斜 杠开始，表示从根节点开始的路径。
2. 相对路径名（relative pathname)以文件名开始，表示从当前工作目录开始的路径。



10.3 打开和关闭文件

权限位

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/10-2.png)

10.4 读和写文件

read 和 write 传送的字节比应用程序要求的要少。这些不足值（short count)不表示有错误。出现这样情况的原因有：

- 读时遇到 EOF
- 从终端读文本行
- 读和写网络套接字（socket)



10.8 共享文件

**可以用许多不同的方式来共享 Linux 文件**

内核用三个相关的数据结构来表示打开的文件：

- 描述符表
- 文件表
- **v-node** 表