- 从a_k到a_k+1的过渡称为控制转移（controltransfer)。这样的控制转移序列叫做处理器的控制流（flow of control 或control flow)。
- 现代系统通过使控制流发生突变来对这些情况做出反应,这些突变称为异常控制流(ecf)
- 异常控制流发生在计算机系统的各个层次



理解ECF作用:

1. 帮助你理解重要的系统概念,ECF 是操作系统用来实现1/0、进程和虚拟内存的基本机制
2. 帮助你理解应用程序是如何与操作系统交互的,应用程序通过使用一个叫做陷阱（trap)或者系统调用（system call) 的ECF 形式，向操作系统请求服务
3. 帮助你编写有趣的新应用程序,操作系统为应用程序提供了强大的ECF 机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件
4. 帮助你理解并发,ECF 是计算机系统中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序
5. 帮助你理解软件异常如何工作,软件异常允许程序进行非本地跳转(即违反通常的调用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层ECF在C 中是通过setjmp 和longjmp 函数提供的



8. 1 异常

   异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同

   ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-1.png)

   在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception table)的跳转表，进行一个间接过程调用（异常）， 到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序（exception handler))

   **当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3 种情况中的一种**:

   ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-1-1.png)

8.1.1 异常处理

1. 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号
2. 其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部I/O 设备的信号
3. 在系统启动时（当计算机重启或者加电时）， 操作系统分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-2.png)

  4.处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器(exception ta丨b e base register)的特殊 CPU 寄存器里,如下图:

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-3.png)

异常类似于过程调用，但是有一些重要的不同之处:

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-3-1.png)

8.1.2 异常的类别

异常可以分为四类：中断（interrupt)、陷牌（trap)、故障（fault)和终止（abort)

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-4.png)

- 中断是异步发生的，是来自处理器外部的I/O 设备的信号的结果

  ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-5.png)

**异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令（faulting instruction)。**

- 陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用

  ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-6.png)

- 故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort 例程，abort 例程会终止引起故障的应程序

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-7.png)

**一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障**

- 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM 或者SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序

8. 1 . 3 Linux/x86-64 系统中的异常

   X86-64 系统定义的一些异常,有高达256 种不同的异常类型[SSÿB 0􃀜31 的号码对应的是由Intel 架构师定义的异常，因此对任何x86-64 系统都是一样的。32􃀜255 的号码对应的是操作系统定义的中断和陷阱

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-9.png)

- Linux/x86-64 故障和终止

  - 除法错误
  - 一般保护故障,通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux 不会尝试恢复这类故障
  - 缺页（异常14)是会重新执行产生故障的指令的一个异常示例
  - 机器检查,机器检査（异常18)是在导致故障的指令执行中检测到致命的硬件错误时发
    生的

- Linux/86-64 系统调用

  Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文
  件、写文件或是创建一个新进程

  一4095 到一1 之间的负数返回值表明发生了错误，对应于负的error

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-10.png)

8.2 进程

异常是允许操作系统内核提供进程(process)概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。

- 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context)中

- **上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合**

- 关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象:

  1>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器

  2>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统



8.2.1 逻辑控制流

如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含
在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC 值的序列叫做逻辑控制流，或者简称逻辑流

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-12.png)

上图说明:**关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（preempted)(暂时挂起）， 然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器**

8.2.2 并发流

- **一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow), 这两个流被称为并发地运行。*
- 多个流并发地执行的一般现象被称为并发（concurrency)
- 一个进程和其他进程轮流运行的概念称为多任务（multitasking)
- 一个进程执行它的控制流的一部分的每一时间段叫做时间片（time Slice)
- 多任务也叫做时间分片（time slicing),上图中,进程A 的流由两个时间片组成

8.2.3 私有地址空间

- 进程也为每个程序提供一种假象，好像它独占地使用系统地址空间

- 进程为每个程序提供它自己的私有地址空间,**和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的**

  ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-13.png)

  说明:x86-64 Linux 进程的地址空间的组织结构,地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈

8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围

8.2.5 上下文切换

操作系统内核使用一种称为上下文切换(context switch)的较高层形式的异常控制流来实现多任务,上下文切换机制是建立在那些较低层异常机制之上的

- 内核为每个进程维持一个上下文（context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表

- 中断也可能引发上下文切换

  ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-14.png)

8.3 系统调用错误处理

当Unix 系统级函数遇到错误时，它们通常会返回一1，并设置全局整数变量来表示什么出错

8.4 进程控制

- 8.4.1 获取进程ID

  - 每个进程都有一个唯一的正数(非零)进程ID(PID) getpid 函数返回调用进程的PID,getppid 函数返回它的父进程的PID(创建调用进程的进程)。

- 8.4.2 创建和终止进程

  进程总是处于下面三种状态之一:

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-99.png)

8.4.3 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始,该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie)

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/8-99-1.png)

如果一个父进程终止了，内核会安排init 进程成为它的孤儿进程的养父。进程的PID 为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init 进程去回收它们。不过，长时间运行的程序，比如shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。



8.4.4 让进程休眠

如果请求的时间量已经到了，sleep 返回0, 否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为sleep 函数被一个信号中断而过早地返回

8.4.5 加载并运行程序

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-21.png)

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-22.png)

程序与进程

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-22-1.png)

8.5 信号

- 更髙层的软件形式的异常，称为 **Linux 信号**，它允许进程和内核中断其他进程
- 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-26.png)

8.5.1  信号术语

传送一个信号到目的进程是由两个不同步骤组成:

1. 发送信号。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：

   1)内核检测到一个系统事件，比如除零错误或者子进程终止

   2)—个进程调用了 kill 函数,显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己

2. 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号

信号处理程序捕获信号的基本思想如下图所示：

![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-27.png)

说明：

- 一个发出而没有被接收的信号叫做待处理信号（pending signal)，在任何时刻，一种类型至多只会有一个待处理信号
- 一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量e中维护着被阻塞的信号集合

8.5.2  发送信号

Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于**进程组**（processgroup)

1. 进程组，每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的

2. 用**/bin/kill** 程序发送信号/bin/kill 程序可以向另外的进程发送任意的信号

3. 从键盘发送信号，Unix shell 使用作业(job)这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业

   ![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-28.png)

4.用 **kill** 函数发送信号进程通过调用 kill 函数发送信号给其他进程(包括它们自己）

5.用 **alarm** 函数发送信号进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号



8.5.3  接收信号

每个信号类型都有一个预定义的默认行为 ，是下面中的一种：

- 进程终止。
- 进程终止并转储内存
- 进程停止(挂起)直到被 SIGCONT 信号重启
- 进程忽略该信号



signal 函数可以通过下列三种方法之一来改变和信号 Signum 相关联的行为：

- 如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号。

- 如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为

- 否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做设置信号处理程序（installing the handler)，调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号

  ![](https://gitee.com/andylinchuanxin/bookimagehome/raw/master/img/8-31.png)



8.5.4 阻塞和解除阻塞信号

**Linux** 提供阻塞信号的隐式和显式的机制：

1. 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。

2. 显式阻塞机制。应用程序可以使用 **sigprocmask** 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

   

8.5.5  编写信号处理程序

1.  安全的信号处理
2. 正确的信号处理
3. 可移植的信号处理



8.6 非本地跳转

C 语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump), 它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列



8.7 操作进程的工具

Linux 系统提供了大量的监控和操作进程的有用工具。

1. STRACE: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用-static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹
2. PS: 列出当前系统中的进程（包括僵死进程）
3. TOP: 打印出关于当前进程资源使用的信息
4. TOP: 打印出关于当前进程资源使用的信息
5. PMAP: 显示进程的内存映射
6. /proc: —个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入cat/proc/loadavg，可以看到你的 Linux 系统上当前的平均负载