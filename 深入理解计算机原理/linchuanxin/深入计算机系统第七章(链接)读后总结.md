链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行



链接可以执行于:

- 编译时,也就是在源代码被翻译成机器代码时
- 加载时,也就是在程序被加载器加载到内存并执行时
- 运行时,也就是由应用程序来执行

**在现代系统中，链接是由叫做链接器（linker)的程序自动执行的。**



理解链接的意义:

1. 理解链接器将帮助你构造大型程序
2. 理解链接器将帮助你避免一些危险的编程错误
3. 理解链接将帮助你理解语言的作用域规则是如何实现的
4. 理解链接将帮助你理解其他重要的系统概念
5. 理解链接将使你能够利用共享库

讨论:**从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接**

环境：**一个运行Linux 的x86-64 系统，使用标准的ELF-64(此后称为ELF)**

7.1	编译器驱动程序

大多数编译系统提供编译器驱动程序, 它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/TIM截图20200619102529.png)

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-2.png)

7.2静态链接

静态链接器（static linker)

构造可执行文件，链接器需要:

- 符号解析(symbol resolution)
- 重定位（relocation)

链接器的一些基本事实：**目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程**
**序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置**



7.3目标文件

三种形式:

1. 可重定位目标文件,**包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件**
2. 可执行目标文件,**包含二进制代码和数据，其形式可以被直接复制到内存并执行**
3. 共享目标文,**一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接**

第一个Unix 系统使用的是x.out 格式,至今也是,可执行文件还是.out结尾

各系统可执行文件:

- Windows 使用可移植可执行（Portable Executable, PE)格式
- MacOS-X 使用Mach-0 格式
- x86-64 Linux 和Unix 系统使用可执行可链接格式（Executable And LinkableFormat ELF)



7.4  可重定位目标文件

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-3.png)

1. ELF 头（ELF header)以一个16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序
2. ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息
   - 包括ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（X86-64) ,节头部表（section header table)的文件偏移，以及节头部表中条目的大小和数量
   - 不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)



一个典型的ELF 可重定位目标文件包含下面几个节：

- .text: 已编译程序的机器代码

- .rodata: 只读数据，比如print语句中的跳转

- .data

- .bass

- .symtab

- rel.text

- .rel.data

- debug

- .line

- .strtab

  ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-3-1.png)



7.5 符号和符号表

每个可重定位目标模块m 都有一个符号表，它包含m 定义和引用的符号的信息

链接器的上下文中，有三种不同的符号:

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-3-2.png)

**COMMON 和.bss 的区别**:

COMMON 未初始化的全局变量
.bss 未初始化的静态变量，以及初始化为0的全局或静态变量



7.6 符号解析

静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字

- 7.6.1 链接器如何解析多重定义的全局符号

  在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。**函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号**。

  根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名
  * 规则1: 不允许有多个同名的强符号。
  * 规则2: 如果有一个强符号和多个弱符号同名，那么选择强符号。
  * 规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个

- 7.6.2 与静态库链接

  - 将所有相关的目标模块打包成为一个单独的文件，称为静态库（static library), 它可以用做链接器的输人

  - 当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块

  - 在Linux 系统中，静态库以一种称为存档（archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a 标识

    ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-8.png)

- 7.6.3 链接器如何使用静态库来解析引用



7.7 重定位

这个步骤中，将合并输人模块，并为每个符号分配运行时地址。重定位由两步组成:

- 重定位节和符号定义

- 重定位节中的符号引用

  7.7.1 重定位条目

  **无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将**
  **目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text 中。已初始化数据的重定位条目放在.rel.data 中**

  ELF 定义了32 种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定货类型：

1. R_X86_64_PC32 重定位一个使用32 位PC 相对地址的引用

2. R_X86_64_32 重定位一个使用32 位绝对地址的引用

   

使用在指令中编码的32 位值作为有效地址，不需要进一步修

这两种重定位类型支持X86-64 小型代码模型（small code model), 该模型假设可执行目标文件中的代码和数据的总体大小小于2GB, 因此在运行时可以用32 位PC 相对地址来访问。

​	7.7.2 重定位符号引用

7.8 可执行目标文件

链接器如何将多个目标文件合并成一个可执行目标文件

典型的ELF 可执行文件中的各类信息如下:

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-13.png)

**可执行目标文件的格式类似于可重定位目标文件的格式**

7.9 加载可执行目标文件

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-15.png)

**在Linux X86-64系统中，代码段总是从地址0x400加0 处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc 库往上增长**



用户栈总是从最大的合法用户地址（2^48 -1)开始，向较小内存地址增长。栈上的区域，从地址2^48 开始，是为内核（kernel)中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分

注意:

1. 实际上，由于.data 段有对齐要求， 所以代码段和数据段之间是有间隙的
2. 在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化



7.10 动态链接共享库

静态库仍然有一些明显的**缺点**:

静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接

**内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性**

**动态库**:

1. 共享库（shared library)是致力于解决静态库缺陷的一个现代创新产物。
2. 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)是由一个叫做动态链接器（dynamic linker)的程序来执行的。共享库也称为共享目标（shared object) 在Linux 系统中通常用.so后缀来表示。

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-16.png)

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-16-1.png)

**动态链接器通过执行下面的重定位完成链接任务:**

- 重定位libc.so 的文本和数据到某个内存段。
- 重定位libvector.so 的文本和数据到另一个内存段。
- 重定位prog21 中所有对由libc.so 和libvector.so 定义的符号的引用。
- 最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定
  了，并且在程序执行的过程中都不会改变。



7.11 从应用程序中加载和链接共享库

动态链接是一项强大有用的技术:

- 分发软件
- 构建高性能Web 服务

**其思路是将每个生成动态内容的函数打包在共享库中**

7.12 位置无关代码

**共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源**

多个进程是如何共享程序的一个副本?如下:

- 一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库---------->空间的使用效率不高,难管理
- 要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本
- 可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code, PIC)用户对GCC 使用-fpic 选项指示GNU 编译系统生成PIC 代码。共享库的编译必须总是使用该选项
- 在一个x86_64 系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为PIC可以用PC 相对寻址来编译这些引用，构造目标文件时由静态链接器重定位



1. PIC 数据引用

   想要生成对全局变量PIC 引用的编译器利用了这个事实，它在数据段开始的地方创建
   了一个表，叫做全局偏移量表（Global Offset Table, GOT)

   ![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-18-3.png)

2. PIC 函数调用



7.13 库打桩机制

Linux 链接器支持一个很强大的技术，称为库打桩（library interpositioning), 它允许你截获对共享库函数的调用，取而代之执行自己的代码

**基本思想**：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者

**打桩可以发生在编译时**、链接时或当程序被加载和执行的运行时。要研究这些不同的机制，我们以图7-20a 中的示例程序作为运行例子。它调用C 标准库（libc.so)中的mal-Iwc 和free 函数。对irnUoe 的调用从堆中分配一个32 字节的块，并返回指向该块的指针。对free 的调用把块还回到堆，供后续的malloc 调用使用。我们的目:标是用打桩来追踪程序运行时对malloc 和free 的调用

7.13.1 编译时打桩

![](https://gitee.com/andylinchuanxin/bookimagenew/raw/master/img/7-19.png)

7.13.2 链接时打桩

7.13.3 运行时打桩

编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的LD_PRELOAD 环境变量



7.14 处理目标文件的工具

在Linux 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils 包尤其有帮助，而且可以运行在每个Linux 平台上。
•AR: 创建静态库，插人、删除、列出和提取成员。
•STRINGS: 列出一个目标文件中所有可打印的字符串。
•STRIP: 从目标文件中删除符号表信息。
• NM: 列出一个目标文件的符号表中定义的符号。
•SIZE: 列出目标文件中节的名字和大小。
•READELF: 显示一个目标文件的完整结构，包括ELF 头中编码的所有信息。包含
SIZE 和NM 的功能。
•OBJDUMP: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大
的作用是反汇编.text 节中的二进制指令。
Linux 系统为操作共享库还提供了LDD 程序：
•LDD: 列出一个可执行文件在运行时所需要的共享库。