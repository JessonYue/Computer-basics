## 计算机系统漫游

计算机系统是由`硬件`和`系统软件组成`组成的，它们共同工作来运行应用程序。

以下是一个简单的hello程序，尽管简单，但是为了让他运行，系统的每个主要组成部分都要协调工作。

```c
//hello.c
#include <stdio.h>

int  main(){
    printf("hello,world\n");
    return 0;
}
```

我们通过跟踪hello程序的`生命周期`来开始对系统的学习——**创建**->在系统上**运行**->**输出简单的消息**->**终止**。

### 信息就是位+上下文


hello程序的生命周期是从一个源程序（或者说原文件）开始的，即通过编辑器创建并保存的文件，文件名为hello.c。源程序实际上就是由0和1组成的位（又称为比特）序列，**8个位组成一组，称为字节**。

大部分的现代计算机使用的是`ASCII`标准来表示字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示字符，由美国有关标准化组织提出。

在计算机中，所有的数据在存储和运算时都要使用`二进制`数表示（因为计算机用高电平和低电平分别表示1和0）。例如像a、b、c这样的52个字符（包括大小写）以及0、1等数字还有一些常用的符号在计算机也是使用`二进制`来表示。区分不同数据对象的唯一方法是我们读到这些数据对象的上下文。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

### 程序被其它程序翻译成不同的格式

为了在系统上能够运行hello.c程序，每条C语句都必须被其他程序转化为一系列`机器语言`指令。然后这些指令按照一种称为`可执行目标程序`的格式打包好，并以二进制磁盘文件的形式存放起来。目标程序也称为`可执行目标文件`。

在Unix系统上，从原文件到目标文件的转化是由`编译器驱动程序`完成的：

> linux> gcc -o hello hello.c

以上命令会将hello.c文件翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段，如图所示。

![图1 编译系统(出自《深入理解Android系统》)](https://user-gold-cdn.xitu.io/2020/6/6/17289b25bc678a75?w=794&h=124&f=png&s=85680)

- **预处理阶段**。预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如hello.c中#include <stdio.h>告诉预处理器将系统头文件stdio.h的内容替换#include <stdio.h>。结果得到另一个C程序，通常以.i作为文件扩展名。
- **编译阶段**。编译器(ccl)将文本文件hello.i翻译成`汇编语言程序`,扩展名为.s。
- **汇编阶段**。汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成`可重定位目标程序`的格式，并将结果保存在目标文件hello.o中。
- **链接阶段**。连接器(ld)负责将hello.o中引用的printf函数存在的printf.o目标文件和启动器合并到hello.o中，最后生成一个可执行文件。

### 了解编译系统如何工作的好处

- **优化程序性能**。
- **理解链接是出现的错误**。
- **避免安全漏洞**。


### 处理器运行内存中的指令

此时，hello.c已经被编译成可执行文件hello,在shell中运行./hello将会打印出hello,world。

### 系统的硬件组成

1. **总线**，贯穿整个系统的是一组管道，称作总线，它负责各个部件间信息的传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。
2. **I/O设备**，I/O(输入/输出)设备是系统与外部联系的通道。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于他们的封装方式。***控制器**是I/O设备本身或者系统的主印刷电路板（通常称作主板）上的芯片组。而**适配器**是一块插在主板插槽上的卡*。
3. **主存**，一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，由一组`动态随机存取存储器(DRAM)`芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。
4. **处理器**，中央处理单元(CPU)，是解释（执行）存储在主存中的指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为**程序计数器（PC）**。在任何时刻，PC都指向主存中的某条机器语言指令。

![一个典型的硬件组成(出自《深入理解Android系统》)](https://user-gold-cdn.xitu.io/2020/6/6/17289b25c1680fb6?w=570&h=399&f=png&s=152005)

下面是一个简单操作的例子，CPU在指令的要求下可能会执行这些操作。

- **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
- **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上的原来的内容。
- **操作**：把两个寄存器的内容复制到ALU（算术/逻辑单元），ALU对这两个做算术运算，并将结果存放到一个寄存器中，以覆盖原来的内容。
- **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。

#### 运行hello程序

当我们我命令行中输入字符串“./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中，如图所示。

![键盘上读取hello命令](https://user-gold-cdn.xitu.io/2020/6/6/17289b25c650299e?w=624&h=429&f=png&s=213262)

当我们在键盘上敲回车键时，shell程序就知道我们结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。

利用`直接存储器存取（DMA）技术`，*数据可以不通过处理器而直接从磁盘到达主存*。

![从磁盘加载可执行文件到主存](https://user-gold-cdn.xitu.io/2020/6/6/17289b25c809fc04?w=703&h=433&f=png&s=225815)

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello，world\n”字符串中的字节从主存复制到寄存器文件，在从寄存器文件中复制到显示设备。

![将字符串从存储器写到显示器](https://user-gold-cdn.xitu.io/2020/6/6/17289b25c6fd03ef?w=722&h=426&f=png&s=232556)

### 高速缓存

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初在磁盘上，然后复制到主存中；运行时，指令有从主存复制到处理器，最后再到显示器。这些复制就是开销，减慢了程序运行速度。因此，系统设计者的一个主要目标就是**使这些复制操作尽可能快的完成。**

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造假远高于同类的低速设备。

一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而处理器从寄存器文件中读取熟读比从主存中读取几乎要快100倍。随着技术的进步，这一差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易得和便宜的多。

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为`高速缓存存储器`，作为暂时的集结区域，存放处理器近期可能需要的信息。其实这个关系和主存同磁盘的关系类似，程序之所以要加载到内存中执行，就是因为处理器直接从磁盘中读取速度太慢，所以先将程序复制到内存中，加快了程序的运行。这样的关系可以是多级的，如下图所示：

![一个存储器层次结构的示例](https://user-gold-cdn.xitu.io/2020/6/6/17289b25c8024d9c?w=805&h=442&f=png&s=245449)

### 操作系统管理硬件

操作系统有两个基本功能：  
1. 防止硬件被失控的应用程序滥用；
2. 向程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

#### 进程

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好想在独占使用硬件。而`并发`运行，则是说一个进程的指令和另一个进程的指令是交错执行的。一个CPU可以并发地执行多个进程，这是通过CPU在进程间切换来实现的。操作系统实现这种交错执行的机制称为`上下文切换`。

操作系统将进程运行所需的所有状态信息保存在一个数据结构中，称为`进程控制块(Processing Control Block)`，简称PCB，其中包含许多信息，比如PC寄存器文件的当前值，以及主存的内容。**在任何一个时刻，一个CPU只能执行一个进程的代码**。当操作系统把控制权才当前进程转移到另一个新进程时，就会进行`上下文切换`，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程转换到另一个进程是由操作系统`内核(kernel)`管理的。内核是操作系统代码常驻的部分。当应用程序需要操作系统的某些操作时，它就执行一条特殊的`系统调用(system call)`指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

> 注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

#### 线程

线程可以理解为更细粒度的进程，和进程类似的线程也有`线程控制块(TCB)`，用来记录线程的状态和信息。之所以有线程是因为进程间进行上下文切换资源消耗大，而且进程间数据的共享通信实现也比较复杂，而一个进程中可以有多个线程，多个线程又共享这个进程的数据，因此线程比进程更容易共享数据，而且一般来说线程比进程更高效。

考虑这样一种情形，假设我们要播放一个视频文件，可以简单的分为3个步骤，分别为，`解码视频数据`，`解码音频数据`，`同步音视频数据并显示`。如果没有线程，那么我们可能使用3个进程来实现这个功能，首先进程1和进程2分别解码出音视频数据放到各自的`虚拟内存`中，线程3去取出数据，然后再进行同步显示。

这个步骤有两个问题：（1）线程间上下文切换效率不高；（2）线程间的内存空间相互独立，线程3无法轻易的获取到线程1和线程2的数据。

而线程正好可以解决以上两个问题。

#### 虚拟内存

上面的例子中我们说到了`虚拟内存`，实际上`虚拟内存`是一个抽象的概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。**每个进程看到的内存都是一致的，称为`虚拟地址空间`**。

在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程都一样。除了这一部分，其它的地址空间都是进程独立的，每个进程的地址均是由0开始。

![进程的虚拟地址空间](https://user-gold-cdn.xitu.io/2020/6/6/17289ef083a5915b?w=554&h=463&f=png&s=290026)

- **程序代码和数据**。对所有的进程来说，代码是从同一固定地址开始，紧接着是C全局变量相对应的数据位置。代码和数据区在进程一开始时就被指定了大小。
- **堆**。堆主要是存放进程运行时生成的数据，它可以动态的扩容和收缩。
- **共享库**。共享库用来存放像C标准库和数学库这样的共享库的代码和数据区域。
- **栈**。编译器用它来实现函数调用，调用函数时入栈，函数返回后出栈。
- **内核虚拟内存**。为内核保留的区域。

> 总结：这部分内容我们知道了一个程序生成的过程，如何从一个文本文件变成一个可执行的目标文件。了解了计算机的基本硬件结构，总线，I/O设备之间，主存，CPU之间是如何协作运行的，知道为什么要有高速缓存。接下来讲到了操作系统的作用：防止应用程序滥用硬件和像应用提供统一简单的操作硬件的接口。进程，线程，虚拟内存的初步认识。

---

## 信息的表示和处理

1. 各种进制之间转换，在做自定义传输协议时常常用到。  
2. 大多数64位机器向后兼容，因此32位程序依然可以运行在64位机器上，反过来则不行。
3. 基本数据类型分配字节数受到如何编译影响，和在多少位机器上编译无关。
4. 大端法、小端法。这个知识点比较熟悉，在和硬件通过蓝牙进行数据传输时遇到，Android是小端法，而硬件是大端发，无法用结构体直接强转数据，只能通过自己写解析工具来解析。
5. 在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小无关。因而我们编写的程序可以在不同的操作系统上进行移植，只要使用同样的代码在对应的操作系统上，或者使用对应系统的交叉编译工具链编译生成对应的二进制的可执行文件就可以。
6. 布尔代数，逻辑运算符，位运算。
7. 补码和无符号数两种表示，在java中没有无符号数。由二进制数转换补码和无符号数的区别在于二进制最高位的处理，假设是w位的二进制数，补码方式最高位的权值是-2^(w-1)，而无符号数的最高位权值是2^(w-1)，可以得出无符号数比补码表示方法大2^w。

二进制转补码公式：
![二进制转补码](https://user-gold-cdn.xitu.io/2020/6/6/1728a4d6fdeb7470?w=850&h=27&f=png&s=3198)

二进制转无符号数公式：

![二进制转无符号数](https://user-gold-cdn.xitu.io/2020/6/6/1728a543151c8e02?w=850&h=27&f=png&s=4129)

8. B2T和B2U都是双射。
9. 反码，反码和补码的区别在于反码最高有效为的权是-(2^(w-1)-1)而不是-2^(w-1)
10. 有符号数和无符号数之间的转换，不论怎么转换，数值的二进制表示都不变，只是使用不同的方式翻译二进制而已。因此可以使用先转换成二进制，在转换成对应的表示法。也可以由以上的两个公式推导出来。
11. C语言中存在证书表示法的隐式转换，这一点要特别注意！
12. 数字的扩展和截断。无符号数零扩展，补码数值符号扩展。
13. 整数运算，整数运算有点类似时钟，最大值和最小值相接组成一个环，比如27点实际上就是3点。
14. 二进制小数的表示方法。
15. 浮点数表示法和运算。

> 总结，这一部分的内容看的时候还是比较好理解的，就是没有把公式记住，但是可以自己推导出来，如果经常接触相关的开发还是记住比较好吧，增加效率，就像数学考试一样，不可能在考试的时候自己推导公式。

---

## 程序的机器级表示

这部分内容还没有看完，目前看到3.4.1

1、汇编，饭汇编。
2、寄存器介绍。
3、立即数，寄存器，内存引用。
4、立即数寻址、寄存器寻址、绝对寻址，变址寻址，比例变址寻址。通过练习题3.1把这些寻址方式已经弄明白了。

**最后这一周整体的总结：**

这一周的主要任务是阅读《深入理解计算机系统》，对于这本书的阅读原本的心态是打算逐字逐句的把里面涉及到的点都弄懂，不一定都要记住。之所以这样有两个原因：（1）之前有看过大学计算机学生上课用的计算机系统书，所以已经有一定的基础，如果看的快怕会自动选自己熟悉的知识点去看，或者自己会去挑自以为重点的知识看，所以想认真看一遍，类似查漏补缺的方式，遇到熟悉的内容也是认真看，温故而知新。（2）这本书看着很厚，但是内容真的很干，几乎全是知识点，也没什么能跳的，感觉学到的都是赚到的，所以看的慢。

目前进度有些慢，如果拖了班级后腿的话会考虑加快速度阅读，然后自己再有时间慢慢精度。

