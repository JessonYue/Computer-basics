### 信息的表示和处理

由于表示的精度有限，浮点运算是不可结合的。

| C版本        | GCC命令行选项  |
| ------------ | -------------- |
| GNU 89       | 无，-std=gnu89 |
| ANSI,ISO C90 | -ansi,-std=c89 |
| ISO C99      | -std=c99       |
| ISO C11      | -std=c11       |

> GNU项目正在开发一个结合ISO C11和其它一些特性的版本，可以通过命令行选项-std=gnu11来指定。截止到今日已经可使用

#### 2.1 信息存储

大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位。

C语言中一个指针的值是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来。`尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息`。

##### 2.1.1 十六进制表示法

##### 2.1.2 字数据大小

##### 2.1.3 寻址和字节顺序

小端法：最低有效字节在最前面的方法。  
大端法：最高有效字节在最前面的方法。

Android和iOS使用的是小端法。

##### 2.1.4 表示字符串

C语言中字符串被编码为一个null（0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的就是ASCII字符码。

##### 2.1.6 布尔代数简介

&（按位与），|（按位或），~（按位取反），^（按位异或)  

a&(b|c) = (a&b)|(a&c),a|(b&c) = (a|b)&(a|c)

##### 2.1.7 C语言中的位级运算

##### 2.1.8 C语言中的逻辑运算

##### 2.1.9 C语言中的移位运算

#### 2.2 整数表示

##### 2.2.3 补码编码

![image](https://upload-images.jianshu.io/upload_images/1360972-bce0be88034f7b7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

正数的补码是正数，负数的补码为反码+1

w位表示的`最大的补码`和`最小的补码`。  

假设w = 8，那么这个二进制数在java中可以认为是一个byte，一个byte 8位。 

那么根据以上公式可以求得： 

最大的补码 = 01111111 = 2^7-1 =127  
最小的补码 = 10000000 = -2^7 = -128  

这也是java中byte能表示的最大值和最小值，其它数据类型类似。  


##### 2.2.4 有符号和无符号数之间的转换

一般规则：数值可能会改变，但是位模式不变。

数值会变的原因实际上就是B2T和B2U的解释方式不同而已，B都是一样的。

因此，有符号数和无符号数之间的转换可以通过位模式作为桥梁来实现，例如：

U2T = B2T(U2B),T2U = B2U(T2B)

-负数的有符号表示（补码）+无符号表示 = 2^w，w表示为数，例如

10000001u = 2^7+1 = 129  
10000001  = -2^7+1 = -127   
-127+129 = 256 = 2^8

> 练习题2.19  
>
> T2U,w = 4
>
> -8 = 2^4-8 = 8u  
> -3 = 2^4-3 = 15u  
> -1 = 16-1 = 15u  
> -2 = 16-2 = 14u  
> 0 = 0  
> 5 = 5


**无符号数转换为补码(U2T)**  

对满足0<=u<=UMax,w位的u有：  
```java
if(u<=TMax){
    U2T = u;
}else{
    U2T = u-2^w;
}
```

在实际应用开发中，比如使用idea断点调试返回的byte数组中，我们看到的每一个数都是以补码的形式展示出来的，而我们定义的文档一般都是16进制，因为我们要直接看出返回数据是否符合文档要求，实际上需要的是T2B的能力，B用16进制表示。

直接T2B比较困难，一般我们可以先T2U，然后在U2B，即`T2B = U2B(T2U)`这个公式比较常用。