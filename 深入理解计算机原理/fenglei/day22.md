###  第十二章 并发编程

* 应用及并发可以应用到一下场景
  * 访问慢速的 I/O 设备。当一个应用正在等待来自慢速 I/O 设备的数据到达时，内核会运行其他进程，使 CPU 保持繁忙。每个应用都可以按照类似的方式，通过交替执行 I/O 请求和其他有用的工作来利用并发
  * 与人交互。和计算机交互的人要求计算机有同时执行多个任务的能力。
  * 通过推迟工作以降低延迟。应用程序能通过推迟其他操作和并发的执行它们，利用并发来降低某种操作的延迟
  * 服务多个网络客户端
  * 在多核机器上进行并行计算
  * 进程，每个逻辑流都是一个进程，由内核来调度和维护
  * I/O 多路复用
  * 线程

##### 基于 I/O 多路复用的并发编程

* select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序

```c
#include <sys/select.h>
// 返回已经准备好的描述符的非零的个数，出错返回 -1
int select(int n, fd_set* fdset,NULL,NULL,NULL);

FD_ZERO(fd_set *fdset);
FD_CLR(int fd, fd_set *fdset);
FD_SET(int fd, fd_set *fdset);
FD_ISSET(int fd, fd_set *fdset);
```

##### 基于 I/O 多路复用的并发事件驱动服务器

* 状态机：就是一组状态，输入事件和转移
  * 转移：将状态和输入事件映射到状态，每个转移是将一个（输入状态，输入事件）对映射到一个输出状态。
  * 自循环：通一输入和输出状态之间的转移。

##### 基于线程的并发编程

* 线程就是运行在进程上下文中的逻辑流，每个线程都有自己的上下文，包括唯一的整数线程 ID，栈，栈指针，程序计数器，通用目的寄存器和条件码，所有运行在一个进程里的线程共享该进程的整个虚拟空间

##### 创建线程

```c
#include <pthread.h>
typedef void *(fun)(void *);
// 创建一个新的线程，若成功返回 0，若出错返回非零
int pthread_create(pthread_t *tid, pthread_attr_t *attr, fun *f, void *arg);

// 获取当前线程 ID
pthread_t pthread_self(void);
```

##### 终止线程

* 线程终止有以下几种方式
  * 当顶层线程例程返回时，线程会隐式的终止
  * 调用 pthread_exit 线程会显式的终止
  * 某个线程调用 Linux 的 exit() 函数，该函数终止进程以及所有与该进程有关的线程
  * 对等线程通过以当前线程 ID 作为参数调用 pthread_cancle 函数来终止当前线程

```c
#include <pthread.h>
// 终止一个线程 从不返回任何值
void pthread_exit(void *thread_return);
```

##### 回收已终止的线程资源

* 线程通过调用 pthread_join 函数等待其他线程终止

```c
#include <pthread.h>
// 等待线程终止，成功返回 0，出错返回非零
int pthread_join(pthread_t tid, void **thread_return)
```

##### 分离线程

* 在任何一个时间点上线程是结合的或者是分离的
  * 结合的线程能够被其他线程回收或杀死，再被其他线程回收之前，它的内存资源（例如栈）是不释放的
  * 分离的线程是不能被其他线程回收或杀死的，它的内存资源在它终止时由系统自动释放

```c
#include <pthread.h>
// 分离可结合线程 tid，线程能够通过 pthread_selef 为参数调用该函数分离自己
int pthread_detach(pthread_t tid);
```

##### 初始化线程

* pthread_once 函数用来初始化与线程例程相关的状态

```c
#include <pthread.h>

pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control,void (*init_routine)(void));
```

#### 用信号量同步线程

##### 信号量

* 信号量 s 是具有非负整数值的全局变量，只有由两种特殊的操作来处理，两种操作称为 P 和 V
  * P：如果 s 是非零的，那么 P 将 s 减 1，并且立即返回。如果 s 为零，那么就挂起这个线程，直到 s 变为非零，而一个 V 操作会重启这个线程。在重启之后，P 操作将 S - 1，并将控制返回给调用者
  * V：V 操作将 S 加 1。如果有任何线程阻塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1，完成 P 操作

```c
#include <semaphore.h>
// 将信号量 sem 初始化为 value。每个信号量在使用前必须初始化
int sem_init(sem_t *sem, 0, unsigned int value);
int sem_wait(sem_t *s);
int sem_post(sem_t *s);

#include "csapp.h"
// 通过下面两个函数来执行 P V 操作
void P(sem_t *s);
void V(sem_t *s):
```

##### 使用信号量来实现互斥

* 在一个互斥锁上执行 P 操作称为堆互斥锁加锁，在一个互斥锁上执行 V 操作称为对出斥锁解锁，对一个互斥锁加了锁但是没有解锁称为占用这个互斥锁

##### 利用信号量来调度共享资源

* 生产者-消费者
  * 生产者线程反复的生成新的项目（item），并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这个项目，然后使用它们。也可能有多个生产者和消费者的变种

* 读者-写者
  * 读者-写者问题是互斥问题的一个概括。一组并发的线程要访问一个共性对象。

#### 其他并发问题

##### 线程安全

* 线程不安全的函数类有四种
  * 不保护共性变量的函数。
  * 保持跨越多个调用的状态的函数（static）
  * 返回指向静态变量的指针函数
  * 调用线程不安全函数的函数

##### 死锁

* 使用二元信号量来实现互斥时，可以指定规则来避免死锁
  * **给定所有互斥锁操作的一个全序，如果每个线程都是以一种顺序获得互斥梭并以相反的顺序释放，那么这个程序就是无死锁的**