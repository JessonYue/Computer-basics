### 第八章 异常控制流

* 从处理器通电开始，直到你断电为止，程序计数器假设一个值的序列  a0，a1，a2 ... a(n-1)，其中每个 a(k) 是某个相应的指令 I(k) 的地址。每次从  a(k) 到 a (k+1) 的过度称为控制转移。这样的控制转移序列叫做处理器的控制流
* 现代系统通过控制流发生突变来对系统状态的变化做出反应，我们把这些突变称为异常控制流（CEF）

#### 异常

* 异常就是控制流中的突变，用来响应处理器状态中的某些变化
* 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序），当异常处理程序完成处理后，根据引起异常的事件的类型，会发送以下三种情况
  * 处理程序将控制返回给当前指令，即当前事件发生时正在执行的指令
  * 处理程序将控制返回给下一条指令，如果没有异常将会执行下一条指令
  * 处理程序终止被中段的程序

##### 异常处理

* 在系统启动时（当计算机重启或这通电时），操作系统分配和初始化一张称为异常表的跳转表，使得表木 k 包含异常 k 的处理程序的地址
* 在运行时（当系统执行某个程序时），处理器检测的发送了一个事件，并且确定了相应的异常号 k，随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k 跳转到相应的处理程序的地址
* 异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基地址寄存器的特殊 CPU 处理器里，异常类似于过程调用，但有一些重要的不同之处
  * 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）
  * 处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序也会需要这些状态
  * 如果控制从用户程序转到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中
  * 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限

##### 异常的类别

异常可以分为四类

| 类别 |        原因         | 异步/同步 |       返回行为       |
| :--: | :-----------------: | :-------: | :------------------: |
| 中断 | 来自 I/O 设备的信号 |   异步    | 总是返回到下一条指令 |
| 陷阱 |     有意的异常      |   同步    | 总是返回到下一条指令 |
| 故障 |  潜在可恢复的错误   |   同步    |   可能返回当前指令   |
| 终止 |   不可恢复的错误    |   同步    |       不会返回       |

* 中断是异步发生的，是来自处理器外部的 I/O 设备的信号结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序，剩下的异常类型是同步发生的，是执行当前指令的结果。我们把指令叫做故障指令
* 陷阱和系统调用，陷阱是有意的异常，是执行指令的结果。就像中断处理程序一样，陷阱处理程序将返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用
  * 用户程序经常需要向内核请求服务，比如一个文件，创建一个新的进程，加载一个新的程序，或者终止当前进程。为了允许这些内核服务的受控访问，处理器提供了一条特殊的 “ syscall n”  指令，当用户想要请求服务 n 时，可以执行这条指令。这条指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序

* 故障是由错误引起的，它们能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误，它就返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 进程，abort 进程会终止引起故障的程序。

* 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序，处理程序将控制返回给 abort 进程，该进程会终止这个程序

#### Linux/x86-64 系统中的异常

*  x86-64 系统定义了 256 种不同的异常类型。0 ~ 31 的号码对应的是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都是一样的。 32 ~ 255 的号码对应的是操作 系统定义的中断和陷阱

|  异常号  |        描述        |  异常类别  |
| :------: | :----------------: | :--------: |
|    0     |      除法错误      |    故障    |
|    13    |    一般保护故障    |    故障    |
|    14    |        缺页        |    故障    |
|    18    |      机器检查      |    终止    |
| 32 ~ 255 | 操作系统定义的异常 | 中断或陷阱 |

* 除法错误，当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把错误报告为 浮点异常
* 一般保护故障，许多原因都会导致不为人知的一般保护故障，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把错误报告为 段故障
* 缺页 是会重新执行产生故障的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物流内存的一个页面，然后重新执行这条产生故障的指令。
* 机器检查 是在导致故障的指令执行中检测到致命的硬件错误发生时。机器检查处理程序从不返回控制给应用程序

* 在 x86-64 系统上，系统调用是通过一条 syscall 的陷阱指提供的，所有 Linux 系统调用都是通过寄存器而不是栈转发的。按照惯例 寄存器 ax 包含系统调用号，寄存器 di，si，dx，10，8 和  9 包含最多 6 个参数，第一个参数在 di 中，第二个在 si 中以此类推。从系统调用返回时，寄存器 cx 和 r11 都会被破坏，ax 包含返回值 -4095 到 -1 之间的负数返回值表明发生了错误，对应于负的 errno

| 编号 | 名字  |        描述        | 编号 |  名字  |         描述         |
| :--: | :---: | :----------------: | :--: | :----: | :------------------: |
|  0   | read  |       读文件       |  33  | pause  | 挂起进程直到信号到达 |
|  1   | wirte |       写文件       |  37  | alarm  |  调度警告信号的传送  |
|  2   | open  |      打开文件      |  39  | getpid |      获取进程ID      |
|  3   | close |      挂壁文件      |  57  |  fork  |       创建进程       |
|  4   | stat  |    获得文件信息    |  59  | execve |     执行一个程序     |
|  9   | mmap  | 将内存页映射到文件 |  60  | _exit  |       终止进程       |
|  12  |  brk  |      重置堆顶      |  61  | wait4  |   等待一个进程终止   |
|  32  | dup2  |   赋值文件描述符   |  62  |  kill  |  发送信号到一个进程  |

#### 进程

* 进程是一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需状态组成的。这个状态包括存放在内存中的程序代码和数据，栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合
* 进程提供给程序的关键抽象有两种
  * 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器
  * 一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统

##### 逻辑控制流

* 进程可以向每个程序提供一种假象，好像它在独占的使用处理器。如果想要调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一的对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做 逻辑控制流，简称逻辑流
  * 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。

##### 并发流

* 一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流称为并发的运行
* 多个流并发的执行一般现象被称为并发，一个进程和其他进程轮流运行的概念称为多任务，一个进程执行它的控制流的一部分的每一个时间段叫做时间片。因此多任务也叫时间分片
* 如果两个流并发的运行在不同的处理器上，称为并行流，它们并行的运行且并行的执行

##### 私有地址空间

* 进程为每个程序提供一种假象，好像它独占的使用系统地址空间，进程为每个程序提供它自己的私有空间，一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读写的。从这个意义上来说地址空间是私有的
* 每个地址空间的内容一般是不同的，但是每个这样的空间都有相同的通用结构
  * 地址空间底部是保留给用户程序的，包括通常的代码，数据，堆和栈段，代码总是从地址 0x400000 开始
  * 地址空间顶部保留给内核（操作系统常驻内存部分），地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序调执行系统调用时）使用的代码，数据和栈

<img src="/Users/fenglei/Documents/learning/day2/img/1592284496064.jpg" alt="1592284496064" style="zoom:50%;" />

##### 用户模式和内核模式

* 处理器通常使用某个控制寄存器中的模式位来提供欧这种功能的，该寄存器描述了当前进程享有的特权（用户模式/内核模式）
* 当设置了位模式时，进程运行在内核模式中，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置
* 当没有设置模式位时，进程就运行在用户模式中，用户模式中的进程不允许执行特权指令，比如停止处理器，改变模式位，或者发起一个 I/O 操作，用户程序必须通过系统调用接口间接的访问内核代码和数据

##### 上下文切换

* 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态
* 在进程执行的某些时刻，内核可以决定抢占进程，并重新开始一个先前被抢占了的进程，这种决策就叫做调度，是由内核中称为调度器的代码处理的。

#### 系统调用错误处理

```c
void unix_error(char *msg) /* Unix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork(void) 
{
    pid_t pid;

    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}

pdi = Fork();
```

#### 进程控制

* Unix 提供了大量从 C 程序中操作进程的系统调用

##### 获取进程 ID

* 每个进程都有一个唯一的正数进程 ID（PID）

```c
#include <sys/types.h>
#include <unistd.h>

// 返回调用进程的 PID
pid_t getpid(void);
// 返回它的父进程的 PID(创建调用进程的进程)
pid_t getppid(void);
```

##### 创建和终止进程

*  进程可以认为总是处于三种状态之一
  * 运行：进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度
  * 停止：进程的执行被挂起，且不会被调度。当收到 SIGSTOP，SIGT-STP，SIGTTIN 或 SIGTTOU 信号时，进程就会停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻进程再次开始运行
  * 终止：进程永远的停止了。进程会停止的原因有三个
    * 收到一个信号，该信号的默认行为是终止进程
    * 从主程序中返回
    * 调用 exit 函数

```c
#include <stdlib.h>
// exit 以 status 退出状态来终止进程
void exit(int status)
```

* 新创建的子进程几乎但不完全与父进程相同，两者最大的区别在于它们有不同的 PID
* fork 函数s
  * 调用一次，会返回两次。一次是在调用进程（父进程）中，一次是在新创建的子进程中，在父进程中 fork 返回子进程的 PID，在子进程中 fork 返回 0。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序时父进程还是子进程执行
  * 并发执行。父进程和子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令。
  * 相同但是独立的地址空间。两个进程地址空间是相同的，然而又是互相独立的进程，它们都有自己的地址空间
  * 共享文件。当运行这个程序时，父进程和子进程都把它们输出到屏幕上。

##### 子进程回收

* 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，知道被它的父进程回收。当一个终止了还未被回收的进程称为僵死进程
* 当一个父进程终止了，内核会安排一个 init 进程称为子进程的养父。init 进程的 PID 为 1，是系统启动时由内核创建的，它不会终止，是所有进程的祖先，如果父进程没有回收僵死进程就终止了，init 进程会回收它们

```c
#include <sys/types.h>
#include <sys/wait.h>
/* 
	一个进程可以调用 waitpid 函数来等待它的子进程终止或停止
	pid 
	判断等待集合的成员  pid > 0 等待集合就是一个单独的子进程，它的进程 ID 就是 pid,pid = -1 等待集合就是有父进程所有的子进程组成
	statusp 
	如果是非空的，waitpid 就会在 status 中放上关于导致返回的子进程的状态信息
	options 
	常量 0,WHOHANG,WUNTRACED,WCONTINUED
	0 waitpid 挂起调用进程的执行，直到它的等待集合中的一个子进程终止，返回已终止子进程的 PID
	WHOHANG 如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0）
	WUNTRACED 挂起调用进程的执行，直到等待集合中的一个进程编程已终止或者被停止，返回 导致返回的 （已终止或已停止）的 PID
	WCONTINUED  挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行
	可以用运算符组合 比如 WHOHANG | WUNTRACED
	
	如果调用进程中没有子进程 返回 -1，设置 errno 为 ECHILD
	如果 waitpid 函数被一个信号中断，返回 -1 设置 errno 为 EINTR
*/
pid_t waitpid(pid_t pid,int *statusp,int options);
```

##### 让进程休眠

* sleep 函数将一个进程挂起一段指定的时间

```c
#include <unistd.h>
// 如果请求的时间已到，返回 0，否则返回剩下的休眠秒数
unsigned int sleep(unsigned int secs);


#include <unsitd.ht>
// 让调用函数休眠，直到该进程收到一个信号
int pause(void);
```

##### 加载并允许程序

* execve 函数在当前进程的上下文中加载并允许一个新程序，execve 加载 filename，且带参数列表 argv 和环境变量 envp，只有当出现错误时，才会返回调用程序，否则从不返回，参数列表和环境变量都是 key - value 形式

```c
#include <unstid.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
```

#### 信号

* 信号允许进程和内核中断其他进程，一个信号就是一条小信息，它通知系统发生了一个某种类型的事件。
* 每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的
* 信号提供了一种机制，通知用户发送了哪些异常。比如，一个进程试图除以 0，内核就会发送给它一个 SIGFPE（号码 8） 信号

<img src="/Users/fenglei/Documents/learning/day2/img/1592290227508.jpg" alt="1592290227508" style="zoom:50%;" />

##### 信号术语

* 发送一个信号到目的进程是由两个不同步骤组成的
  * 发送信号：内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程，发送信号可以有两种原因，一个进程可以发送信号给自己
    * 内核检测到一个系统事件，比如除零错误或者子进程终止
    * 一个进程调用了 kill 函数
  * 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，或者通过执行 叫 信号处理程序 的用户层函数捕获这个信号

* 一个发出而没有被接收的信号叫做待处理信号，在任何时刻，一种类型至多会有一个待处理信号

##### 发送信号

* Unix 提供了大量发送信号的机制，所有的机制都是基于进程组这个概念的

##### 进程组

* 每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的

```c
#include <unistd.h>
// getpgrp 函数返回进程组 ID
pid_t getpgrp();
```

* 一个父进程和它的子进程默认同属于一个进程组，可以通过 set-pgid 来改变自己或者其他进程的进程组

```c
#include <unistd.h>
// 将 pid 的组改为 pgid
// pid 为 0 就使用当前的进程 PID 
// pgid 为 0 就使用 pid 指定的进程的 pid 作为进程组 ID
int setpgid(pid_t pid,pid_t pgid);
```

* 进程通过 kill 函数发送信号给其他进程

```c
#include <sys/types.h>
#include <signal.h>
// pid > 0   kill 函数发送 sig 信号给进程 pid
// pid = 0   kill 函数发送 sig 信号给调用进程所在进程组的每个进程
// pid < 0   kill 函数发送 sig 信号给 |pid| 进程组中的每个进程
int kill(pid_t pid, int sig)
```

* 进程通过调用 alarm 函数向它自己发送 SIGALRM 信号

```c
#include <unsitd.h>
// 安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程
// 返回前一次闹钟的秒数，若以前没有设置闹钟，则为 9
unsigned int alarm(unsigned int secs);
```

