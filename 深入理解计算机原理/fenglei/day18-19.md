### 第九章 虚拟内存

* 虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它的每一个进程提供了一个大的，一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力
  * 它将主存看成是一个储存在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并且根据需要在磁盘和主存之间来回传送数据
  * 它为每个进程提供了一致的地址空间，从而简化了内存管理
  * 它保护了每个进程的地址空间不被其他进程破坏

* 虚拟内存的概念
  * 虚拟内存是内存的核心。理解虚拟内存将帮助我们更好的理解系统通常是如何工作的
  * 虚拟内存是强大的。

#### 物理和虚拟寻址

* 物理寻址：计算机系统的内存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（PA），第一个字节地址为 0，接下来的字节地址为 1，再下一个为 2
* 虚拟寻址：CPU 生成一个虚拟地址（VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将虚拟地址转成物理地址的任务叫做地址翻译。CPU 芯片上叫做内存管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理

#### 地址空间

* 地址空间是一个非负整数地址的有序集合
  * 在一个带有虚拟内存的系统中，CPU 从一个有 N = 2^n 个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间
  * 一个地址空间的大小是由表示最大地址所需要的位数来描述的
  * 一个系统还有一个物理地址空间，对应于系统中物理内存的 M 个字节

#### 虚拟内存作为缓存的工具

* 虚拟内存被组织成一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。
  * 每个字节都有一个唯一的虚拟地址，作为数组的索引
  * 数组的内容被缓存到主存中

* 磁盘上的数据被分割为块，作为磁盘和主存（较高层）之间的传输单元
  * 系统将虚拟内存分割称为虚拟页（VP）的大小固定的块
  * 每个虚拟页大小为 P = 2 ^p 字节
  * 物理内存被分为物理页，大小也为 P 字节，被称为页帧

* 在任何时刻，虚拟页面的集合都分为三个不相交的子集
  * 未分配的：VM 系统还未分配（或创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间
  * 缓存的：当前已缓存在物理内存中的已分配页
  * 未缓存的：未缓存在物理内存中的已分配页

##### DRAM  缓存组织结构

* 术语 SRAM 缓存表示位于 CPU 和主存之间的 L1，L2 和 L3 高速缓存，术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存缓存中缓存虚拟页

##### 页表

* 页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟页转换为物理地址时，都会读取页表。操作系统维护页表的内容，以及在磁盘和 DRAM 之间来回传送页
* Linux 中 getrusage 函数可以监测缺页的数量

#### 虚拟内存作为内存管理的工具 

* 操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间，不同进程多个虚拟页面可以映射到相同的一个共享物理页上
* 简化链接：独立的地址空间运行每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处
* 简化加载：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件，将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux 提供了 mmap 函数运行应用程序自己做内存映射

#### 地址翻译

<img src="/Users/fenglei/Documents/learning/day2/img/1592454204714.jpg" alt="1592454204714" style="zoom:50%;" />

##### 结合高速缓存和虚拟内存

* 任何既使用虚拟内存又使用 SRAM 高速缓存的系统中，通常都使用物理寻址

##### 利用 TLB 加速地址翻译

* 每次 CPU 产生一个虚拟地址，内存管理单元（MMU）就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址。这会造成开销，MMU 中包含了一个关于 PTE 的小的缓存，称为翻译后备缓冲器（TLB）
* TLB 是一个小的，虚拟寻址的缓存，其中每行都保存着一个由单个 PTE 组成的块，TLB 通常有高度的两联度

* TLB 命中步骤
  * CPU 产生一个虚拟地址
  * MMU 从 TLB 中取出相应的 PTE
  * MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存
  * 高速缓存/主存 将所请求的数据返回给 CPU

* 当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，新取出的 PTE 存放在 TLB 中，可能会覆盖一个已存在的条目

#### 内存映射

* Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到以下两种类型的对象中的一种
  * Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件
  * 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零

##### 共享对象

* 内存映射提供了一种清晰的机制，用来控制多个进程如何共享对象

* 一个对象可以被映射到虚拟内存的区域，要么作为共享对象，要么作为虚拟对象
  * **如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，都是可见的，这些变化也会反应到磁盘的原始对象中**
  * **一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反应在磁盘的对象中**

* 一个映射到共享对象的虚拟内存叫做共享区域。类似的也有私有区域

* 私有对象使用一种叫做**写时复制**的巧妙技术被映射到虚拟内存，只要没有进程试图写自己的私有区域，它们就可以共享物理内存中对象的一个单独副本。反之，这个写操作就会触发一个保护故障
  * 当触发保护故障时，物理内存就会创建一个新的副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限

##### fork 函数

* fork 函数用来创建一个带有独立虚拟地址空间的新进程
  * 当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配一个唯一的 PID，为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct，区域结构和页表的原样副本，它将两个进程中的每个页面都标为只读，并将两个进程中的每个区域结构都标记为私有的写时复制

##### execve 函数

* execve 函数加载和执行程序， 

```c
// 假设
execve("a.out",null, null)
```

* 上述代码执行以下几个步骤
  * 删除已存在的用户区域
  * 映射私有区域
  * 映射共享区域
  * 设置程序计数器

##### mmap 函数

* mmap 函数可以创建新的虚拟内存区域，并将对象映射到这些区域中s

```c
#include <unistd.h>
#include <sys/mman.h>
/**
成功返回指向映射区域的指针，出错则为 MAP_FAILED (-1)
参数 port 包含描述新映射的虚拟内存区域的访问权限位
PROT_EXEC: 这个区域内的页面由可以被 CPU 执行的指令组成
PROT_READ: 这个区域内的页面可读
PROT_WRITE: 这个区域内的页面可写
PROT_NONE: 这个区域内的页面不能被访问
*/
void *mmap(void *start, size_t length, int port, int flags, int fd, off_t offset);
```

* munmap 函数删除虚拟内存区域

```c
#include <unistd.h>
#include <sys/mman.h>

int munmap(void *start,size_t length);
```

#### 动态内存分配

* 动态内存分配器在 C 中更方便，也有更好的移植性
* 动态内存分配维护着一个进程的虚拟内存区域，称为堆，对于每个进程，内核维护着一个变量 brk（读作 break），它只向堆的顶部
* 分配器将堆视为一组不同大小的块的集合来维护，每个块都是一个连续的虚拟内存片，分为两种
  * 已分配的：显式的保留准备为应用程序使用
  * 空闲的：空闲块保持空闲，知道它显式的被应用分配
  * 一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行，要么是内存分配器自身隐式执行

* 分配器有两种风格
  * 显式分配器：要求应用显式的释放任何已分配的块（ C 中的 free 或 C++ 中的 delete ）
  * 隐式分配器：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块（例如 java 的 GC）

##### malloc 和  free 函数

* malloc 函数，用来从堆中分配块
* calloc 函数将分配的内存初始化为 零
* realloc 函数想要改变一个以前分配块的大小

```c
#include <stdlib.h>

void *malloc(size_t size);
```

* sbrk 函数将内核 brk 指针增加 incr 来扩展和收缩堆，成功返回 brk 的旧值，否则返回 -1
* free 函数释放已分配的堆块，ptr参数必须指向一个从 malloc，calloc 或 realloc 获得的分配的起始位置

```c
#include <stdlib.h>

void free(void *ptr);
```

##### 分配器的要求和目标

* 显示分配器必须在一些相当严格的约束条件下工作
  * 处理任意请求序列：一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件
    * 每个释放请求必须对应一个当前已分配块，这个块是由一个以前的分配请求获得的。因此分配器不可假设分配和释放请求的顺序
  * 立即响应请求：分配器必须立即响应分配请求。
  * 只使用堆：为了使分配器可扩展，分配器使用的任何非标量数据结构都必须保存在堆里
  * 对齐块：分配器必须对齐块，使得它们可以保存任何类型的数据对象
  * 不修改已分配的块：分配器只能操作或者改变空闲块。一旦块被分配了就不允许修改或者移动它了

##### 碎片

* 造成堆利用率很低的主要原因是一种称为碎片的现象，当有未使用的内存但不满足分配请求时，就会发生这种现象，有两种形式的碎片 
  * 内部碎片：是一个已分配块比有效荷载大时发生的
  * 外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲足够大可以来处理这个请求时发生

##### 获取额外的堆内存

* 如果分配器不能为请求块找到合适的空闲块，则会通过合并那些在内存中物理相邻的空闲块来创建一个更大的空闲块，如果这样还是不能生成一个足够大的块，或者如果空闲块已经最大的程度合并了，那么分配器就会调用 sbrk 函数，向内核请求额外的堆内存



##### 分离空闲链表

* 分离储存可以减少分配时间，其基本定义
  * 维护多个链表，其中每个链表中的块有大致相等的大小
  * 一般的思路是将所有可能大小分成一些等价类，也叫做大小类
  * 分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列，当分配器需要一个大小为 n 的块时，它就搜索相应的空闲链表，如果不能找到合适的块与值匹配，就搜索下一个链表

#### 垃圾收集

* 在 C 语言中，应用通过 malloc 和 free 来分配和释放堆块。应用要负责释放所有不需要的已分配块

##### 垃圾收集器基本知识

* 垃圾收集器将内存视为一张有向可达图（树状图），该图的节点被分成一组根节点和一组堆节点。每个堆节点对应于堆涨的已分配的块，根节点对应于一种不在堆中的位置，它们包含指向堆中的指针。这些位置可以是寄存器，栈里的变量，或者是虚拟内存中读写数据区域的全局变量
* 垃圾收集器的角色是维护可达图的某种表示，通过释放不可达节点且将它们返回给空闲链表，来定期回收它们

##### Mark & Sweep 垃圾收集器

* Mark & Sweep 垃圾收集器由标记阶段和清除阶段组成，标记阶段标记出根节点所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了

```c++
// 如果 p 指向一个已分配块中的某个字，那么就返回一个指向这个块的起始位置的指针 b。否则返回 NULL
prt isPtr(ptr p);
// 如果块 b 是已标记的，那么就返回 true
int blockMarked(ptr b);
// 如果块 b 是已分配的。那么就返回 true
int blockAllocated(ptr b);
// 标记块 b
int markBlock(ptr b);
// 返回块 b 的以字为单位的长度（不包括头部）
int length(b);
// 将块 b 的状态由已标记的改为未标记的
void unmarkBlock(ptr b);
// 返回堆中块 b 的后继
ptr nextBlock(ptr b);
```

