### 总结

#### 一 计算机系统漫游

##### 1.1 Hello.c 的加载流程

* hello.c 文件编译过程分为 4 个阶段
  * 预处理:  hello.i  插入所有 #include 命令指定的文件，扩展 #define 声明指令的宏
  * 编译器:  产生汇编代码 hello.s
  * 汇编器: 将汇编代码转换成二进制目标代码文件 hello.o
  * 最后，链接器将两个目标代码文件与实现库函数(如 printf) 代码合并，并产生最终的可执行代码 hello

##### 1.2 系统的硬件组成

* CPU 想要进行数据的读写，必须和外部的器件交互
  * 储存单元地址（地址信息）
  * 器件选择，读写命令（控制信息）
  * 读或写数据（数据信息）

* 总线：计算机中专门连接 CPU 和其他芯片的导线，通常称为总线（Bus）
  * 逻辑上分为 地址总线，控制总线，数据总线
  * 读：地址总线发送地址找到需要读取的数据 -> 控制总线发出读的指令 ->  数据总线把读出的数据读取到 CPU
  * 写:  地址总线发送地址找到需要写入的地址 ->  控制总线发出写的指令 -> 数据总线把数据写入到地址中

* 储存器
  * 储存器(不一定是内存 比如: 显存)被划分为若干个存储单元，每个存储单元从零开始编号
* 内存地址空间
  * 随机存储器（RAM）随机存储器的特性是断电之后数据会丢失
  * 只读存储器（ROM）永远只能读的存储器，断电之后数据不会丢失
  * BIOS: 是由主板和各类接口卡（如显卡，网卡）厂商提供的软件系统
* 高速缓存
  * 系统花费大量的时间把信息从一个地方挪到另一个地方，中间的复制过程就是是开销，因此我们的主要目标就是使这些复制尽可能快的完成
  * 根据机械原理，较大的设备要比较小的设备运行慢么，开销大，因此要用更快更小的储存设备，高速缓存(cache memory)，通过在高速缓存里存放可能经常访问的数据，减少系统的开销，加快程序的执行时间、
  * CPU 处理并解释存放在主存中的二进制指令，需要花费大量的时间进行复制，因此产生了高速缓存的层次结构，层级越高体积越小，速度越快，通过对储存层次结构的认识，可以优化程序的性能

* 虚拟内存
  * 为每个进程提供了一个独占使用主存假象，每个进程看到的内存都是一致的，称为虚拟地址空间，每个虚拟地址空间由大量准确定义的区构成，从最低地址开始依次是 程序代码和数据区，堆区，共享库区，栈区，内核虚拟内存

##### 1.3 并发与并行

* 并发: 一个系统同时具有多个活动	并行: 用并发来使一个系统运行的更快
* 线程并发: 构建在进程的抽象之上，能够在一个进程中执行多个控制流，是通过不断切换线程来实现的
* 多核处理器: 多个 CPU 集成到一个集成电路芯片上，每个核都有自己的高速缓存。共享更高层次的告诉缓存
* 超线程(同时多线程): 允许一个 CPU 执行多个控制流

### 二 信息的表示和处理

##### 2.1 计算机的信息表示

* 现代计算机储存和处理的信息是以二进制信号表示的，其中有三种重要的数字表示分别为
  * 无符号(unsigned)	基于传统的二进制表示法，表示大于或者等于零的数字
  * 补码(two's-complement)   表示有符号的整数的最常见的方式，有符号数就是可以为正或为负的数字
  * 浮点数(floating-point)  表示实数的科学记数法的以 2 为基数的版本

##### 2.2 信息的储存

* 机器级程序将内存视为一个非常大的字节数组称为虚拟内存。
* 内存的每个字节都由一个唯一的数字标识，称为地址
* 所有的地址的集合称为虚拟地址空间

##### 2.3 字数据大小

* 每台计算机都有一个字长(word size)，通常是32位或64位，代表指针数据的标称大小(nominal size)，字长决定了虚拟地址空间的最大值，例如一个字长为 w 位的机器，虚拟地址范围是 0 ~ 2^w - 1
* 大多数 64 位机器向后兼容 32位机器，反之不行
* C 语言中只有 char* 和 long 在 32位 和 64位的机器中不同

##### 2.4 寻址和字节顺序

* 对于跨越多字节程序的对象，必须建立两个规则：这个对象的地址是什么以及在内存中是如何排序的
* 几乎在所有的机器上，多字节对象都被储存为连续的字节序列，对象的地址为所使字节中最小地址
* 排列一个对象的字节有两个通用的规则：大端法，小端法，android 和 IOS 都是小端模式，网络传输中为了避免不同类型之间字节顺序不一样，必须遵守网络应用的字节顺序的规则

##### 2.5 运算

* 布尔代数：^ 异或  任何数和 0 异或  则结果为任何数本身，任何数和 1 异或，则结果为任何数取反
* 位级运算:  确定一个位级表达式最好的方法是将十六进制的参数扩展成二进制表示并执行二进制运算，然后在转回十六进制 | & ~ ^
* 逻辑运算符: || && ! ，和位级运算不同
* 移位运算:  x 向左移 k 位，丢弃最高的 k 位，在右端补 0，x 向右移 k 为，丢弃最低的 k 位，在左端补 0，对于无符号数，右移必须是逻辑位移，C 语言中进行位移操作最好加上括号
* 整数表示: unsigned 表示非负整数， signed 表示负数，整数，零，两者取值范围不同

##### 2.6 浮点数

* IEEE 计算 V = (-1)^s * M * 2^e  
  * s  决定这个数是正数(s=0)还是负数(s=1)
  * M 是一个二进制小数它的范围是 1 ~ 2-E 或者 0 ~ 1-E
  * E 的作用是对浮点
  * 数加权，这个权重是 2 的 E 次幂(可能是负数)
  * 浮点数的位划分为三个字段 s（决定是正数还是负数），exp（非规格化和非规格化），frac（小数）

* 舍入
  * 默认舍入方式:最接近的可表示的值
  * 向零舍入方式，把正数向上舍入，把负数向下舍入 比如，1.232 = 1，-1.213 = -1
  * 向负无穷大(向下)舍入：比如: 1.231 = 1，-1.23432 = -2
  * 向正无穷大(向上)舍入: 比如 1.231 = 2，-1.123 = -1

### 第三章

##### 3.1 寄存器

* CPU 分为三部分，寄存器(信息存储)，运算器(做加减乘除相关运算)，控制器（CPU 控制外部的资源）
  * 开发者通过改变寄存器的内容来控制 CPU 的行为
  * 不同的 CPU 寄存器的个数，结构，名称都是不同的，CPU 会根据寄存器指向的地址来读取指令
  * 改变寄存器就可以改变一个 CPU 的执行

##### 3.2 操作数指示符

*  寻址方式
  * CPU 访问内存单元时，要给出内存单元的地址，所有的内存单元都有唯一的地址，叫做物理地址
  * 8086 的寻址范围是 1M ，假设有个地址是 0xCFFA7，8086 的 16位 CPU 是无法接收到怎么大的数据的(最大接收 0xFFFF)，因此会把物理地址(0xCFFA7) = 段地址 * 16 + 偏移地址 即

```
0xCFFA7 = 0xCFFA * 16 + 0x007
0xCFFA * 16 = 0xCFFA0	
// 可以简写为
0xCFFA:0x007
```

##### 3.3 数据传送指令

* MOV 类是最简单形式的数据传送指令，由四条指令组成，这些指令都执行同样的操作，区别在于传送的数据大小不同分别是 movb（传送1个字节），movw（传送2个字节），movl （传送4个字节），move（传送8个字节）
* 将一个值从一个内存位置复制到另一个内存位置需要两条指令
  * 第一条指令将源值加载到寄存器中
  * 第二条指令将该寄存器的值写入目的位置

##### 3.4 压入和弹出栈数据

* 栈是一种数据结构，可以添加或者删除值，不过要遵循先进后出，通过 push 操作把数据压入栈中，通过 pop 操作删除数据，它就有一个属性: 弹出的值永远是最近把压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一段插入和删除元素，这一端被称为栈顶
* pushq 指令用来把数据压入栈中，popq 用来弹出数据

##### 3.5 算术和逻辑操作

* 大多数操作都分成了指令类，这些指令类有各种不同大小操作数的变种，例如 指令类 ADD 由 addb，addw，addl 和 addq 组成，分别是字节加法，字加法，双字加法和四字加法

### 小结

​		通过一周的学习，我对计算机的结构与数据储存和传递有了大致的了解，知道了 C 语言中的文件是如何加载的，了解了进程和线程之间的区别于切换的概念， IEEE 浮点计数法的计算过程，和 C 语言中的运算的方式（比如位级运算，移位运算，补码，源码，反码等）通过第三章的学习（虽然没看完）清楚了汇编语言的基本概念和指令含义，以前没接触过汇编语言，初看一脸蒙蔽，因此我还特地补充的汇编语言相关的知识，希望在接下来的学习中更加轻松