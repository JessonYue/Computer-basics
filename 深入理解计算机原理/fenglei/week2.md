### 总结

这周完成了 4，5，6 三个章节的阅读

#### 第四章 处理器体系结构

1. 了解的 ISA 指令，ISA 指令提供好了程序执行的一种顺序说明，也就是一条指令执行完了，下一条指令才会开始

##### 指令编码

* 每条指令需要 1 ~ 10 个字节不等，这取决于哪些字段。
* 每条指令的第一个字节表明指令类型，这个字节分为两个部分，每部分 4 位：高 4 位是代码部分，低 4 位是功能部分
* 15 个寄存器中每个都有一个相对应的范围在 0 到 0xE 之间寄存器标识符，Y86-64 与 x86-64 的寄存器编号一样。
* 程序寄存器存在 CPU 中的一个寄存器文件中，这个寄存器就是一个小的，以寄存器 ID 作为地址的随机访问储存器，当指令编码中以及我们的硬件设计中，当需要指明不应访问任何寄存器时，就用 0xF 来表示
* 有些指令需要一个附加的 4 字节常数。这个字能作为 irmovq 的立即数据，rmmovq 和 mrmovq 的指令指示符偏移量，以及分支指令和调用指令的目的地址 **这里的分支指令和调用指令的目的是一个绝对地址，而不像 IA32 中那样使用 PC 相对寻址的方式**

2. 了解了流水线化通过让不同的阶段并行操作，改进了系统的吞吐量性能

* 在任意一个给的的时刻，多条指令被不同的阶段处理
* 在引入流水线的过程中要注意与程序的顺序执行相同的程序级行为

##### 了解了 SEQ 的硬件结构

* 取指：将程序计数器寄存器作为地址，指令内存读取指令的字节
* 译码：寄存器有两个读端口 A 和 B，从这两个端口同时读寄存器值 valA 和 valB
* 执行：执行阶段会根据指令的类型，将算术/逻辑单元 用于不同的目的
  * 对整数操作，它要执行指令所指定的运算，对其他指令，它会作为一个加法器来计算增加或减少栈指针，或计算有效地址，或者只是简单的加 0，将一个输入传递到输出
* 访存：在执行访存操作时，数据内存读出或写入一个内存序。指令和数据内存访问的是相同的位置，但是用于不同的目的
* 写回：寄存器文件有两个写端口。端口 E 用来写 ALU 计算出来的值，而端口 M 用来写从数据内存中读出来的值
* 更新 PC：程序计数器的新值选择自：valP，下一条指令的地址：valC，调用指令或跳转指令指定的地址目标地址：valM，从内存读取返回地址

* 通过调整 SEQ 各个部分的顺序，引入流水线得到 SEQ+

### 第五章 优化程序性能

##### 优化编译器的能力和局限性

* 通过调整代码的结构和算法，改变程序的性能
* 通过几个程序的示例，认识到了代码的重要性
  * 消除循环的低效率
  * 减少过程调用
  * 消除不必要的内存引用

##### 理解现代处理器

现代处理器可以再每个时钟周期执行多个操作，而且是乱序的，意思就是指令执行的顺序不一定要与它们在机器程序中的顺序一致，整个设计由两部分组成（指令控制单元和执行单元），前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作，后者执行这些操作。

* ICU 从指令高速缓存中读取指令（指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令）
* ICU 会在当前指令执行很早之前取指，并发送到 EU，当遇到分支时，采用分支预测技术猜测处理器是否会选择分支和预测分支目标地址，使用投机执行技术取出位于预测分支跳到的指令，并对指令译码，如果确定分支预测错误，将会重新设置分支点状态，并开始取出和执行另一个方向上的指令
* 指令译码逻辑接收实际的程序指令，并将它们转换成基本操作
* 在 X86-64 实现中一条指令可能转换一条或多条操作，译码逻辑对指令进行分解，允许并行的执行多条指令的不同部分
* EU 接收取指单元的操作
* 读写内存是由加载和储存单元实现的，加载单元处理从内存读数据到处理器的操作，储存单元处理从处理器写数据到内存的操作，两者通过数据告诉缓存来访问内存
* 投机技术对操作求值的结果直到确定应该实际执行这些指令之前都不会放在程序寄存器或数据内存中
* 分支操作被放倒 EU 用来确定分支预测是否正确，如果预测错误会导致很大的性能开销

##### 调高并行性 

* 多个累积变量
  * 代码演示了 2*2循环展开，它即使用了两次循环展开，以每次迭代合并更多的元素，也使用了两路并行，将索引数为偶数的元素累积在变量 acc0 中，而索引值为奇数的元素累积在变量 acc1 中，之后对于向量长度不为 2 的倍数时，第二次循环累积所有剩下的元素，最后对 acc0 和 acc1 应用合并运算，得出最终结果
  * 2*2 循环对所有情况都得到了改进，可以使性能显著增加
* 重新结合变换
  * 第二种打破顺序相关从而使性能调高到延迟界限的方法，下面函数与 combine5 的展开代码唯一区别在于内循环中元素合并的方式，差别仅在于两个括号如何放置，我们称之为重新结合变换，通过括号改变了向量元素与累积值 acc 的合并顺序
  * 重新结合变换能够减少计算中关键路径上操作的数量，通过更好的利用功能单元的流水线能力得到更好的性能，但是对浮点运算不保证是可结合的，因此循环展开和并行的累积在多个值中，是提高性能更可靠的方法

```c++
void combine7(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    long limit = length - 1;
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;

    for (i = 0; i < limit; i += 2) {
      	// 与 combine5 唯一的区别是括号的位置不同
        acc = acc OP (data[i] OP data[i + 1]);
    }
    for (; i < length; i++) {
        acc = acc OP data[i];
    }
    *dest = acc;
}

void combine5(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    long limit = length - 1;
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;

    for (i = 0; i < limit; i += 2) {
        acc = (acc OP data[i]) OP data[i + 1];
    }
    for (; i < length; i++) {
        acc = acc OP data[i];
    }
    *dest = acc;
}
```

##### 一些限制因素

* 寄存器溢出
  * 如果我们将并行度 P 超过了可用的寄存器数量，那么编译器就会产生溢出，将某些值存放到内存中，通常是在运行时堆栈分配空间，比如把  combine6 的多累积变量模式扩展到 k = 10 或 k = 20（现代 x86-64 寄存器有 16 个寄存器，并可以使用 16 个 YMM 寄存器来保存浮点数）时，超过了寄存器数量，程序必须在栈上分配一些变量，这就导致了程序性能可能比之前更差
  * 一般情况下 x86-64 有足够的寄存器，大多数循环在出现寄存器溢出之前就将达到吞吐量限制

* 分支预测和预测错误处罚
  * C 语言如何保证分支预测触发不阻碍程序效率是个很复杂的问题，但是可以注意以下几点
    * 不要过分关心可预测的分支
    * 书写适合用条件传送实现的代码，GCC 能为一种更 功能性 风格书写的代码产生传送条件，这种风格对立一种更 命令式 的风格（下面举例）
    * 命令式风格代码主要看预测对错，如果预测正确性能比功能性代码号，预测错误则性能极差（3 ~ 13）功能性风格代码避免了处理器的预测，因此性能平稳（4 左右）

```c++
// 命令式风格代码
void minmax1(long a[], long b[], long n) {
    long i;
    for (int i = 0; i < n; ++i) {
        if (a[i] > b[i]) {
            long t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}

// 功能性风格代码
void minmax2(long a[], long b[], long n) {
    long i;
    for (int i = 0; i < n; ++i) {
        long min = a[i] < b[i] ? a[i] : b[i];
        long max = a[i] < b[i] ? b[i] : a[i];
        a[i] = min;
        b[i] = max;
    }
}
```

##### 性能提高技术

优化程序程序性能的基本策略

* 高级设计：为遇到的问题选择适当的算法和数据结构。
* 基本编码原则：避免限制优化的因素，这样编译器就能产生高效代码
  * 消除连续的函数调用，在可能时，将计算移到循环外。考虑有选择的妥协程序的模块性已获得更大的效率
  * 消除不必要的内存引用。应用临时变量来保存中间结构，只有在最后的值计算出来时，才将结构存放到数组或全局变量中
* 低级优化，结构化代码以利用硬件功能
  * 展开循环，降低开销，并且使得进一步的优化称为可能
  * 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令集并行
  * 用功能性的风格重写条件操作，使得编译采用条件数据传送

### 第六章 储存器层次结构

##### 储存技术

* 随机访问储存
  * 静态 RAM 
    * 只要有电，它就会永远保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值
  * 动态 RAM 
    * 将每个位储存为对一个电容的充电。与 SRAM 不同，DRAM 储存器单元对干扰非常敏感，当电容的电压被扰乱之后，它就永远不能恢复了，暴露在光线下会导致电容电压改变
  * 传统的 DRAM  
    * DRAM 芯片中的单元被分成 d 个超单元，每个超单元都由 w 个 DRAM 单元组成，一个  d * w 的 DRAM 总共存储了 dw 位信息
  * 内存模块 
    * DRAM 芯片封装在内存模块中，它插到主板的扩展槽上。
  * 增强的 DRAM 
    * 快页模式，扩展数据输出DRAM，同步 DRAM（SDRAM），双倍数据速率同步 DRAM，视频 RAM（VRAM）
  * 非易失性储存器 如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的。非易失储存器即使在断电后，仍然保存着它们的信息
  * 访问主存 读事务 和写失误

* 磁盘储存
  * 从磁盘上读信息的时间为毫秒级，比 DRAM 满了 10 万倍，比 SRAM 慢了 100 万倍
* 固态硬盘

##### 储存器层次结构

| 储存器                                     | 功能                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 寄存器                                     | CPU 寄存器保存着从高速缓存存储器取出的字                     |
| 高速缓存 L1（SRAM）                        | L1 高速缓存保存着 从 L2 高速缓存取出的缓存行                 |
| 高速缓存 L2 （SRAM）                       | L2 高速缓存保存着 从 L3 高速缓存取出的缓存行                 |
| 高速缓存 L3（SRAM）                        | L3 高速缓存保存着从主存高速缓存取出的缓存行                  |
| 主存（DRAM）                               | 主存保存着从本地磁盘取出的磁盘块                             |
| 本地二级储存（本地磁盘）                   | 本地磁盘保存着从远程网络服务器磁盘上取出的文件（如果有远程服务器） |
| 远程二级储存（分布式文件系统，Web 服务器） |                                                              |

#####  储存结构中的缓存

* 一般而言，高速缓存是一个小而快速的储存设备，它作为储存在更大，也更慢的设备中的数据对象的缓冲区域。**使高速缓存的过程称为缓存**
* 缓存命中 
  * 当程序需要 K + 1 层的某个数据对象 d 时，它首先在当前存储在第 K 层的一个块中查找 d，如果 d 刚好储存在第 k 层中，那么被称为缓存命中
* 缓存不命中
  * 如果第 K 层中没有缓存数据对象 d，那么被称为缓存不命中，当发生缓存不命中时，第 k 层的缓存从第 k + 1层缓存中取出包含 d 的那个块，如果第 K 层的缓存已经满了，可能会覆盖现存的一个块

##### 高速缓存存储器

* 通用的高速缓存存储器组织结构
  * 高速缓存有 S 个高速缓存数组，每个数组包含 E 个高速缓存行。每个行是由一个 B 字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，因此高速缓存的大小 C 指的是所有块大小的和，标记位和有效位不包括在内，因此 C = S * E * B

* 直接映射高速缓存
  * 根据每个组的高速缓存行数 E，高速缓存被分为不同的类。每个组只有一行的高速缓存称为直接映射高速缓存

##### 编写高速缓存友好的代码

* 让最常见的情况运行的快。程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间都花在了少量循环上。所以要把注意力集中在核心函数的循环上，而忽略其他部分
* 尽量减小每个循环内部的缓存不命中数量，在其他条件相同的情况下，不命中率较低的循环运行的更快

