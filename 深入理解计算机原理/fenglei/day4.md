#### 第三章 程序的机器级表示

#####	程序编码

* 假设一个 C 程序有两个文件 p1.c 和 p2.c，用 Unix 命令行编译这些代码: linux> gcc -Og -o p p1.c p2.c
  * gcc 是Linux上默认的用来编译 C 的编译器
  * -Og 会优化编译后的机器代码，增强可读性
  * 源代码转换成可执行代码的流程
    * C 预处理器扩展源代码，插入所有 #include 命令指定的文件，扩展 #define 声明指令的宏
    * 编译器产生两个汇编代码，分别为 p1.s 和 p2.s
    * 汇编器将汇编代码转换成二进制目标代码文件 p1.o 和 p2.o，目标代码是机器代码的一种形式，它包含所有的二进制表示
    * 最后，链接器将两个目标代码文件与实现库函数(如 printf) 代码合并，并产生最终的可执行代码 p （有 -o p 指定的）

##### 机器级代码

* 汇编代码表示非常接近接近机器代码，与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示
* 在机器代码中 C 语言的聚合数据类型(如数组和结构) 用一组连续的字节表示，即使对标量数据类型，汇编代码也不区分有符号数和无符号数，不区分各种类型的指针，不区分指针和整数
* 机器执行的程序只是一个字节序列，它是对一系列指令的编码，机器对产生这些指令的源代码一无所知
* 生成汇编代码 gcc -Og -S mstore.c  生成二进制文件 gcc -Og -C mstore.c

汇编代码示例

```
	.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 10, 15	sdk_version 10, 15, 4
	.globl	_multStore              ## -- Begin function multStore
	.p2align	4, 0x90
_multStore:                             ## @multStore
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	pushq	%rbx
	pushq	%rax
	.cfi_offset %rbx, -24
	movq	%rdx, %rbx
	callq	_mult2
	movq	%rax, (%rbx)
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
	.cfi_endproc
                                        ## -- End function

.subsections_via_symbols
```

所有以 '.'开头的行都是指导汇编器和链接器工作的伪指令，通常可以省略这些行，因此过滤伪指令后

```
_multStore:                             ## @multStore
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%rbx
	pushq	%rax
	movq	%rdx, %rbx
	callq	_mult2
	movq	%rax, (%rbx)
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
                                        ## -- End function

.subsections_via_symbols
```

* 在 C 语言中插入汇编代码有两种方法，第一种是可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用 C 语言书写的代码合并起来，第二种方法是可以用 GCC 的内联汇编特性，用 asm 伪指令可以在 C 程序中包含简短的汇编代码，这种方法的好处是减少了一机器相关的代码量

##### 数据格式

| C 声明 | Intel 声明 | 汇编代码后缀 | 大小(字节) |
| ------ | ---------- | ------------ | ---------- |
| char   | 字节       | b            | 1          |
| short  | 字         | w            | 2          |
| int    | 双字       | l            | 4          |
| long   | 四字       | q            | 8          |
| char * | 四字       | q            | 8          |
| float  | 单精度     | s            | 4          |
| Double | 双精度     | l            | 8          |



##### 访问信息

* 一个 x86-64 位的 CPU 包含一组 16 个储存 64 位值的通用目的寄存器,这些寄存器用来储存整数数据和指针
* 不同的指令可以对 16 个寄存器的低位字节中存放的不同的大小数据进行操作，字节级操作可以访问最低字节，16 位操作可以最低访问 2 个字节，32 位操作可以最低访问 4 个字节，64 位操作可以访问整个寄存器



##### 知识增补 - 寄存器

* CPU 分为三部分，寄存器(信息存储)，运算器(做加减乘除相关运算)，控制器（CPU 控制外部的资源）

* 开发者通过改变寄存器的内容来控制 CPU 的行为

  * 不同的 CPU 寄存器的个数，结构，名称都是不同的，CPU 会根据寄存器指向的地址来读取指令
  * 通用寄存器主要存放一般性的数据，CPU 会先将内存中的数据储存到通用寄存器中然后在对通用寄存器进行计算，最后把返回的值放入通用寄存器中
  * X86-64 架构的通用寄存器是以 16个比特位为一组，每组可以储存 2 个字节，为了保持兼容性(之前的寄存器是 8 位的)，一个 16 位寄存器可以分为两个独立的 8 位的寄存器，分为高位寄存器和低位寄存器
  * 在汇编的数据储存中，有两个比较常见的单位
    * 字节(byte) 一个字节由 8 bit组成，可以存储在 8 位的寄存器中
    * 字(word) 一个字由两个字节组成，这两个字节分别称为低字节和高字节

  

* 因此改变寄存器就可以改变一个 CPU 的执行



##### 操作数指示符

* 大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置，x86-64 支持多种操作数格式
* 各种不同的操作数的被分为三种类型
  * 立即数: 用来表示常数值，写法是 $ 后面给一个 C 语言表示法表示的正数如 $-577 ，$0x1F
  * 寄存器：表示某个寄存器的内容，16 个寄存器的低位 1 字节，2 字节，4 字节和 8 字节中的一个作为操作数，分别对应 8 位，16 位，32 位和 64 位，用 ra 表示任意寄存器 a，用 R[ra] 表示它的值
  * 内存引用，它会根据计算出来的地址(通常称为有效地址) 访问某个内存位置。因为将内存看出一个很大的字节数组，用 Mb[Addr] 表示对储存在内存中地址 Addr 开始的 b 个字节值的引用，为了简便写法省略下标 b 即 M[Addr]

* 寻址方式:

  * CPU 访问内存单元时，要给出内存单元的地址，所有的内存单元都有唯一的地址，叫做物理地址
  * 8086 的寻址范围是 1M ，假设有个地址是 0xCFFA7，8086 的 16位 CPU 是无法接收到怎么大的数据的(最大接收 0xFFFF)，因此会把物理地址(0xCFFA7) = 段地址 * 16 + 偏移地址 即

  ```c
  0xCFFA7 = 0xCFFA * 16 + 0x007
  0xCFFA * 16 = 0xCFFA0	
  // 可以简写为
  0xCFFA:0x007
  ```


##### 数据传送指令

* 最频繁使用的指令是将数据从一个位置复制到另一个位置
  * MOV 类是最简单形式的数据传送指令，由四条指令组成，这些指令都执行同样的操作，区别在于传送的数据大小不同
    * movb		传送 1 字节
    * movw       传送 2 字节
    * movl         传送 4 字节
    * move        传送 8 字节

* 将一个值从一个内存位置复制到另一个内存位置需要两条指令
  * 第一条指令将源值加载到寄存器中
  * 第二条指令将该寄存器的值写入目的位置



##### 压入和弹出栈数据

* 栈是一种数据结构，可以添加或者删除值，不过要遵循先进后出，通过 push 操作把数据压入栈中，通过 pop 操作删除数据，它就有一个属性: 弹出的值永远是最近把压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一段插入和删除元素，这一端被称为栈顶
* pushq 指令用来把数据压入栈中，popq 用来弹出数据

##### 算术和逻辑操作

* 大多数操作都分成了指令类，这些指令类有各种不同大小操作数的变种，例如 指令类 ADD 由 addb，addw，addl 和 addq 组成，分别是字节加法，字加法，双字加法和四字加法
* 每个指令类都有对这四种不同大小数据的指令，这些操作被分为四组: 加载有效地址，一元操作，二元操作和移位
* 二元操作有两个操作数，一元操作有一个操作数

##### 加载有效地址

* 加载有效地址指令 leaq 是 movq 的变形，它的指令形式是从内存读取数据到寄存器，但实际上它并没有引用内存，它的第一个操作数看上去是一个内存引用，但是该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数















