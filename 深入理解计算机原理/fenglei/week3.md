### 总结

这周完成了  7 ~ 10 章的阅读

### 第七章

编译步骤

1. **驱动程序运行  C 预处理器将源文件翻译成 ASCII 码中间文件（main.c -> main.i）**
2. **驱动程序运行 C 编译器，将 main.i 翻译成 ASCII 汇编语言文件（main.i -> main.s）**
3. **驱动程序运行汇编器，将 main.s 翻译成可重定位目标文件（mian.s -> main.o）**
4. **驱动器经过相同的步骤生成 sum.o，最后通过链接器程序将 main.o 和 sum.o 以及一些必要的目标文件组合起来，创建一个可执行目标文件 prog**
5. **shell 中运行可执行文件 prog，shell 调用一个叫做加载器的函数，将可执行文件 prog 中的代码和数据复制到内存中，然后将控制转移到这个程序的开头**

#### 静态链接

* Linux 的静态链接器以一组可**重定位目标文件**和**命令行参数**作为输入，生成一个完全的链接，可以**加载**和**运行**的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的全部变量又在另一节中。
* 为了构造可执行文件，链接器必须完成两个任务
  * 符号解析：目标文件定义和引用符号，每个符号对应于一个函数，一个全局变量或一个静态变量，符号解析的目的是将每个符号引用正好和一个符号定义关联起来
  * 重定位：
    * 编译器和汇编器生成从地址 0 开始的代码和数据节
      * 重定位节，链接器通过把每个符号定义与一个内存位置关联起来
      * 修改所有对这些符号的引用，使得它们指向这个内存的位置
      * 链接器使用汇编器产生的重定位条目的详细指令，不加甄别的执行这样的重定位

#### 目标文件

* 目标文件有三种形式
  * 可重定位目标文件。包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并起来，创建一个可执行目标文件
  * 可执行目标文件。包含二进制代码和数据。其形式可以被直接复制到内存并执行
  * 共享目标文件。一种特殊类型的可重定位目标文件，可以**加载或者运行时**被动态的加载进内存并连接
  * **一个目标文件就是一个字节序列，一个目标文件就是以一个文件形式存放在磁盘中的目标模块**
  * **ELF：在 x86-65 Linux 和 Unix 系统使用可执行可链接格式**

#### 动态连接

* 静态库明显的缺陷
  * 静态库和所有软件一样，需要定期维护和更新，如果想要一个最新的版本，必须以某种方式了解到该库的更新情况，然后显示的将他们的程序与更新的了库重新链接
  * 每个 C 程序几乎都使用了标准 I/O 函数，比如 pringf 和 scanf，在运行时，这些函数的代码会被复制到每个运行进程的文本中，在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源极大浪费

* 共享库
  * 共享库是致力于解决静态库缺陷的创新产物，共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个内存中的程序链接起来。这个过程称为**动态链接**，是一个叫做动态链接器的程序来执行的
  * 共享库是以两种不同的方式来共享的
    * 任何给定的文件系统中，对于一个共享库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中
    * 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享

#### 小结

链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用

多个目标文件可以被连接到单独的静态库中，链接器用库来解析其他目标模块中的符号引用

链接器将可执行文件内容映射到内存

### 第八章

#### 异常

* 异常就是控制流中的突变，用来响应处理器状态中的某些变化
* 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序），当异常处理程序完成处理后，根据引起异常的事件的类型，会发送以下三种情况
  * 处理程序将控制返回给当前指令，即当前事件发生时正在执行的指令
  * 处理程序将控制返回给下一条指令，如果没有异常将会执行下一条指令
  * 处理程序终止被中段的程序

##### 异常的类别

异常可以分为四类

| 类别 |        原因         | 异步/同步 |       返回行为       |
| :--: | :-----------------: | :-------: | :------------------: |
| 中断 | 来自 I/O 设备的信号 |   异步    | 总是返回到下一条指令 |
| 陷阱 |     有意的异常      |   同步    | 总是返回到下一条指令 |
| 故障 |  潜在可恢复的错误   |   同步    |   可能返回当前指令   |
| 终止 |   不可恢复的错误    |   同步    |       不会返回       |

#### 信号

* 信号允许进程和内核中断其他进程，一个信号就是一条小信息，它通知系统发生了一个某种类型的事件。
* 每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的
* 信号提供了一种机制，通知用户发送了哪些异常。比如，一个进程试图除以 0，内核就会发送给它一个 SIGFPE（号码 8） 信号

##### 阻塞和解除阻塞信号

* Linux 提供阻塞信号的显式和隐式机制
  * 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号
  * 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确的阻塞和解除阻塞选定的信号

#### 小结

异常控制流发送在计算机系统的各个层次，是计算机系统提供并发的基本机制

有四种不同类型的异常：中断，故障，终止和陷阱

在操作系统层，进程提供了两个抽象：1.逻辑控制流	2 私有空间地址

### 第九章

#### 物理和虚拟寻址

* 物理寻址：计算机系统的内存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（PA），第一个字节地址为 0，接下来的字节地址为 1，再下一个为 2
* 虚拟寻址：CPU 生成一个虚拟地址（VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将虚拟地址转成物理地址的任务叫做地址翻译。CPU 芯片上叫做内存管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理

#### 地址空间

* 地址空间是一个非负整数地址的有序集合
  * 在一个带有虚拟内存的系统中，CPU 从一个有 N = 2^n 个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间
  * 一个地址空间的大小是由表示最大地址所需要的位数来描述的
  * 一个系统还有一个物理地址空间，对应于系统中物理内存的 M 个字节

#### 虚拟内存作为内存管理的工具 

* 操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间，不同进程多个虚拟页面可以映射到相同的一个共享物理页上
* 简化链接：独立的地址空间运行每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处
* 简化加载：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件，将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射。Linux 提供了 mmap 函数运行应用程序自己做内存映射

#### 内存映射

* Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到以下两种类型的对象中的一种
  * Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件
  * 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零

##### 共享对象

* 内存映射提供了一种清晰的机制，用来控制多个进程如何共享对象

* 一个对象可以被映射到虚拟内存的区域，要么作为共享对象，要么作为虚拟对象
  * **如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，都是可见的，这些变化也会反应到磁盘的原始对象中**
  * **一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反应在磁盘的对象中**

* 一个映射到共享对象的虚拟内存叫做共享区域。类似的也有私有区域

* 私有对象使用一种叫做**写时复制**的巧妙技术被映射到虚拟内存，只要没有进程试图写自己的私有区域，它们就可以共享物理内存中对象的一个单独副本。反之，这个写操作就会触发一个保护故障
  * 当触发保护故障时，物理内存就会创建一个新的副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限

#### 动态内存分配

* 动态内存分配器在 C 中更方便，也有更好的移植性
* 动态内存分配维护着一个进程的虚拟内存区域，称为堆，对于每个进程，内核维护着一个变量 brk（读作 break），它只向堆的顶部
* 分配器将堆视为一组不同大小的块的集合来维护，每个块都是一个连续的虚拟内存片，分为两种
  * 已分配的：显式的保留准备为应用程序使用
  * 空闲的：空闲块保持空闲，知道它显式的被应用分配
  * 一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行，要么是内存分配器自身隐式执行

* 分配器有两种风格
  * 显式分配器：要求应用显式的释放任何已分配的块（ C 中的 free 或 C++ 中的 delete ）
  * 隐式分配器：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块（例如 java 的 GC）

##### malloc 和  free 函数

* malloc 函数，用来从堆中分配块
* calloc 函数将分配的内存初始化为 零
* realloc 函数想要改变一个以前分配块的大小

#### 垃圾收集

* 在 C 语言中，应用通过 malloc 和 free 来分配和释放堆块。应用要负责释放所有不需要的已分配块

### 第十章

#### Unix I/O

* 所有 I/O 设备（例如网络，磁盘和终端）都被模型化为文件，而所有输入和输出都被当做对响应文件的读和写来执行。I/O 设备映射为文件的方式，允许 Linux 内核引出一个简单，低级的应用接口，称为 Unix I/O，使得所有输入和输出都能以一种统一一致的方式来执行
  * 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做**描述符**，扫描符在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个扫描符
  * Linux shell 创建的每个进程开始时都有三个打开文件
    * 标准输入（描述符为 0	STDIN_FILENO）
    * 标准输出（描述符为 1    STDOUT_FILENO）
    * 标准错误（描述符为 2    STDERR_FILENO）
  * 改变当前文件的位置。对于每个打开的文件，内核保持着一个文件的位置 k，初始为 0。这个文件位置是从文件头开始的字节偏移量。应用程序能够通过执行 seek 操作，显式的设置文件当前的位置为 k
  * 读写文件。
    * 读操作：一个读操作就是从文件复制到 n > 0 个字节到内存，从当前文件位置 k 开始，然后将 k 增加到 k + n。给定一个大小为 m 字节的文件，当 k >= m 时执行读操作会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件
    * 写操作：一个写操作就是从内存复制到 n > 0 个字节到一个文件，从当前文件位置 k 开始，然后更新 k
  * 关闭文件：当应用完成了对文件的访问后，通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述池中。无论进程因为何种原因终止，内核都会关闭所有打开的文件并释放它们的内存资源

#### 文件

* 每个 Linux 文件都有一个类型（type）来表明它在系统中的角色
  * 普通文件：包含任意数据。应用程序常常区分文本文件和二进制文件
    * 文本文件是只含有 ASCII 或 Unicode 字符的普通文件
    * 二进制文件是所有其他的文件
    * 对内核而言，文本文件和二进制文件没有区别
  * 目录( dircetory )：是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录，每个目录至少含有两个条目
    * “.” 是该目录自身的链接
    * “..” 是到目录层次结构中父目录的链接
  * 套接字：socket 用来与另一个进程进行跨网络通信的文件
  * 其他文件类型包括 命名通道，符号链接，以及字符和块设备

* Linux 内核将所有文件都组织成一个目录层次结构，由名为 / 的根目录确定，系统中的每个文件都是根目录的间接和直接的后代

#### 用 RIO 包健壮的读写

* RIO 包主要处理不足值，主要提供了两类不同的函数
  * 无缓冲的输入和输出函数：这些函数直接在内存和文件之间传送数据，没有应用级缓冲，它们对二进制数据读写到网络和从网络读写二进制数据尤其有用
  * 带缓冲的输入函数：这些函数允许从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内（比如 printf 提供的缓冲区）

#### 共享文件

* 内核用三个相关的数据结构来表示打开文件
  * 描述符表：每个进程都有它独立的描述符表，它的表项是由进程打开文件描述符来索引的。每个打开的描述符表项指向文件表的一个表项
  * 文件表：打开文件的集合是由一张文件表来表示的，虽有进程共享这张表，每个文件表的表项组成包括当前文件的位置，引用计数（当前指向该表项的描述表项数），以及一个指向 v-code 表对应表项的指针
  * v-code 表：同文件表一样，所欲进程共享这张 v-code 表。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size