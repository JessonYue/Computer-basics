#### 第一章 计算机系统漫游

跟踪 hello 程序的生命周期开始对系统的学习

```c
#include <stdio.h>

int main() {
    printf("hello world\n");
    return 0;
}
```

* 信息就是位 + 上下文

  1. 从源程序(程序员通过编辑器创建并保存的文本文件 文件名：Hello.c)

  2. **源程序是由 0 和 1组成的位(又称比特)序列，8 个位称为一组 称为一个字节**

  3. 现代计算机系统用 ASCII 表示文本字符，以唯一的单字节大小的整数值表示每个字符，每个文本行都有一个看不见的换行符 \n 结束的 比如

     ```
     #include <stdio.h>
     # = 35 i = 105 n = 110 c = 99 l = 108 u = 117 d = 100 e = 101 sp(空格) = 32 < = 60 s = 115 
     t = 116 d = 100 i = 105 o = 111 .=46 h = 105 > = 62 \n = 10
     ```

  4. 只由 ASCII 字符构成的文件称为文本文件，其他文件称为二进制文件

以上案例说明了在系统的所有信息中(磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传送的数据)都是由一串比特表示，区分不同数据对象的唯一方式是读取这些文件时的上下文，比如不同的在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者机器指令

* Hello.c 的加载流程

  * Hello.c 是从一个高级 C 语言开始的，在运行时每条 C 语句都会被其他程序转换为一系列的低级机器语言指令，这些指令按照一种称为可执行目标程序(可执行目标文件)的格式打包好，并以二进制磁盘文件的形式存放起来
  * Unix 中的源文件转换是由编译器驱动程序完成的 linux -> gcc -o hello hello.c 这个翻译过程分为 4 个阶段 预处理(hello.i) -> 编译器(hello.s) -> 汇编器(hello.o) -> 链接器(hello)  

  (**这里的so和android的so有联系吗？**)

  * 系统的硬件组成 
    * 总线: 贯穿整个系统的一组电子管道，它可以携带信息字节并负责在各个部件间传递，通常总线传递定长的字节快 4 个字节(32位) 8 个字节 (64位)
    * I/O 设备: 是系统与外部的联系通道 (鼠标，键盘，显示器，磁盘驱动器等) ，再开始 hello 就存放在磁盘上，每个 I/O 设备都通过适配器或控制器与总线相连，控制器是 I/O 系统本身或计算机主板，适配器则是一个插在主板上的卡
    * 主存: 临时储存设备，在处理器质性程序时，用来存放程序和程序处理的数据
    * 处理器(CPU): 是解释储存在主存中指令的引擎，CPU 的核心是一个大小为一个字的储存设备，称为程序计数器 (PC)，在任何时刻 PC 都指向主存中的某条机器语言指令 简单操作如下
      * 加载：从主存复制一个字节或者一个字到寄存器，覆盖寄存器原有的内容
      * 储存:   从寄存器复制一个字节或者一个字到主存的某个位置，覆盖这个位置上的原有内容
      * 操作:   把两个寄存器的内容赋值到 ALU 中，ALU 对两个字做算数运算，并将结果存放到寄存器中，覆盖该寄存器中原来的内容
      * 调整:   从指令本身抽取一个字，并将这个字复制到程序计数器(PC) 中，覆盖 PC 中原来的值

  4. 运行 hello 程序: 
     * 当输入字符串 hello 时，shell 程序将字符逐一读入寄存器，再把他存放到内存
     * 敲下回车，结束输入指令，shell 通过一系列指令加载 hello 文件，这些指令将 hello 文件的代码和数据从磁盘复制到主存
     * 当被加载到主存，CPU 就可以执行 hello 的main 程序，将 "hello world" 从主存复制到寄存器中，再从寄存器复制到显示设备上最终显示到屏幕中

* 高速缓存
  * 系统花费大量的时间把信息从一个地方挪到另一个地方，中间的复制过程就是是开销，因此我们的主要目标就是使这些复制尽可能快的完成
  * 根据机械原理，较大的设备要比较小的设备运行慢么，开销大，因此要用更快更小的储存设备，高速缓存(cache memory)，通过在高速缓存里存放可能经常访问的数据，减少系统的开销，加快程序的执行时间

* 储存器由慢到快的级别
  
* 远程二级储存(分布式文件系统，web 服务器) - 本地二级储存(本地磁盘) - 主存 - 高速缓存L3(保存自主存) - 高速缓存L2(保存自L3) - 高速缓存L1(保存自L2) - 寄存器
  
* 操作系统管理文件
  * 进程: 是操作系统对一个正在运行的程序的抽象，一个系统可以同时允许多个进程，并发运行是一个进程的指令和另一个进程的指令交错执行，上下文是操作系统保持跟踪运行所需的所有状态信息，在任何时刻单处理器系统只能执行一个进程的代码，当需要切换时，保存当前进程上下文信息，恢复新进程的上下文
    * 事例中的进程切换
      * shell 等待输入 - 执行 hello - 保存 shell 上下文 - 创建 hello 上下文 - hello 终止 - 恢复 shell 上下文
  * 线程: 进程由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，共享同样的代码和全局数据，线程比进程更高效
  * 虚拟内存: 为每个进程提供了一个独占使用主存假象，每个进程看到的内存都是一致的，称为虚拟地址空间，每个虚拟地址空间由大量准确定义的区构成，从最低地址开始依次是
    * 程序代码和数据区: 对所有的进程来说，代码是从同一固定地址开始，紧接着是和 C 全局变量相对应的数据位置，代码和数据是直接按照可执行目标文件的内容初始化的，事例中就是 hello
    * 堆区: 程序代码和数据在开始运行时就被指定了大小，当调用 malloc 和 free 时，堆可以在运行时动态的扩展和收缩
    * 共享库区: 在地址空间和中间部分是一块用来存放像 C 标准库和数学库的代码和数据区域
    * 栈区:  位于用户地址空间顶部的是用户栈，编译器用它来实现函数的调用，和堆一样，栈也可以在程序执行期间动态扩展和收缩，每次调用一个函数栈就会增长，一个函数返回，栈就会收缩
    * 内核虚拟内存: 地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数
  * 文件: 字节序列，每个设备(I/O) 都可以看成文件

* 系统之间的网络通信
  
* 客户端键入 "hello" 敲下回车 - 发送字符串到服务器 - 服务器传给 shell 程序 - shell 允许 hello 程序 - 输出行返回客户端 - 客户端输出本地
  
* Amdahl 定律：
  
* 系统某个初始部分耗时比例为 60% ，其加速比例因子为 3，则可以求出加速比为 1.67 倍
  
* 并发和并行:
  * 并发: 一个系统同时具有多个活动	并行: 用并发来使一个系统运行的更快
  * 线程并发: 构建在进程的抽象之上，能够在一个进程中执行多个控制流，是通过不断切换线程来实现的
  * 多核处理器: 多个 CPU 集成到一个集成电路芯片上，每个核都有自己的高速缓存。共享更高层次的告诉缓存
  * 超线程(同时多线程): 允许一个 CPU 执行多个控制流

* 指令级并行: 在较低的抽象层次上，现代处理器可以同时执行多条指令的属性，比如流水线就是执行多条指令的一种
* 单指令，多数据并行(SIMD并行): 在最低层次上，一条指令产生多个可以并行执行的操作
* 抽象的重要性:
  * 例如为一组函数提供一个简单的程序接口
  *  I/O 是对设备的抽象，虚拟内存是对程序储存器的抽象，进程是对运行程序的抽象，虚拟机是对整个计算机的抽象

#### 小结

​		计算机系统是由硬件和软件组成的，计算机内部的信息被表示为一组组的位(8位一个字节)，它们依据上下文有不同的解释方式，程序被其他程序翻译成不同的形式，开始都是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件

​		CPU 处理并解释存放在主存中的二进制指令，需要花费大量的时间进行复制，因此产生了高速缓存的层次结构，层级越高体积越小，速度越快，通过对储存层次结构的认识，可以优化程序的性能

​		内核是应用程序和硬件的媒介，提供了几个基本的抽象 I/O 是对设备的抽象，虚拟内存是对程序储存器的抽象，进程是对运行程序的抽象，虚拟机是对整个计算机的抽象

​		网络是一种 I/O设备

