#### 第二章 信息的表示和处理

现代计算机储存和处理的信息是以二进制信号表示的，其中有三种重要的数字表示

* 无符号(unsigned)	基于传统的二进制表示法，表示大于或者等于零的数字
* 补码(two's-complement)   表示有符号的整数的最常见的方式，有符号数就是可以为正或为负的数字
* 浮点数(floating-point)  表示实数的科学记数法的以 2 为基数的版本

计算机用这些不同的表示方法实现算数运算

计算机的表示法是用有限的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出(overflow)

整数的运算满足人们所熟知的真正整数运算的许多性质，例如 乘法结合律和乘法交换律

浮点数运算是不可结合的，例如在 C 语言中 (3.14 + 1e20) - 1e20 的值为 0 而 3.14 + (1e20 - 1e20) 的值为 3.14

整数运算和浮点运算有不同的数学属性是因为 整数的表示时精确的而浮点表示是近似的

* 信息的储存
  * 机器级程序将内存视为一个非常大的字节数组称为虚拟内存。
  * 内存的每个字节都由一个唯一的数字标识，称为地址
  * 所有的地址的集合称为虚拟地址空间
  * 十六进制表示法
    * 一个字节由 8 位组成，二进制表示法太冗长，替代方式是十六进制数（简写 "hex"）
    * 十六进制使用数字 0~9 以及字符 A~F 来表示 16 个可能的值，在 C语言中 0X 或 0x 开头的数字常量被认为是十六进制数，不区分大小写
    * 十六进制转二进制可以通过记住每个数字对应的值来进行转换 比如 0x173A4C 即 173A4C 每个数字展开成二进制在拼接即使二进制数
    * 二进制转十六进制可以把一个二进制数分为每4位一组，如果总数不是4的整数倍，最左边的一组可以少于4位，前面补0，然后将4位转换成十六进制在拼接

```
十六进制	  十进制		二进制
	 0				 0			0000
	 1				 1			0001
	 2				 2			0010
   3				 3			0011
...
   D			   13			1101
   E				 14		  1110
   F				 15			1111
```

* 字数据大小

  * 每台计算机都有一个字长(word size)，通常是32位或64位，代表指针数据的标称大小(nominal size)，字长决定了虚拟地址空间的最大值，例如一个字长为 w 位的机器，虚拟地址范围是 0 ~ 2^w - 1
  * 大多数 64 位机器向后兼容 32位机器，反之不行
  * C 语言中只有 char* 和 long 在 32位 和 64位的机器中不同
    *  char*  	32占 4 个字节	64占8个字节
    *  long        32占 4 个字节	64占8个字节

* 寻址和字节顺序

  * 对于跨越多字节程序的对象，必须建立两个规则：这个对象的地址是什么以及在内存中是如何排序的
  * 几乎在所有的机器上，多字节对象都被储存为连续的字节序列，对象的地址为所使字节中最小地址
  * 排列一个对象的字节有两个通用的规则
    * 大端法	最高有效字节在最前面
    * 小端法.   最低有效字节在最前面
    * android 和 IOS 都是小端模式
    * 网络传输中为了避免不同类型之间字节顺序不一样，必须遵守网络应用的字节顺序的规则，发送方内部转换成网络标准，接收方按照网络标准转换为需要的内部表示


* 表示字符串: C 语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组，每个字符都由某个标准编码来表示，比如 ASCII 码
* 表示代码：不同机器之间二进制代码不兼容，因此二进制代码很少能在不同机器和操作系统之间移植
* 布尔代数：^ 异或  任何数和 0 异或  则结果为任何数本身，任何数和 1 异或，则结果为任何数取反
* 位级运算:  确定一个位级表达式最好的方法是将十六进制的参数扩展成二进制表示并执行二进制运算，然后在转回十六进制 | & ~ ^
* 逻辑运算符: || && ! ，和位级运算不同
* 移位运算: x 向左移 k 位，丢弃最高的 k 位，在右端补 0，x 向右移 k 为，丢弃最低的 k 位，在左端补 0，对于无符号数，右移必须是逻辑位移，C 语言中进行位移操作最好加上括号
* 整数表示: unsigned 表示非负整数， signed 表示负数，整数，零，两者取值范围不同
* 无符号数的编码：无符号数的二进制 0 ~ 2^w - 1之间的数都有唯一一个 w 位的值编码，例如 十进制值 11 只有一个 4 位 的表示 [1011]
* 补码编码:不太理解，应该是计算机按照补码编码的方式计算 int 型变量 b 的值， 补码主要用于表示有符号数，按位取反与补码编码无关，但是结果一样，TMax 有符号数的最大值，TMin 有符号数的最小值，UMax 无符号数的最大值
* 有符号数和无符号数的转换:如果取值在 0 <= x <= TMax，在位级的表示上没有变化(都一样)，如果在取值范围之外取值范围需要加上或者减去 2^w
* C 语言中的有符号数和无符号数，无符号数后缀有 U 或 u 比如 0x1A2Bu，如果没有后缀默认为有符号数，**当有符号数和无符号数运算时，会把有符号数强转无符号数，并假设两个数都是非负的,这样做对标准运算没有什么差异，但是对位移运算影响较大**
* 扩展一个数字的位表示
  * 要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加 0 这种称为**零扩展**
  * 将一个补码数转换为更大的数据类型要执行**符合扩展** 规则是在表示位中添加最高有效值的值的副本
  * 一个数据大小到另一个数据大小的转换，以及一个有符号和无符号数字的转换顺序不一样，得到的结果也不一样

* 截断数字
  * 截断无符号数: 当一个 w 位的数截断为一个 k 位的数时，丢弃 w - k 个高位
  * 截断补码数值:  不太理解公式含义



####  小结

​		储存二进制表有三种方式(无符号，补码，浮点数)，储存的表示法为十六进制表示法，储存大小由字长(通常是 32 位 和 64 位)决定，多字节储存的方式通常是连续的内存地址，分为大端法和小端法两种，可以表示字符串，代码，布尔代数和整数，整数分为有符号数(非负数)和无符号数(负数，正数，零)，两者取值范围不一样，运算规则分为位级运算，逻辑运算，移位运算，有符号数和无符号数之间运算时，会把有符号数转成无符号数，并假设两个数都是非负数再进行运算，对位移运算影响较大，有符号数和无符号数可以进行相互的转换，如果要将数据类型不同的数据进行转换可以进行扩展和截取操作

##### 思考

​		补码编码，无符号数编码，无符号数和有符号数转换，具体运算方式不太理解(主要是公式的运算符看不懂)







##### 整数运算

​	由于计算机的有限性，两个整数相加可能会得出一个负数， X < Y 和  X - Y < 0 也会产生不同的结果

* 无符号加法 两个非负整数 x y 相加如果结果大于 2^w 就会造成溢出
  * 模运算：x=9 y=12 对应位表示 [1001] 和 [1100]，x + y = 21 对应位表示 [10101]，去掉最高位正是 [0101]，即 21 % (2^ 4) = 5
  * 如果 x + y < 2^w，x + y 的 w + 1 位表示中的最高位为 0，丢弃它不会改变数值，如果 2^w <= x + y < 2^(w + 1) 最高位为 1 ，丢弃它相当于减去了 2^w
  * C 程序不会将溢出作为错误信号，需要判断是否溢出时 s = x + y 如果 s < x （或者 s < y）则溢出

* 补码加法
  * 当 x + y > TMax 时 发生正溢出，这种情况下截断的结果是从和中减去 2^w 
  * 当 x - y  < TMinx 时 发生负溢出，这种情况下截断的结果是从和中加上 2^w

* 补码的非 
  * 对 w 位的补码来说，TMin 是自己加法的逆，而对其他数值 x 都有一个 -x 作为其加法的逆
  * 补码非的位级表示，对一个位级补码去补，然后对结果加 1，结果就是补码的非

* 无符号乘法
  *  C 语言中无符号位乘法被定义为产生的 w 位的值，就是 2w 位乘积的低 w 位表示的值

* 补码乘法
  * C 语言中的有符号乘法是通过将 2w 位的乘积截断为 w 位来实现的，将一个补码数截断为 w 位相当于先计算该值的模 2^w，再把无符号数转换为补码
  * 对于每一对位级运算数，执行无符号和补码乘法，得到 6 位的乘积，然后再把乘积阶段到 3 位。无符号位的截断的乘积总是为 ( x * y ) % 8，无符号和补码两种乘法乘积的 6 位表示不同，但是截断后的乘积位级表示都相同





* 乘以常数
  * 以往，在大多数机器上，整数乘法指令相当慢，除法指令比乘法指令更慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如，加法，减法，位级运算和移位) 只需要 1 个时钟周期，因此编译器用位移运算和加法运算优化了乘法运算和除法运算
  * 乘以 2 的幂，左移幂位，例如一个表达式 x * 14 可以换算成 2^3 + 2^2 + 2^1
  * 除以 2 的幂，右移幂位



##### 浮点数

* 二进制小数
  * 假设仅考虑有限长度的编码，十进制表示法不能准群的表达像 1/3，5/7 这样的数，类似小数的二进制表示法只能表示能够被写成 x * 2^y 的数，其他的值只能近似的表示，例如 1/5 可以用十进制小数 0.20 表示，但是并不能把它准确的表示为一个二进制小数，二进制小数只能近似的表示它，增加二进制表示的长度可以提高表示的精度
  * IEEE 浮点表示  V = (-1)^s * M * 2^e
    * s  决定这个数是正数(s=0)还是负数(s=1)
    * M 是一个二进制小数它的范围是 1 ~ 2-E 或者 0 ~ 1-E
    * E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)
    * 浮点数的位划分为三个字段 s，exp，frac
    * 规格化的值 exp 的指数部分不全为零也不全为1(比如：0 1100 0000)
    * 非规格化数 exp 的指数部分全为零或全为1(比如：0 0000 0000，0 1111 0000)
    * 特殊值 指码阶码全为 1，当 s = 0 时代表 正无穷，当 s = 1 时代表负无穷，当小数域都为零时，相乘或相除会造成溢出，当小数域为非零时，结果值被称为 "NaN"，即不是一个数
* IEEE 计算示例

```
公式: V = 2^E * M
E: 阶码
M: 尾数(小数部分)

0	0110 0100
0(位数 s) 0110(阶码 E) 0100(小数 M)			

规格化数公式:
E = e - (2^(k-1)-1) 
e = 阶码的指数 0110 转换成十进制 = 6
k = 位数 = 4
M = 1 + f
f = M 的指数 0100 （所有的 M 区域都为小数） = 2^-2 = 1/4 = 0.25
M = 0.25 + 1 = 1.25
因此 
E = 6 - (2^3 - 1) = -1
因此通过公式
V = 2^-1 * 1.25 = 0.5 * 1.25 = 0.625
非规格化数公式
E = 1 - (2^(k-1)-1)
M = f
f = M 的指数 0100 （所有的 M 区域都为小数） = 2^-2 = 1/4 = 0.25
M = 0.25

如果把 0	0110 0100 改成 1 0110 0100 那么最终的值就是 -0.625

如果一个非规格化数 0 1111 0110 那么它代表无穷大

再比如
32位 float  s=1 k=8 n=32		比如 0 01001010 010101010101010101010101010101010101010
s 来判断是正数还是负数，
k 判断是否是一个数如果是 11111111 那么代表无穷大，如果是 00000000 那么 E 位等于零，M 位的大小就是这个数的大小
```

* 舍入
  * 因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似的表示实数运算，因此，对于值 X 能找到最接近的匹配值，可以用期望的浮点形式表现出来，这是舍入的运算任务
  * IEEE 的默认舍入方式向最接近的可表示的值，它与四舍五入只有一点不同，对.5的舍入采用去偶的方式，比如: 0.5 = 0，1.5 = 2，2.5 = 2，3.5 = 4
  * 还有另外三种舍入方式
    * 向零舍入方式，把正数向上舍入，把负数向下舍入 比如，1.232 = 1，-1.213 = -1
    * 向负无穷大(向下)舍入：比如: 1.231 = 1，-1.23432 = -2
    * 向正无穷大(向上)舍入: 比如 1.231 = 2，-1.123 = -1

* C 语言标准不要求使用 IEEE 浮点，但是采用 IEEE 的默认舍入方式，但是不能修改舍入方式



#### 知识增补

* 原码，反码，和补码运算

```
1. 一个正数的源码，反码和补码都是这个整数本身
2. 一个负数(以 -123 为例)
	正数的 123 是 0 111 1011		0 表示 符号位 1 为负，0 为正
	因此 -123 的原码就是 1 111 1011
	反码就是除了符号数，其余位数都取反
	因此 -123 的反码就是 1 000 0100
	补码就是在反码的基础上加 1
	反码就是 1 000 0101
3. 0 可以看出正数也可以看出负数 因此有两种写法
	原码 0 0000 0000 或者 1 0000 0000
	反码 0 1111 1111 或者 1 1111 1111
	补码在反码的基础上加 1 如果最后 1 位是 1 需要进位 (1被丢弃)0 0000 0000 
```

* 有符号数和无符号数的转换
  * 本质: 在有符号和无符号之间相互转换的时候，基本规则: 位模式不变，解析规则变化。假设一个有符号数字长等于 4 即 w = 4 的数 1101 转换成无符号数位向量依然是 1101
  * 1101 -> 1101 不同点在于如果是有符号位最高位解析为符号位，无符号位最高位解析为值

```c
void show_bytes(unsigned char *start, size_t len) {
    size_t i;
    for (int i = 0; i < len; ++i) {
        printf("%.2x",start[i]);
    }
    printf("\n");
}

void show_short(short var){
    show_bytes((unsigned char*)&var,sizeof(short));
}

void show_u_short(unsigned short var){
    show_bytes((unsigned char*)&var,sizeof(unsigned short));
}

int main() {
    short int var1 = -12345;
    unsigned short int uvar1 =(unsigned)var1;

    printf("var1=%d\t",var1);
    show_short(var1);

    printf("uvar1=%u\t",uvar1);
    show_u_short(uvar1);

    // 计算两个值的绝对值和
    printf("|var1| + uvar1 = %d\n",uvar1 -var1);
    return 0;
}

// 打印结果
// var1=-12345	c7cf
// uvar1=53191	c7cf
// |var1| + uvar1 = 65536
// MAX UNSIGEND Short = 65535

可以看出当 var1 强制类型转换成无符号数时，虽然位模式都是 c7cf，但是确解析成了两个不同的数
注意 -12345 和 53191 之间的关系，计算两个数的绝对值的和
|var1| + uvar1 = 65536 与 unsigned short 的最大值 65536 相差 1
结论: 将一个以补码方式表示的数转换成无符号数，如果这个数 小于 0 值就等于这个数本身 加上 2 的字长的次方
x < 0 = x + 2^w
比如 -12345 < 0 符合这个条件，那么 -12345 的无符号数就等于 -12345 + 2^16 = 53191
假设 var >= 0 那么无符号数就等于这个数的绝对值
把 var1 改成 12345 打印结果
// var1=12345	3930
// uvar1=12345	3930
// |var1| + uvar1 = 0
// MAX UNSIGEND Short = 65535 无符号数补码的情况
```



#### 总结

​		 大多数计算机对整数使用补码编码，而对浮点数使用 IEEE 标准 754 编码。在长度相同的无符号和有符号整数之间进行张志类型转换时，大多数 C 语言实现遵循的原则是底层的位模式不变。需要注意的是 C 语言隐式的强制类型转换会出现无法预计的错误。由于编码长度有限，与传统的整数和实数运算相比，计算机运算具有不同的属性，需要考虑溢出的可能性。浮点只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性，因此计算过程中应该注意