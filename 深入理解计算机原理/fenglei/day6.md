#### 汇编语言基础

* 汇编语言由一下 3 类组成
  * 汇编指令  (机器码的助记符)   比如 mov  jmp 可以直接翻译成机器码
  * 伪指令  (有编译器执行)       计算机不能识别，但是编辑器可以识别，是辅助编译器转换成机器码的
  * 其他符号 (由编译器识别)     + - * / ?  计算机不能识别与伪指令类似

* CPU 是计算机的核心部件，它控制整个计算机运作并进行运算，要想让一个 CPU 运作，就必须向它提供指令和数据，指令和数据在存储器中存放，也就是平时所说的内存
* 在一台计算机中内存的作用仅次于 CPU，离开了内存，性能再好的  CPU 也无法运作
* 磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被 CPU 使用

一个二进制数据   1000 1001 1101 1000 既可以是数据也可以数指令

数据：89D8H

指令:  MOV  AX  BX (把 BX 放入 AX，BX 和 AX 都是寄存器的一种)

具体是指令还是数据由程序员决定

* 储存器(不一定是内存 比如: 显存)被划分为若干个存储单元，每个存储单元从零开始编号
* CPU 想要进行数据的读写，必须和外部的器件交互
  * 储存单元地址（地址信息）
  * 器件选择，读写命令（控制信息）
  * 读或写数据（数据信息）

##### CPU 对处理器的读写操作

* 总线：计算机中专门连接 CPU 和其他芯片的导线，通常称为总线（Bus）
  * 逻辑上分为
    * 地址总线: 地址总线上能传送多少个不同信息，CPU 就可以对多少个储存单元进行寻址（32 位有 32 条线，64 位有 64 条线）
      * 64 位的地址总线想要完全达到 64 位的读取量必须具备 64 位的 CPU，64 位的操作系统，64 位的操作软件
      * 一个 CPU 有 N 根总线，则可以说这个 CPU 地址总线的宽度为 N，这样的 CPU 最多可以寻找 2 的 N 次方个内存单元
    * 控制总线: CPU 的外部器件是通过控制总线来进行的，控制总线是一些不同控制线的集合，有多少跟控制总线，就意味着  CPU 提供了对外部器件的多少种控制
    * 数据总线: 数据总线的宽度决定了 CPU 和 外界的数据传输速度
  * 读：地址总线发送地址找到需要读取的数据 -> 控制总线发出读的指令 ->  数据总线把读出的数据读取到 CPU
  * 写:  地址总线发送地址找到需要写入的地址 ->  控制总线发出写的指令 -> 数据总线把数据写入到地址中
  * 

##### 内存地址空间

一个 CPU 地址线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成了这个 CPU 的内存地址空间

* 随机存储器（RAM）随机存储器的特性是断电之后数据会丢失
* 只读存储器（ROM）永远只能读的存储器，断电之后数据不会丢失
* BIOS: 是由主板和各类接口卡（如显卡，网卡）厂商提供的软件系统



##### 寄存器

* 通用寄存器：段地址* 16 + 偏移地址，通用寄存器可以储存任何数据，然后把它们分配到指定的寄存器中
* 8086(x86) 有 14 个寄存器，它们分别是 AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW

* AX，BX，CX，DX 通常用来存放一般性的数据被称为通用寄存器
  * 10010 在寄存器中存储

```
15	14	13	12	11	10	9	  8	  7	  6	  5	  4	  3	  2	  1
0		0		0		0		0		0		0		0		0		0		1		0		0		1		0
```

* * 0100111000100000 在寄存器中存储

```
15	14	13	12	11	10	9	  8	  7	  6	  5	  4	  3	  2	  1
0		1		0		0		1		1		1		0		0		0		1		0		0		0		0
```

* 一个 16 位的寄存器能储存的最大的值为 2^16 - 1 = 25535
* 8086 的上一代是 8 位的寄存器，为了保证兼容性，每个 16 位寄存器可以分成两个独立的寄存器
  * 因此 AX 寄存器可以分为 AL (0位~7位)和  AH(8位~15位) (H 是高位，L 是低位)，BX，CX，DX 依然如此
  * AH 和 AL 是可以独立使用的寄存器 

##### 字

* 1 word  = 2 byte = 16 bit

* 一个字可以存在一个 16 位的寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中
* 十六进制转二进制 比如  0100 1110 0010 0000 == 4(0100) E(1110) 2(0010) 0(0000) = 4E20

##### 几条常用的汇编指令

* 汇编指令不区分大小写

| 汇编指令  | 控制CPU完成的操作                                   | 用高级语言的语法描述 |
| --------- | --------------------------------------------------- | -------------------- |
| mov ax,18 | 将 18 输入 AX 寄存器                                | AX = 18              |
| mov ah,78 | 将 78 输入 AH 寄存器（AH 寄存器是 AX 的高位寄存器） | AH = 78              |
| add ax,8  | 将 AX 寄存器中的值加8                               | AX = AX + 8          |
| mov ax,bx | 将 BX 寄存器中的数据送入寄存器 AX                   | AX = BX              |
| add ax,bx | 将寄存器 AX 和 BX 的数值相加，结果存入 AX 寄存器中  | AX = AX + BX         |

 

##### CPU 内存工作原理

* 16 位的 CPU 具有以下特性
  * 1.运算器一次最多可以处理 16 位的数据
  * 2.寄存器的最大宽度为 16 位
  * 3.寄存器和运算器之间的通路是 16 位

* 8086 的 CPU 有 20 位地址（外部）总线，可以传送 20 位地址（2^20），寻址能力 1M，内部总线为 16 位结构，只能传送 16 位的地址，表现出寻址能力却只有 64K（2^16）
*  8086CPU 采用一种内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址 
  * 通过地址加法器把段地址和偏移地址合成一个 20 位的物理地址
  * 即 段地址 * 16  = 基础地址 + 偏移地址 = 物理地址，（十六进制的段地址）乘以 16 相当于向左移一位，二进制相当于向左移 4 位
  * 根据上面的公式可以得出很多种 段地址和偏移地址（比如 2 * 16 + 30 = 62，3 * 16 + 14 = 62）在 CPU 中也是这么做的，因此衍生出了多种的组合法

* 段的概念
  * 由于 8086CPU 采用 段地址 * 16 = 物理地址 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存
  * 段只是我们便于理解 CPU 内存强加的概念，实际上再 CPU 中是没有段的划分的
  * 段地址 * 16 必然是 16 的倍数，因此一个段的起始地址也一定是 16 的倍数
  * 偏移地址为 16 位，16 位地址的寻址能力为 64K，所以一个（偏移）段的长度最大是 64K
  * 因此可根据需要将连续地址的起始地址为 16 倍数的一组内存单元定义为一个段

* 段寄存器
  * 在 8086CPU 中有 4 个段寄存器
    * **分别是 CS（代码段地址寄存器），DS（数据段地址寄存器），SS（堆栈段地址寄存器），ES（附加段地址寄存器）**
  * CS 代码段地址寄存器
    * CS 和 IP（指令指针寄存器）是 8086CPU 中最关键的寄存器，因为他们指示了 CPU 当前要读取的地址
    * 在 8086CPU 开始工作时，CS 和 IP 被设置为 CS = FFFFH，IP = 0000H，即 CPU 内存 FFFF0H 单元读取指令执行的，FFFF0H 单元中的指令是 8086PC 机开机执行的第一条指令
    * MOV 指令不能对 CS IP 进行操作，8086CPU 提供了另外的指令来改变它们的值
  * 转移指令
    * 同时修改 CS IP 的内容: jmp 段地址：偏移地址
      * 比如 jmp 2AE3:3 （段地址 * 16 = 物理地址 的通用写法）  告诉 CPU 跳到 2AE33 地址
      * 比如 jmp 3:0B16  告诉 CPU 跳到 B46  地址
      * 仅修改 IP : jmp ax （类似于 mov IP,ax）该指令常用于寄存器中的值修改 IP
      * 如果 IP 执行完当前指令，会默认执行下面的指令
  * 代码段
    * 在 8086CPU，在编程时，可以根据需要将一组内存单元定义为一个段
    * 可以将长度为 N （N <= 64KB）的一组代码存在一组地址连续，其实地址为 16 倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段
  * CPU 只认为被 CS:IP 指向的内存单元中的内容为指令

##### CPU 与内存的互动

* 内存中的字的储存
  * 任何两个地址连续的内存单元，N 号单元和 N + 1 号单元，可以将它们看成两个内存单元，可以将它们看成是一个地址为 N 的字单元中的高位字节单元和低位字节单元
* DS 数据段地址寄存器
  * 8086CPU 中有一个 DS 寄存器，通常用来存放访问的数据段地址
  * 将内存中的数据送入寄存器 mov al,[0]，[] 中的 0 说明这个内存单元的偏移地址是 0，它的段地址默认放在 DS 中
  * 8086CPU 不支持将数据直接送入段寄存器的操作，必须经过通用寄存器，DS 是一个段寄存器（硬件设计问题）
  * 因此如果想要将寄存器的数据送往内存单元则

```C
mov bx,1000H // 把 数据 1000H 放入通用就存起
mov ds,bx   //  把 bx 中的数据(就是 1000H) 放入 数据段地址寄存器 ds 中
mov [0],al  //  将寄存器中的数据放入内存中
```

* mov add sub 指令
  * mov 指令的几种形式
    * mov 寄存器,数据
    * mov 寄存器,寄存器
    * mov 寄存器,内存单元(偏移地址)
    * mov 内存单元,寄存器
    * mov 段寄存器,寄存器(通过通用寄存器传输)
    * mov 寄存器,段寄存器(直接传送)
  * add 和 sub 指令同 mov 一样，都有两个操作对象，逻辑与 mov 一样

* 数据段
  * 前面讲过，对于 8086 机，我们可以根据需要将一组内存单元定义为一个段（可以是代码段，数据段）
  * 我们也可以将一组长度为 N （N <= 64K），地址连续，起始地址为 16 的倍数的内存单元当做专门储存数据的内存空间，称为数据段
  * 比如用 123B0H ~ 123B9H 这段空间来存放数据
    * 段地址为 123BH
    * 长度 10 个字节
    * 数据段通过 ds 传输

##### 栈

* 栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于最后进入的数据是最先出去的
* 栈有两个基本操作 入栈 和 出栈
  * 入栈: 将一个新元素放入栈中
  * 出栈: 从栈顶取出一个元素
* 8086CPU 提供先关的指令来以栈的方式访问内存空间，这意味着，我们在基于 8086CPU 编程时可以将一段内存当做栈使用
  * push 入栈	push ax 将寄存器的数据推入栈中
  * pop 出栈      pop ax 从栈顶取出数据放入 ax
  * 8086CPU 的入栈出栈都是以字为单位进行的
  * 堆栈地址寄存器 SS 存放栈顶的段地址
  * 寄存器 SP 存放栈顶的偏移地址
  * 任何时刻 SS : SP 指向栈顶元素
  * 当执行 push ax 的时候 cpu 内部做了两个操作 
    * SP = SP - 2
    * 将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶
  * 当执行 pop ax 的时候 
    * SP = SP + 2
    * SS:SP 指向当前的栈顶下面的单元，以当前栈顶下面的单元为新栈顶
* 栈顶的超界
  * SS 和 SP 只能保证记录栈顶的地址，依靠 SS 和 SP 可以保证在入栈和出栈时找到栈顶
  * 当栈满或栈空的时候在使用 push 或 pop 指令会造成栈顶超界（越界）的问题
  * CPU 没有检查栈顶越界的功能，因此栈顶越界应该由我们自己控制
* 栈和内存
  * 栈只是一种数据存放的形式，栈空间也是内存空间的一部分
  * push 内存单元: 将一个内存单元处的字入栈（栈操作都是以字为单位的） 例如 push [0]
  * pop 内存单元：用一个内存单元接收出栈的数据 例如 pop [2]
  * 执行指令时 CPU 要知道内存的单元地址，可以给出偏移地址，段地址在指令执行时 CPU 从 ds 中获取
  * 数据的段地址永远从 ds 中获得，代码的段地址永远从 cs 中获得，栈的段地址永远从 ss 总获得

* 栈段
  * 类似数据段，代码段，我们可以将长度 <= N （N <= 64K）的一组连续地址，起始地址为 16 的倍数的内存单元，当做栈来使用，从而定义了栈段
  * 将一段内存当做栈段，只是我们在编程时的一种安排，CPU并**不会**就执行 push ，pop 等栈操作指令时就自动的将我们定义的栈段当做空间来访问

