### 第七章 链接

* 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
* 链接可以执行于编译时，也就是源代码被翻译成机器代码时，也可以执行于加载时，也就是在程序被加载器加载到内存并执行时，甚至于运行时，也就是由应用程序来执行，链接是由叫做链接器的程序自动执行的
* 理解链接器能够主要解决的问题
  * 构造大型程序时经常会遇到由于缺少模块或缺少库或者不兼容的库版本引起的链接器错误。在默认的情况下，错误定义的多个全局变量的程序将通过链接器而不产生任何警告信息，会非常难以调试
  * 理解链接器将帮助我们理解语言的作用域规则是如何实现的。例如：全局变量和局部变量之间的区别是什么，当定义一个 static 属性的变量或函数时将意味着什么
  * 链接器产生的可执行目标文件在重要的系统中扮演者关键的角色，比如加载和运行程序，虚拟内存，分页，映射等
  * 理解链接器将使我们能够利用共享库（.so/.a）

#### 编译链接驱动程序

* 编译步骤
  1. **驱动程序运行  C 预处理器将源文件翻译成 ASCII 码中间文件（main.c -> main.i）**
  2. **驱动程序运行 C 编译器，将 main.i 翻译成 ASCII 汇编语言文件（main.i -> main.s）**
  3. **驱动程序运行汇编器，将 main.s 翻译成可重定位目标文件（mian.s -> main.o）**
  4. **驱动器经过相同的步骤生成 sum.o，最后通过链接器程序将 main.o 和 sum.o 以及一些必要的目标文件组合起来，创建一个可执行目标文件 prog**
  5. **shell 中运行可执行文件 prog，shell 调用一个叫做加载器的函数，将可执行文件 prog 中的代码和数据复制到内存中，然后将控制转移到这个程序的开头**

* 实例程序

```c++
// main.c
int sum(int *a, int n);

int array[2] = {1, 2};

int main() {
    int val = sum(array, 2);
    return val;
}

// sum.c
int sum(int *a, int n) {
    int i, s = 0;
    for (i = 0; i < n; ++i) {
        s += a[i];
    }
    return s;
}
```

#### 静态链接

* Linux 的静态链接器以一组可**重定位目标文件**和**命令行参数**作为输入，生成一个完全的链接，可以**加载**和**运行**的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的全部变量又在另一节中。
* 为了构造可执行文件，链接器必须完成两个任务
  * 符号解析：目标文件定义和引用符号，每个符号对应于一个函数，一个全局变量或一个静态变量，符号解析的目的是将每个符号引用正好和一个符号定义关联起来
  * 重定位：
    * 编译器和汇编器生成从地址 0 开始的代码和数据节
      * 重定位节，链接器通过把每个符号定义与一个内存位置关联起来
      * 修改所有对这些符号的引用，使得它们指向这个内存的位置
      * 链接器使用汇编器产生的重定位条目的详细指令，不加甄别的执行这样的重定位

#### 目标文件

* 目标文件有三种形式
  * 可重定位目标文件。包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并起来，创建一个可执行目标文件
  * 可执行目标文件。包含二进制代码和数据。其形式可以被直接复制到内存并执行
  * 共享目标文件。一种特殊类型的可重定位目标文件，可以**加载或者运行时**被动态的加载进内存并连接
  * **一个目标文件就是一个字节序列，一个目标文件就是以一个文件形式存放在磁盘中的目标模块**
  * **ELF：在 x86-65 Linux 和 Unix 系统使用可执行可链接格式**

#### 可重定位目标文件

* ELF 文件格式是由 **ELF 头 ，节头部表和夹在中间的节组成**

|        结构        |   名称    |   作用   |
| :--------------: | :---------: | :--- |
|        节        |   ELF 头    | ELF 头以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序 |
|        节        |    .text    | 已编辑程序的机器代码 |
|        节        |   .rodata   | 只读数据，比如 printf 语句中的格式串和开关语句的跳转表 |
|        节        |    .data    | 已初始化的全局和静态 C 变量。局部 C 变量在运行时保存在栈中，即不出现在 .data 节中也不出现在 .bss 节中 |
|        节        |    .bss     | 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局和静态变量，在目标文件中这个节不占据实际空间，只是一个占位符，目标文件区分已初始化和未初始化变量是为了空间效率，在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0 |
|        节        |   .symtab   | 符号表，它存放在程序中定义和引用的函数和全局变量的信息，和编译器中的符号表不同， .symtab 中 不包含局部变量条目 |
|        节        | .rel  .text | 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。任何调用外部函数或引用全局变量的指令都需要修改，调用本地函数的指令不需要修改 |
|        节        | .rel  .data | 被模块引用或定义的所有全局变量的重定位信息 |
|        节        |   .debug    | 调试符号表，条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件，只有以 -g 选项调用编译器驱动程序，才会得到这张表 |
|        节        |    .line    | 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序，才会得到这张表 |
|        节        |   .strtab   | 字符串表 内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字，是以 null 为结尾的字符串序列 |
| 描述目标文件的节 |  节头部表   | ELF 节头部表包含条目（**entry**）大小和数量，不同节的位置和大小都是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目 |

#### 符号和符号表

* 每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号信息，在链接器的上下文中，有三种不同符号
  * 全局符号：由 m 模块定义并能被其他模块引用的全局符号。全局符号对应于非静态的 C 函数和全局变量
  * 外部符号：由其他模块定义并被 m 引用的全局符号称为外部符号。对应于在其他模块中定义的非静态 C 函数和全局变量
  * 局部符号：只被模块 m 定义和引用的符号。对应带 static 属性的 C 函数和全局变量，这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用
  * 链接器不包含对应本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理

* 符号表是由汇编器构造的，使用汇编器输出到汇编语言 .s 文件中的符号。 .symtab 节中包含 ELF 的符号表
* 条目格式
  * name：字符串表中的字节偏移，指向符号以 null 为结尾的字符串名字
  * type：通常要么是数据，要么是函数
  * binding：表示符号是本地的还是全局的
  * section：每个符号都被分配到目标文件的某个节，由 section 表示，该字段也是一个到节头部表的索引。有三个特殊的伪节
    * ABS：不该被重定位的符号
    * UNDEF：代表未定义的符号，在本模块中引用，但是却在其他地方定义的符号
    * COMMON：未被分配位置的未初始化的数据目标，value 字段给出对齐要求，size 字段给出的最小的大小
      * COMMON 和 .biss 区别很细微，COMMON 未初始化的全局变量  .bss 未初始化的静态变量，以及初始化为 0 的全局或静态变量
    * 只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的
  * value：距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址
  * size：目标大小（以字节为单位）

条目结构

```c++
typedef struct {
    int   name;
    char  type: 4,
          binding: 4;
    char  reserved;
    short section;
    long  value;
    long  size;
} Elf64_Symbol;
```

#### 符号解析

1. 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。
2. 对引用定义在相同模块中的局部符号引用，编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接符号，编译器还要确保他们拥有唯一的名字
3. 对全局符号的引用解析，编译器当遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中固定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就会输出错误并终止

##### 编译器如何解析多重定义的全局符号

* 如果多个模块定义同名的全局符号，在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐藏地址编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化变量的是弱符号，Linux 链接器使用如下规则处理多重定义的符号名
  * 不允许有多个同名强符号
  * 如果一个强符号和多个弱符号同名，那么选择强符号
  * 如果有多个弱符号同名，那么从这些弱符号中任意选择一个

##### 与静态库链接

* 所有编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块
* 相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些库中定义的函数。
* 连接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。

##### 链接器如何使用静态库来解析引用

* 静态库在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序扫描可重定位目标文件和存档文件，在这次扫描中，链接器同时维护三个集合
  * 集合 E：可重定位目标文件的集合，这个集合中的文件最终会被合并起来形成可执行文件
  * 集合 U：未解析的符号集合，即引用了但是尚未定义的符号
  * 集合 D：在前面输入文件中已经定义的符号集合
  * 初始时，E，U 和 D 均为空

* 解析过程
  * 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。如果 f 是一个目标文件，那么链接器会把 f 添加到 E 中，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个输入文件
  * 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号，如果某个存档文件成员 m 定义了一个符号来解析 U 中的一个引用，那么就把 m 添加到 E 中，并将链接器修改 U 和 D 来反映 m 中的符号定义引用。
  * 如果链接器完成对命令行上输入文件扫描后 U  是非空的，那么链接器就会输入一个错误并终止，否则，它会合并和重定位 E 中的目标文件，构建输出的可执行文件

* 关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的，那么这些库就可以任意顺序摆放在结尾，否则必须按顺序摆放，如果需要满足依赖需求，可以在命令行上重复摆放库

#### 重定位

* 链接器完成了符号解析之后，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来，此时链接器就知道它的输入目标模块中的代码节和数据节的确切大小，之后就可以进行重定位，重定位分为两步
  * 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节 例如：将所有输入模块的 .data 节全部合并成一个节，这个节成为输出的可执行目标文件的 .data 节
  * 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行地址，要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构

##### 重定位条目

* 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。因此无论何时汇编器遇到对最终位置未知的目标引用，都会生成一个重定位条目，告诉链接器再将目标文件合并可执行文件时如何修改这个引用。代码的重定位放在  .rel .text 中，已初始化数据的重定位条目放在 .real .data 中

*  ELF 重定位条目格式
  * offset：需要被修改的引用的节偏移
  * symbol：标识被修改引用应该指向的符号
  * type：告知链接器如何修改新的引用
  * addend：是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整

```c++
typedef struct {
  long offset;
  long type:32,
  		 symbol:32,
  long addend;
}Elf64_Real;
```

#### 可执行目标文件

* 可执行目标文件的格式类似于可重定位目标文件的格式。ELF 头文件描述文件的总体格式。它还包括入口，也就是当程序运行时要执行的第一条指令的地址。.text .rodata 和 .data 节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。 .init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。可执行文件是完全链接的（已被重定位），所以不需要 rel 节

#### 动态连接共享库

* 静态库明显的缺陷
  * 静态库和所有软件一样，需要定期维护和更新，如果想要一个最新的版本，必须以某种方式了解到该库的更新情况，然后显示的将他们的程序与更新的了库重新链接
  * 每个 C 程序几乎都使用了标准 I/O 函数，比如 pringf 和 scanf，在运行时，这些函数的代码会被复制到每个运行进程的文本中，在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源极大浪费

* 共享库
  * 共享库是致力于解决静态库缺陷的创新产物，共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个内存中的程序链接起来。这个过程称为**动态链接**，是一个叫做动态链接器的程序来执行的
  * 共享库是以两种不同的方式来共享的
    * 任何给定的文件系统中，对于一个共享库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中
    * 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享

#### 从应用程序中加载和链接共享库

* Linux 系统为动态链接库提供了一个简单的接口，允许应用程序在运行时加载和链接共享库

```c++
#include<dlfcn.h>

// 返回：若成功则为指向句柄的指针，若出错则为 NULL
void *dlopen(const char *filename,int flag);

// 返回：若成功则为指向符号的指针，若出错则为 NULL
void *dlsym(void *handle, char *symbol);

// 返回：若成功则为 0，若出错则为 -1
int dlcolse(void *handle);

// 返回：如果前面对 dlopen，dlsym 或 dlclose 的调用失败，则为错误信息，如果前面调用成功则为 NULL
const char *dlerror(void);
```

#### 位置无关代码

* 多个进程是如何共享程序的一个副本的
  * 给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库，这个方法有很大的缺陷，不便于管理
  * 位置无关代码（PIC），可以避免缺陷的发生

* PIC 数据引用
  * 内存中任何地方加载一个目标模块，数据段和代码段的距离总是保持不变的，因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的
  * PIC 在数据段开始的地方创建一个表，称为全局偏移表（GOT），在 GOT 中，每个被这个目标模块引用的全局数据目标都有一个 8 字节条目。编译器还为 GOT 中的每个条目生成一个重定位记录。在加载时，动态连接器会重定位 GOT 中的每个条目，使得它包含目标正确的绝对地址。每个引用全局目标的目标模块都有自己的 GOT

* PIC 函数调用
  * 使用延迟绑定的动机是对于一个像 libc.so 这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分

#### 库打桩机制

* 库打桩运行截获对共享库函数的调用，取而代之执行自己的代码

#### 处理目标文件的工具

* Linux 系统中有大量可用的工具可以帮助理解和处理目标文件，GNU binutils 包尤其有帮助
  * AR：创建静态库，插入，删除，列出和提取成员
  * STRINGS：列出一个目标文件中所有可打印的字符串
  * STRIP：从目标文件中删除的符号表信息
  * NM：列出一个目标文件的符号表中定义的符号
  * SIZE：列出目标文件中节的名字和大小
  * READELF：显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 的功能
  * OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 中的二进制指令
  * LDD：列出一个可执行文件在运行时所需要的共享库