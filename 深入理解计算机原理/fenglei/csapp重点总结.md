### 总结

### 第五章 5.9/5.10/5.11

#### 调高并行性

- 硬件具有以跟高速率执行乘法和加法的潜力，但是代码不能利用这种能力，即使循环展开也不能，因为我们将累积值放在一个单独的变量 acc 中，在前面的计算完成都不能计算 acc 的新值。虽然计算 acc 新值的功能单元能够每个时钟周期开始一个新的操作，但是它只会每 L 个周期开始一条新操作，这里 L 是合并操作的延迟。现在我们试图打破这种顺序相关，得到比延迟更好性能的方法

##### 多个累积变量

- 下面的代码演示了 2*2循环展开，它即使用了两次循环展开，以每次迭代合并更多的元素，也使用了两路并行，将索引数为偶数的元素累积在变量 acc0 中，而索引值为奇数的元素累积在变量 acc1 中，之后对于向量长度不为 2 的倍数时，第二次循环累积所有剩下的元素，最后对 acc0 和 acc1 应用合并运算，得出最终结果
- 2*2 循环对所有情况都得到了改进，可以使性能显著增加

改进代码

```c
void combine6(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    long limit = length - 1;
    data_t *data = get_vec_start(v);
    data_t acc0 = IDENT;
    data_t acc1 = IDENT;

    for (i = 0; i < limit; i += 2) {
        acc0 = acc0 OP data[i];
        acc1 = acc1 OP data[i + 1];
    }
    for (; i < length; i++) {
        acc0 = acc0 OP data[i];
    }
    *dest = acc0 OP acc1;
}
```

##### 重新结合变换

- 第二种打破顺序相关从而使性能调高到延迟界限的方法，下面函数与 combine5 的展开代码唯一区别在于内循环中元素合并的方式，差别仅在于两个括号如何放置，我们称之为重新结合变换，通过括号改变了向量元素与累积值 acc 的合并顺序
- 重新结合变换能够减少计算中关键路径上操作的数量，通过更好的利用功能单元的流水线能力得到更好的性能，但是对浮点运算不保证是可结合的，因此循环展开和并行的累积在多个值中，是提高性能更可靠的方法

```c
void combine7(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    long limit = length - 1;
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;

    for (i = 0; i < limit; i += 2) {
      	// 与 combine5 唯一的区别是括号的位置不同
        acc = acc OP (data[i] OP data[i + 1]);
    }
    for (; i < length; i++) {
        acc = acc OP data[i];
    }
    *dest = acc;
}
```

##### 优化合并代码的结果小结

- 调高并行性通常来讲有两种方式
  - 在二次展开中拆分操作使用多个累积变量的方法来使各个操作并行减少延迟等待的事件
  - 减少计算中关键路径上的操作数量称为重新结合变量，减少关键赋值的次数提高程序性能
- 通过调高并行性并展开二次等一系列优化，上述案例的性能在在其他条件不变的情况下性能提高了 10 倍，说明现代处理器具有相当的计算能力，但是需要我们按照非常程式化的方式编写程序以便于将这些能力诱发出来

#### 一些限制因素

- 寄存器溢出
  - 如果我们将并行度 P 超过了可用的寄存器数量，那么编译器就会产生溢出，将某些值存放到内存中，通常是在运行时堆栈分配空间，比如把 combine6 的多累积变量模式扩展到 k = 10 或 k = 20（现代 x86-64 寄存器有 16 个寄存器，并可以使用 16 个 YMM 寄存器来保存浮点数）时，超过了寄存器数量，程序必须在栈上分配一些变量，这就导致了程序性能可能比之前更差
  - 一般情况下 x86-64 有足够的寄存器，大多数循环在出现寄存器溢出之前就将达到吞吐量限制
- 分支预测和预测错误处罚
  - C 语言如何保证分支预测触发不阻碍程序效率是个很复杂的问题，但是可以注意以下几点
    - 不要过分关心可预测的分支
    - 书写适合用条件传送实现的代码，GCC 能为一种更 功能性 风格书写的代码产生传送条件，这种风格对立一种更 命令式 的风格（下面举例）
    - 命令式风格代码主要看预测对错，如果预测正确性能比功能性代码号，预测错误则性能极差（3 ~ 13）功能性风格代码避免了处理器的预测，因此性能平稳（4 左右）

```c
// 命令式风格代码
void minmax1(long a[], long b[], long n) {
    long i;
    for (int i = 0; i < n; ++i) {
        if (a[i] > b[i]) {
            long t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}

// 功能性风格代码
void minmax2(long a[], long b[], long n) {
    long i;
    for (int i = 0; i < n; ++i) {
        long min = a[i] < b[i] ? a[i] : b[i];
        long max = a[i] < b[i] ? b[i] : a[i];
        a[i] = min;
        b[i] = max;
    }
}
```

#### 理解内存性能

- 现代处理器有专门的功能单元来执行加载的储存操作，这些单元内部的缓冲区来保存未完成的内存操作请求集合。例如：参考机有两个加载单元，每一个可以保存多达 72 个未完成的读请求。它还有一个储存单元，其存储缓冲区能保存最多 42 个写请求。每个这样的单元通常可以每个时钟周期开始一个操作

##### 加载性能

- 要确定一台机器上的加载延迟，我们可以建立由一系列加载操作组成的一个计算，一条加载操作的结果决定下一条操作的地址。

```
typedef struct ELE {
    struct ELE *next;
    long data;
} list_ele, *list_ptr;

long list_len(list_ptr ls) {
    long len = 0;
    while (ls) {
        len++;
        ls = ls->next;
    }
    return len;
}
```

#### 性能提高技术

- 优化程序程序性能的基本策略
  - 高级设计：为遇到的问题选择适当的算法和数据结构。
  - 基本编码原则：避免限制优化的因素，这样编译器就能产生高效代码
    - 消除连续的函数调用，在可能时，将计算移到循环外。考虑有选择的妥协程序的模块性已获得更大的效率
    - 消除不必要的内存引用。应用临时变量来保存中间结构，只有在最后的值计算出来时，才将结构存放到数组或全局变量中
  - 低级优化，结构化代码以利用硬件功能
    - 展开循环，降低开销，并且使得进一步的优化称为可能
    - 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令集并行
    - 用功能性的风格重写条件操作，使得编译采用条件数据传送

### 第六章 6.3-6.5 

* 储存器结构层次结构对应用程序的性能有着巨大的影响。如果你的程序需要的数据是存储在 CPU 寄存器中的，那么在指令的执行期间，在 0 个周期内就能访问到它们，如果储存在高速缓存中，需要 4 ~ 75 个周期。如果储存在主存中，需要上百个周期，而如果储存在磁盘上，需要大约几千万个周期！
* **寄存器 > 高速缓存 > 主存 > 磁盘**

#### 储存技术

##### 随机访问储存器

* 随机访问储存器分为两类：静态的（SRAM）和动态（DRAM）的。静态比动态更快，但也更贵的多。
  * SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下
  * DRAM 用来作为主存以及图形系统的帧缓冲区
  * 典型的，一个桌面系统的 SRAM 不会超过几兆字节，但是 DRAM 却有几百兆或者几千兆字节
* 静态 RAM
  * SRAM 将每个位储存在一个双稳态的储存单元里。SRAM 像一个钟摆，两边是稳定状态（左状态和右状态），其它任何位置都是不稳定状态，从其它任何位置，钟摆都会倒向一边或另一边
  * SRAM 特性：只要有电，它就会永远保持它的值。即使有干扰来扰乱电压，当干扰消除时，电路就会恢复到稳定值

* 动态 RAM
  * DRAM 将每个位储存为对一个电容的充电。与 SRAM 不同，DRAM 储存器单元对干扰非常敏感，当电容的电压被扰乱之后，它就永远不能恢复了，暴露在光线下会导致电容电压改变。

* 传统的 DRAM 
  * DRAM 芯片中的单元被分成 d 个超单元，每个超单元都由 w 个 DRAM 单元组成，一个  d * w 的 DRAM 总共存储了 dw 位信息

* 内存模块
  * DRAM 芯片封装在内存模块中，它插到主板的扩展槽上。
* 增强的 DRAM
  * 有许多的 DRAM储存器，而生产厂商跟上迅速增长的处理器速度，市场上就会定期推出新的种类，每种都是基于 DRAM 单元
    * 快页模式(FPMD RAM) ：传统的 DRAM 将超单元的一整行复制到它的内部行缓冲区，使用一个，然后丢弃剩余的。FPM DRAM 允许同一行连续的访问可以直接从行缓冲区得到服务，从而改进了这一点
    * 扩展数据输出DRAM：FPM DRAM 的一个增强形式，它允许 CAS 信号在时间上靠得更紧密一点
    * 同步 DRAM（SDRAM）： SDRAM 能够比异步的储存器更快的输出它的超单元内容
    * 双倍数据速率同步 DRAM（DDR SDRAM）：DDR SDRAM 是对 SDRAM的一种增强，它通过使用两个时钟沿作为信号，从而使 DRAM 的速度翻倍
    * 视频 RAM（VRAM）。它用在图形系统的帧缓冲区中
      * VRAM 的输出是通过依次对内部缓冲区的整个内容进行移位得到的
      * VRAM 允许对内存并行的进行读和写

* 非易失性储存器
  * 如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的。非易失储存器即使在断电后，仍然保存着它们的信息
  * PROM（可编程 ROM）只能被编程一次。PROM 的每个储存器单元有一种熔丝，只能用高电流熔断一次
  * EPROM（可擦可编程 ROM）紫外线光照射过窗口，EPROM 单元就被清除为 0，对 EPROM 编程是一种把 1 写入 EPROM 的特殊设备来完成的，EPROM 能够被擦除和重编程的次数的数量级可以达到 1000 次
  * EEPROM 与 EPROM 类似，但它不需要一个物理上独立的编程设备，可以直接在印制电路卡上编程， 能够被擦除和重编程的次数的数量级可以达到 10^5
  * 闪存 是一类非易失性储存器，基于 EEPROM，固态硬盘是基于闪存的磁盘驱动器

* 访问主存
  * 读事务：地址 A 的内容被加载到寄存器 ax 中分为三部分
    * CPU 将地址 A 放到系统总线上，I/O 桥将信号传递到内存总线
    * 主存感觉到内存总线上的地址信号，从内存总线读地址，从 DRAM 取出数据字，并将数据写到内存总线，I/O 桥将内存总线信号翻译成系统总线信号，然后沿着系统总线传递
    * CPU 感觉到系统总线上的数据，从总线读数据，并将数据赋值到寄存器 ax 中
  * 写事务：寄存器 ax 的内容写到 A 地址同样分为三部分
    * CPU 将地址放大总线上，内存从内存总线读出地址，并等待数据到达
    * CPU 将 ax 中的数据字复制到系统总线
    * 主存从内存总线读出数据字，并且将这些位储存到 DRAM 中

##### 磁盘储存

* 从磁盘上读信息的时间为毫秒级，比 DRAM 满了 10 万倍，比 SRAM 慢了 100 万倍

### 第七章

#### 编译链接驱动程序

* 编译步骤
  1. **驱动程序运行  C 预处理器将源文件翻译成 ASCII 码中间文件（main.c -> main.i）**
  2. **驱动程序运行 C 编译器，将 main.i 翻译成 ASCII 汇编语言文件（main.i -> main.s）**
  3. **驱动程序运行汇编器，将 main.s 翻译成可重定位目标文件（mian.s -> main.o）**
  4. **驱动器经过相同的步骤生成 sum.o，最后通过链接器程序将 main.o 和 sum.o 以及一些必要的目标文件组合起来，创建一个可执行目标文件 prog**
  5. **shell 中运行可执行文件 prog，shell 调用一个叫做加载器的函数，将可执行文件 prog 中的代码和数据复制到内存中，然后将控制转移到这个程序的开头**


#### 静态链接

* Linux 的静态链接器以一组可**重定位目标文件**和**命令行参数**作为输入，生成一个完全的链接，可以**加载**和**运行**的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的全部变量又在另一节中。
* 为了构造可执行文件，链接器必须完成两个任务
  * 符号解析：目标文件定义和引用符号，每个符号对应于一个函数，一个全局变量或一个静态变量，符号解析的目的是将每个符号引用正好和一个符号定义关联起来
  * 重定位：
    * 编译器和汇编器生成从地址 0 开始的代码和数据节
      * 重定位节，链接器通过把每个符号定义与一个内存位置关联起来
      * 修改所有对这些符号的引用，使得它们指向这个内存的位置
      * 链接器使用汇编器产生的重定位条目的详细指令，不加甄别的执行这样的重定位

#### 目标文件

* 目标文件有三种形式
  * 可重定位目标文件。包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并起来，创建一个可执行目标文件
  * 可执行目标文件。包含二进制代码和数据。其形式可以被直接复制到内存并执行
  * 共享目标文件。一种特殊类型的可重定位目标文件，可以**加载或者运行时**被动态的加载进内存并连接
  * **一个目标文件就是一个字节序列，一个目标文件就是以一个文件形式存放在磁盘中的目标模块**
  * **ELF：在 x86-65 Linux 和 Unix 系统使用可执行可链接格式**

#### 可重定位目标文件

* ELF 文件格式是由 **ELF 头 ，节头部表和夹在中间的节组成**

#### 符号和符号表

* 每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号信息，在链接器的上下文中，有三种不同符号
  * 全局符号：由 m 模块定义并能被其他模块引用的全局符号。全局符号对应于非静态的 C 函数和全局变量
  * 外部符号：由其他模块定义并被 m 引用的全局符号称为外部符号。对应于在其他模块中定义的非静态 C 函数和全局变量
  * 局部符号：只被模块 m 定义和引用的符号。对应带 static 属性的 C 函数和全局变量，这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用
  * 链接器不包含对应本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理

* 符号表是由汇编器构造的，使用汇编器输出到汇编语言 .s 文件中的符号。 .symtab 节中包含 ELF 的符号表
* 条目格式
  * name：字符串表中的字节偏移，指向符号以 null 为结尾的字符串名字
  * type：通常要么是数据，要么是函数
  * binding：表示符号是本地的还是全局的
  * section：每个符号都被分配到目标文件的某个节，由 section 表示，该字段也是一个到节头部表的索引。有三个特殊的伪节
    * ABS：不该被重定位的符号
    * UNDEF：代表未定义的符号，在本模块中引用，但是却在其他地方定义的符号
    * COMMON：未被分配位置的未初始化的数据目标，value 字段给出对齐要求，size 字段给出的最小的大小
      * COMMON 和 .biss 区别很细微，COMMON 未初始化的全局变量  .bss 未初始化的静态变量，以及初始化为 0 的全局或静态变量
    * 只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的
  * value：距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址
  * size：目标大小（以字节为单位）

#### 重定位

* 链接器完成了符号解析之后，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来，此时链接器就知道它的输入目标模块中的代码节和数据节的确切大小，之后就可以进行重定位，重定位分为两步
  * 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节 例如：将所有输入模块的 .data 节全部合并成一个节，这个节成为输出的可执行目标文件的 .data 节
  * 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行地址，要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构

##### 重定位条目

* 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。因此无论何时汇编器遇到对最终位置未知的目标引用，都会生成一个重定位条目，告诉链接器再将目标文件合并可执行文件时如何修改这个引用。代码的重定位放在  .rel .text 中，已初始化数据的重定位条目放在 .real .data 中

* ELF 重定位条目格式
  * offset：需要被修改的引用的节偏移
  * symbol：标识被修改引用应该指向的符号
  * type：告知链接器如何修改新的引用
  * addend：是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整

### 第八章  8.1-8.5

#### 异常

* 异常就是控制流中的突变，用来响应处理器状态中的某些变化
* 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序），当异常处理程序完成处理后，根据引起异常的事件的类型，会发送以下三种情况
  * 处理程序将控制返回给当前指令，即当前事件发生时正在执行的指令
  * 处理程序将控制返回给下一条指令，如果没有异常将会执行下一条指令
  * 处理程序终止被中段的程序

##### 异常处理

* 在系统启动时（当计算机重启或这通电时），操作系统分配和初始化一张称为异常表的跳转表，使得表木 k 包含异常 k 的处理程序的地址
* 在运行时（当系统执行某个程序时），处理器检测的发送了一个事件，并且确定了相应的异常号 k，随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k 跳转到相应的处理程序的地址
* 异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基地址寄存器的特殊 CPU 处理器里，异常类似于过程调用，但有一些重要的不同之处
  * 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）
  * 处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序也会需要这些状态
  * 如果控制从用户程序转到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中
  * 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限

##### 异常的类别

异常可以分为四类

| 类别 |        原因         | 异步/同步 |       返回行为       |
| :--: | :-----------------: | :-------: | :------------------: |
| 中断 | 来自 I/O 设备的信号 |   异步    | 总是返回到下一条指令 |
| 陷阱 |     有意的异常      |   同步    | 总是返回到下一条指令 |
| 故障 |  潜在可恢复的错误   |   同步    |   可能返回当前指令   |
| 终止 |   不可恢复的错误    |   同步    |       不会返回       |

#### Linux/x86-64 系统中的异常

*  x86-64 系统定义了 256 种不同的异常类型。0 ~ 31 的号码对应的是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都是一样的。 32 ~ 255 的号码对应的是操作 系统定义的中断和陷阱

|  异常号  |        描述        |  异常类别  |
| :------: | :----------------: | :--------: |
|    0     |      除法错误      |    故障    |
|    13    |    一般保护故障    |    故障    |
|    14    |        缺页        |    故障    |
|    18    |      机器检查      |    终止    |
| 32 ~ 255 | 操作系统定义的异常 | 中断或陷阱 |

#### 进程

* 进程是一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需状态组成的。这个状态包括存放在内存中的程序代码和数据，栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合
* 进程提供给程序的关键抽象有两种
  * 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器
  * 一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统

##### 逻辑控制流

* 进程可以向每个程序提供一种假象，好像它在独占的使用处理器。如果想要调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一的对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做 逻辑控制流，简称逻辑流
  * 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。

##### 并发流

* 一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流称为并发的运行
* 多个流并发的执行一般现象被称为并发，一个进程和其他进程轮流运行的概念称为多任务，一个进程执行它的控制流的一部分的每一个时间段叫做时间片。因此多任务也叫时间分片
* 如果两个流并发的运行在不同的处理器上，称为并行流，它们并行的运行且并行的执行

##### 私有地址空间

* 进程为每个程序提供一种假象，好像它独占的使用系统地址空间，进程为每个程序提供它自己的私有空间，一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读写的。从这个意义上来说地址空间是私有的
* 每个地址空间的内容一般是不同的，但是每个这样的空间都有相同的通用结构
  * 地址空间底部是保留给用户程序的，包括通常的代码，数据，堆和栈段，代码总是从地址 0x400000 开始
  * 地址空间顶部保留给内核（操作系统常驻内存部分），地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序调执行系统调用时）使用的代码，数据和栈

##### 用户模式和内核模式

* 处理器通常使用某个控制寄存器中的模式位来提供欧这种功能的，该寄存器描述了当前进程享有的特权（用户模式/内核模式）
* 当设置了位模式时，进程运行在内核模式中，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置
* 当没有设置模式位时，进程就运行在用户模式中，用户模式中的进程不允许执行特权指令，比如停止处理器，改变模式位，或者发起一个 I/O 操作，用户程序必须通过系统调用接口间接的访问内核代码和数据

##### 上下文切换

* 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态
* 在进程执行的某些时刻，内核可以决定抢占进程，并重新开始一个先前被抢占了的进程，这种决策就叫做调度，是由内核中称为调度器的代码处理的。

#### 信号

* 信号允许进程和内核中断其他进程，一个信号就是一条小信息，它通知系统发生了一个某种类型的事件。
* 每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的
* 信号提供了一种机制，通知用户发送了哪些异常。比如，一个进程试图除以 0，内核就会发送给它一个 SIGFPE（号码 8） 信号

### 第九章9.1-9.3\9.8-9.9\9.11

* 虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它的每一个进程提供了一个大的，一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力
  * 它将主存看成是一个储存在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并且根据需要在磁盘和主存之间来回传送数据
  * 它为每个进程提供了一致的地址空间，从而简化了内存管理
  * 它保护了每个进程的地址空间不被其他进程破坏

* 虚拟内存的概念
  * 虚拟内存是内存的核心。理解虚拟内存将帮助我们更好的理解系统通常是如何工作的
  * 虚拟内存是强大的。

#### 物理和虚拟寻址

* 物理寻址：计算机系统的内存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（PA），第一个字节地址为 0，接下来的字节地址为 1，再下一个为 2
* 虚拟寻址：CPU 生成一个虚拟地址（VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将虚拟地址转成物理地址的任务叫做地址翻译。CPU 芯片上叫做内存管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理

##### DRAM  缓存组织结构

* 术语 SRAM 缓存表示位于 CPU 和主存之间的 L1，L2 和 L3 高速缓存，术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存缓存中缓存虚拟页

##### 页表

* 页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟页转换为物理地址时，都会读取页表。操作系统维护页表的内容，以及在磁盘和 DRAM 之间来回传送页
* Linux 中 getrusage 函数可以监测缺页的数量

#### 内存映射

* Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到以下两种类型的对象中的一种
  * Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件
  * 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零

##### 共享对象

* 内存映射提供了一种清晰的机制，用来控制多个进程如何共享对象

* 一个对象可以被映射到虚拟内存的区域，要么作为共享对象，要么作为虚拟对象
  * **如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，都是可见的，这些变化也会反应到磁盘的原始对象中**
  * **一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反应在磁盘的对象中**

* 一个映射到共享对象的虚拟内存叫做共享区域。类似的也有私有区域

* 私有对象使用一种叫做**写时复制**的巧妙技术被映射到虚拟内存，只要没有进程试图写自己的私有区域，它们就可以共享物理内存中对象的一个单独副本。反之，这个写操作就会触发一个保护故障
  * 当触发保护故障时，物理内存就会创建一个新的副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限

#### 动态内存分配

* 动态内存分配器在 C 中更方便，也有更好的移植性
* 动态内存分配维护着一个进程的虚拟内存区域，称为堆，对于每个进程，内核维护着一个变量 brk（读作 break），它只向堆的顶部
* 分配器将堆视为一组不同大小的块的集合来维护，每个块都是一个连续的虚拟内存片，分为两种
  * 已分配的：显式的保留准备为应用程序使用
  * 空闲的：空闲块保持空闲，知道它显式的被应用分配
  * 一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行，要么是内存分配器自身隐式执行

* 分配器有两种风格
  * 显式分配器：要求应用显式的释放任何已分配的块（ C 中的 free 或 C++ 中的 delete ）
  * 隐式分配器：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块（例如 java 的 GC）

### 第十一章 11.4

##### 套接字地址结构

* 从 Linux 内核的角度来看，一个套接字就是通信的一个端点。从 Linux 程序的角度来看，套接字就是一个有相应描述符的打开文件

```c
// 因特网套接字地址结构
struct sockaddr_in {
  uint16_t	sin_family;		// AF_INET
  uint16_t	sin_port;			// 16 位的端口号	 网络字节顺序（大端法存放）
  struct in_addr	sin_addr;	//  32 位的 IP 地址 （大端法存放）
  unsigned char	sin_zero[8];	//  struct sockaddr
}

// 通用套接字地址结构
struct sockaddr {
  uint16_t	sa_famliy;  // AF_INET
  char 			sa_data[14]	// 数据
}
```

##### socket 函数

* 客户端和服务器端使用 socket 函数来创建一个套接字描述符

```c
#include <sys/types.h>
#include <sys/socket.h>
/**
	使用方法 clientfd = socket(AN_INET, SOCK_STREAM, 0);
	AN_INET 表示我们正在使用 32 位 IP 地址
	SOCK_STREAM 表示这个套接字是连接的一个端点
	成功返回 非负描述符，出错返回 -1
*/
int socket(int domain, int type, int protocol);
```

##### connect 函数

* 客户端通过调用 connect 函数来建立和服务器的连接

```c
#include <sys/socket.h>
// connect 函数试图与套接字地址为 addr 的服务器建立连接，addrlen 是 sizeof(sockaddr_in)
// connect 函数会阻塞，一直到连接成功或失败，如果连接成功 clientfd 已经准备好可以读写
// 成功返回 0，失败返回 -1
int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
```

##### bind 函数

* bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

##### listen 函数

* listen 函数将 sockfd 从一个主动套接字转化为监听套接字，该套接字可以接受来自客户端的连接请求

```c
#include <sys/socket.h>
// backlog 要求对 TCP/IP 协议理解，通常会把它设置为一个较大的值，比如 1024
int listen(int sockfd, int backlog);
```

##### accept 函数

* 服务器通过调用 accept 函数来等待来自客户端的请求，accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个已连接的描述符，这个描述符可被用来利用 Unix I/O 函数与客户端通信

```c
#include <sys/socket.h>
// 若成功则为非负连接描述符，若出错则为 -1
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
```

##### 主机和服务转换

* getaddrinfo 函数将主机名，主机地址，服务名和端口号的字符串表示转化成套接字地址结构。是个可重入的函数，适用任何协议

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

/**
	给定 host 和 service (套接字地址的两个组成部分), getaddrinfo 返回 result
	result 指向 addrinfo 结构的链表
	每个结构指向一个对应 host 和 service 的套接字地址结构
	如果成功返回 0，如果错误返回错误代码
*/
int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);
// 为了避免内存泄漏，程序最后必须调用 freeaddrinfo 释放链表
void freeaddrinfo(struct addrinfor *result);
// 如果返回错误代码 可以调用 gai_strerror 转成消息字符串
const char *gai_strerror(int errcode):
```

* getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务器名字符串。

```c
#include <sys/socket.h>
#include <netdb.h>
/**
  sa: 指向大小为 salen 的套接字地址结构
  host: 指向大小为 hostlen 字节的缓冲区
  service: 指向大小为 servlen 字节的缓冲区
  如果成功返回 0，如果错误返回错误代码
*/
int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, 
                size_t hostlen, char *service, size_t servlen, int flags);
```

##### 套接字接口的辅助函数

* open_clientfd 和 open_listenfd 是 get nameinfo 函数和套接字接口的包装函数

```c
#include "caspp.h"
// 建立服务器连接，若成功返回描述符，若出错返回 -1
int open_clientfd(char *hostname, char *port);
// 创建一个监听描述符，准备好接受连接请求，若成功返回描述符，若出错返回 -1
int open_listenfd(char *port);
```

### 第十二章

##### 基于 I/O 多路复用的并发编程

* select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序

```c
#include <sys/select.h>
// 返回已经准备好的描述符的非零的个数，出错返回 -1
int select(int n, fd_set* fdset,NULL,NULL,NULL);

FD_ZERO(fd_set *fdset);
FD_CLR(int fd, fd_set *fdset);
FD_SET(int fd, fd_set *fdset);
FD_ISSET(int fd, fd_set *fdset);
```

##### 基于 I/O 多路复用的并发事件驱动服务器

* 状态机：就是一组状态，输入事件和转移
  * 转移：将状态和输入事件映射到状态，每个转移是将一个（输入状态，输入事件）对映射到一个输出状态。
  * 自循环：通一输入和输出状态之间的转移。

##### 基于线程的并发编程

* 线程就是运行在进程上下文中的逻辑流，每个线程都有自己的上下文，包括唯一的整数线程 ID，栈，栈指针，程序计数器，通用目的寄存器和条件码，所有运行在一个进程里的线程共享该进程的整个虚拟空间

#### 用信号量同步线程

##### 信号量

* 信号量 s 是具有非负整数值的全局变量，只有由两种特殊的操作来处理，两种操作称为 P 和 V
  * P：如果 s 是非零的，那么 P 将 s 减 1，并且立即返回。如果 s 为零，那么就挂起这个线程，直到 s 变为非零，而一个 V 操作会重启这个线程。在重启之后，P 操作将 S - 1，并将控制返回给调用者
  * V：V 操作将 S 加 1。如果有任何线程阻塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1，完成 P 操作

##### 使用信号量来实现互斥

* 在一个互斥锁上执行 P 操作称为堆互斥锁加锁，在一个互斥锁上执行 V 操作称为对出斥锁解锁，对一个互斥锁加了锁但是没有解锁称为占用这个互斥锁

##### 利用信号量来调度共享资源

* 生产者-消费者
  * 生产者线程反复的生成新的项目（item），并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这个项目，然后使用它们。也可能有多个生产者和消费者的变种

* 读者-写者
  * 读者-写者问题是互斥问题的一个概括。一组并发的线程要访问一个共性对象。

#### 其他并发问题

##### 线程安全

* 线程不安全的函数类有四种
  * 不保护共性变量的函数。
  * 保持跨越多个调用的状态的函数（static）
  * 返回指向静态变量的指针函数
  * 调用线程不安全函数的函数

##### 死锁

* 使用二元信号量来实现互斥时，可以指定规则来避免死锁
  * **给定所有互斥锁操作的一个全序，如果每个线程都是以一种顺序获得互斥梭并以相反的顺序释放，那么这个程序就是无死锁的**