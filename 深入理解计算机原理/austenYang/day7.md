##### 基本 C 数据类型的大小（字节为单位）

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-143350.png" alt="image-20200607222951225" style="zoom:50%;" />

## 2.2 整数表示

### 2.2.1 整型数据类型

**32位** 与 **64位** 机器的取值范围

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-144214.png" alt="image-20200607224157787" style="zoom:50%;" />

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-144614.png" alt="image-20200607224609142" style="zoom:50%;" />

> C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。

<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-145428.png" alt="image-20200607225419020" style="zoom:50%;" />

### 2.2.2无符号数编码

##### 二进制转无符号数

![image-20200607225709014](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-145711.png)

### 2.2.2 补码编码

最常见的有符号数的计算机表示方式就是 **补码（two's-complement）**形式。在这个定义中，将字的最高有效位解释为负权（negative weight）。

我们用 
$$
B2T_w (Binary to Two's-complement)
$$
长度为 w 来表示：

补码编码的**定义**：

对向量 $\vec{a}=[x_{w-1},x_{w-2},\cdots,x_0]$:
$$
B2T_w(\vec{x}) = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}{x_i2^i}
$$
最高有效位也 $x_{w-1}$ 也称为 **符号位**，它的 “权重” 为 $-2^{w-1}$ ,是无符号表示中权重的负数。符号位被设置为 1 时，表示负数，而当设置为 0 时，值为非负。

示例：
$$
B2T_4([0001]) = -0\cdot2^3 + 0\cdot2^2 + 0\cdot2^1+1\cdot2^0 = 0+0+0+1=1
$$

$$
B2T_4([0101]) = -0\cdot2^3 + 1\cdot2^2+0\cdot2^1+1\cdot2^0 = 0+4+0+1 = 5
$$

$$
B2T_4([1011])=-1\cdot2^3+0\cdot2^2+1\cdot2^1+1\cdot2^0 = -8 + 0+2+1 = 5
$$

**有符号 w 位**

最小值：[10000....0]：$TMin_w = -2^{w-1}$ 

最大值：[01111....1]:$TMax_w = 2^{w-1}-1$ 

**补码的唯一性**





<img src="https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-07-160327.png" alt="image-20200608000321532" style="zoom:50%;" />

$Umax_w$ 无符号最大

$TMin_w$ 有符号最小

$TMax_w$ 有符号最大

-1 和 0 

补码是有符号数的一种表示方法。

有符号数还有两种标准的表示方法：

**反码（Ones'Complement）**: 除了最高有效位的权是 $-(2^{w-1})$ 而不是 $-2^{w-1}$ ,它和补码是一样的：
$$
B2O_w(\vec{x}) = -x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i
$$
**原码（Sign-Magnitude）**:最高有效位是符号位，用来确定剩下的位应该取负权还是正权：
$$
B2S_w(\vec{x}) = (-1)^xw-1\
$$
**反汇编器**是一种将可执行程序文件转换回可读性更好的 ASCII 码形式的程序。这些文件包含许多十六进制数字，都是用典型的补码形式来表示这些值。



### 2.2.4 有符号和无符号数之间的转换

```c
short int v = -12346;
unsigned short uv = (unsigned short)v;
printf("v = %d,uv = %u\n",v,uv);

//结果：v = -12346, uv = 53190
```

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。 

```c
 unsigned u = 4294967295u;//32位 无符号数 4294967295 0xFFFFFFFF
 int tu = (int)u;
 printf("u = %u, tu = %d\n",u,tu);

//结果：u = 4294967295, tu = -1
```

对于 32 位字节长度来书，无符号形式的 4294967295（$UMax_{32}$）：

`11111111111111111111111111111111`

和 补码形式的 -1 的位表示形式是完全一样的。所以底层的位保持不变，只改变解释这些位的方式。

大多数 C 语言的实现，处理同样字长的有符号和无符号之间的相互转换的一般规则是：数值可能改变，但是为模式不变。

**自我总结**

1. 有符号 最高位 1 表示最高位为负 ，0 为正，并不是自己以前以为的算出 （w-2）位所表示的值，当最高位（w-1）位为 1 加符号边负数，为 0 不操作即为正数。
2. 有符号与无符号之间的转换，底层为模式不变，只改变这些位的解释方式。

—— P49





