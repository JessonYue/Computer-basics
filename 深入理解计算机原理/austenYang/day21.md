![image-20200621095820022](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-015821.png)

任务结构（task_struct）中的一个条目指向 mm_struct，它描述了虚拟内存的当前状态。

2. Liunx 缺页异常处理

MMU 在视图翻译某个虚拟地址 A 时，触发某个缺页。这个异常会转到内核的缺页处理程序，处理程序随后执行下面的步骤：

1. 
2.  
3.  

### 9.8 内存映射

Liunx 通过将一个虚拟内存区域与一个磁盘上的对象（object）关联起来，以初始化这个虚拟内存区域的内容，这个过程称为 **内存映射（memory mapping）**。虚拟内存可以映射到两种类型对象中的一种：

1. Linux 文件系统中的普通文件：
2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU 第一次引用这样的区域内的虚拟页面时，内核在物理内存中找到一个合适的牺牲页，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。

无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的 **交换文件（swap file）** 之间换来换去。交换文件也叫做 **交换空间（swap space）** 或者 **交换区域（swap area）**。需要注意的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。

### 9.8.1 再看共享对象

共享对象映射到每个进程的虚拟内存中，那个其中一个进程对这个共享对象的写操作，其他进程也是可见的。

### 9.8.2 在看 fork 函数

当 fork 函数被当前进程调用时，内核为新进程创见各种数据结构，并分配它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct 、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。

当 fork 进程返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制就会创建新的页面，因此，也就为每个进程保持了私有地址空间的抽象概念。

### 9.8.3 再看 execve 函数

### 9.9 动态内存分配

动态内存分配器

动态内存分配器维护着一个进程的虚拟内存区域，称为堆。

* 显示分配器（explicit allocator）
* 隐式分配器（implicit allocator）



### 9.9.1 malloc 和 free 函数

### 9.9.2 为什么使用动态内存分配

程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。

### 9.9.4 碎片

造成堆利用率很低的主要原因是一种称为 碎片的现象，

### 9.10 垃圾收集

### 9.10.1 垃圾收集器的基本知识

垃圾收集器将内存视为一张有向的 **可达图（reachability graph）** 

![image-20200621110654677](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-030657.png)

该图的节点被分成一组 **根节点（root node）** 和 一组 **堆节点（heap node）** 。每个堆节点对应于堆中的一个已分配块。有向边 p - q 意味着块 p 中的某个位置指向块 q 中的某个位置。根节点对应于这样一种不在堆中的位置，它们中包含执行堆中的指针。这些位置可以是寄存器、栈中的变量，或者是虚拟内存中读写数据区域内的全局变量。

当存在一个条从任意根节点出发并到达 p 的有向路径时，我们可以说节点 p 是可达的。在任何时刻，不可达节点对应于垃圾，是不能被应用再次使用的。垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期地回收它们。

### 9.11 C 程序中常见的与内存有关的错误

### 9.11.1 间接引用坏指针

`scanf("%d",&val)`

`scanf("%d",val)`

### 9.11.2 未初始化的内存

程序员不正确的假设向量 y 被初始化为 0。

### 9.11.3 允许栈缓冲区溢出





# 10 系统级I/O

I/O 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输出操作从 I/O 设配复制数据到主存，而输出操作从主存复制数据到 I/O 设备。

所有语言的运行时都提供执行 I/O 的较高级别的工具。

Linux 操作系统中，是通过使用由内核提供的系统级 Unix I/O 函数来实现这样较高级别的功能。大多数情况下，高级别的 I/O 函数工作良好，没有必要直接使用 Unix I/O。

* 了解 Unix I/O 将帮助你理解其他的系统概念。
* 有时候你除了使用 Unix I/O 以外别无选择。

### 10.1 Unix I/O

一个 Linux 文件就是一个 m 个字节的序列：

$B_0,B_1,....B_k,....B_{m-1}$ 

所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对应的读和写来执行。这种将设配优雅的映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式执行：

* 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做 **描述符**，它在后续所有操作中标识这个文件。内核记录了所有有关打开文件的所有信息。应用程序只需要记住这个描述符。
* Linux shell 创建的每个进程开始时都有三个打开的我文件：标准输入（描述符号为0）、标准输出（描述符号为1）和标准错误（描述符号为2）。

* 改变当前文件的位置。
* 读写文件。
* 关闭文件。当应用完成了对这个文件访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

### 10.2 文件

每个 Linux 文件都有一个类型（type）来表明它在系统中的角色：

* 普通文件（regular file）包含任意数据。应用程序常常要区分 **文本文件（text file）** 和 **二进制文件（binary file）** ，文本文件是含有 ASCII 或 Unicode 字符的普通文件；二进制文件是所有其他文件的文件。对内核而言，文本文件 和 二进制文件没有区别。
* 目录（directory）。是包含一组链接（link）的文件，其中每个链接都将一个文件名（filename）映射到一个文件，这个文件可以是另一个目录。每一个目录至少含有两个条目：”.“ 是到该目录自身的链接，以及 “..” 是到目录层次结构中的父目录（parent directory）的链接。
* 套接字（socket）。是用来与另一个进程进行跨网络通信的文件。

其他文件类型包括 **命名通道（named pipe）**、**符号链接（symbolic link）** 以及 **字符** 和 **块设备（character and block device）**。

Linux 内核将所有文件组成一个 **目录层次结构（directory hierarchy）**,由名为 / (斜杠) 的根目录确定。系统的每个文件都是根目录直接或间接的后代。

![image-20200621193928317](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-113930.png)

作为其上下文的一部分，每个进程都有一个 **当前工作目录（current working directory）** ，来确定其在目录层次结构中的当前位置。你可以用 cd 命令来修改 shell 中当前工作目录。

目录层次结构中的位置用 **路径名（pathname）** 来指定。

路径名有两种形式：

* 绝对路径名（absolute pathname）
* 相对路径名（relative pathname）

### 10.3 打开和关闭文件

![image-20200621200432864](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-120434.png)

![image-20200621200452956](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-120454.png)

![image-20200621200507190](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-120508.png)

###  10.4 读文件 和 写文件

![image-20200621220835181](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-140837.png)

`read()` 函数从描述符为 fd 的当前文件位置最多复制 n 个字节到内存 buf 。

返回 -1 表示一个错误

返回 0 表示 EOF

![image-20200621221250084](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-21-141252.png)

某些情况下，read 和 write 传送的字节比程序要求的要少。这些 **不足值（short count）**不表示有错误。出现这样的情况原因有：

* 读是遇到 EOF。read 将通过 返回不足值 0 来发出 EOF 信号。
* 从终端读文件本行
* 读和写网络套接字。如果打开的文件对应网络套接字，那么内部缓冲约束和较长的网络延迟会引起 read 和 write 返回不足值。对 **Linux 管道（pipe）** 调用 read 和 wirte 时，也有时会出现不足值，这种进程间通信机制不在我们的讨论范围之内。

### 10.5 用RIO包健壮地读写

RIO（Robust I/O,健壮的I/O）包，它会自动为你处理上面所述的 不足值。在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O。RIO 提供了两类不同的函数：

* 无缓冲的输入输出函数。
* 带缓存的输入函数。

### 10.5.1 RIO的无缓冲的输入输出函数

通过调用 `rio_readn` 和 `rio_writen` 函数，应用程序可以在内存和文件之间直接传递数据。

```

```

### 10.8 共享文件

可以用许多不同的方式来共享 Linux 文件。除非你很清楚内核是如何打开文件，否则共享文件的概念相当难懂。内核用三个相关的数据结构来表示打开的文件：

1. 描述符表（decriptor table）。每个进程都有它独立的描述符表，它的表项是由进程打开的we年描述符来索引的。每个打开的描述符表项指向 **文件表** 中的一个表项。
2. 文件表（file table）。打开文件的集合是由一张文件表来表示的，所有进程共享这张表。每个文件表的表项组成包括 **当前文件位置、引用计数（指向当前该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。**关闭一个描述符会减少相应的we年表表项中的引用计数。内核会删除这个文件表表项，直到它的引用计数为零。
3. v-node 表（v-node table）。同文件表一样，所有进程共享这张 v-node 表。每个表项包含 stat 结构中的大多信息，包括 st_mode 和 st_size 成员。

![image-20200622111856688](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-031858.png)

![image-20200622111910120](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-031911.png)

父进程是如何共享文件的？

假设在调用 fork 之前，父进程有如图 10 - 12 所示的打开文件。然后，图 10 - 14 展示了调用 fork 后的情况。

![image-20200622112632164](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-032633.png)

子进程有一个父进程的描述符表的副本。父进程共享相同的打开文件表集合，因此共享相同的文件位置。一个重要的结果是，在内核删除相应的we年表表项之前，父进程必须都关闭了它们的描述符。

### 10.9 I/O 重定向

Linux shell 提供了 I/O **重定向** 操作符，允许用户将磁盘文件和标准输出联系起来。例如，键入

`linux> ls > foo.txt`

使得 shell 加载和执行 ls 程序，将标准输出重定向到磁盘文件 foo.txt。

![image-20200622114744018](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-034745.png)

![image-20200622115025911](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-035028.png)

### 10.10 标准 I/O

C 语言定义了一组高级输入输出函数，称为 标准 I/O 库，为程序提供了 Unix I/O 的高级级别的代替。

库（libc）提供

* 打开和关闭文件函数：fopen、fclose。
* 读写字节函数： fread、fwirte。
* 读和写字符串的函数：fgets 和 fputs。
* 复杂的格式化的 I/O 函数：scanf 和 printf。

标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。每个 ANSI C 程序开头都有三个打开的流 stdin、stdout 和 stderr，分别对应于标准输入、标准输出和标准错误：

![image-20200622115853945](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-035856.png)

类型为 FILE 的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和 RIO 读缓冲区的一样：就是使得稍高开销的 Linux I/O 系统调用数量尽可能的小。

### 10.11 什么情况下？该使用那些 I/O 函数

![image-20200622120409556](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-040411.png)

1. Unix I/O 模型是在操作系统内核中实现的。
2. 较高级别的 RIO 和 标准 I/O 函数都是使用 Unix I/O 函数来实现的。
3. RIO
4. 标准 I/O

在程序开发中使用哪个函数？下面是一些基本的指导原则：

![image-20200622121259652](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-041301.png)

![image-20200622121332347](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-041334.png)

![image-20200622121343059](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-041344.png)

# 11 章 网络编程

### 11.1 客户端-服务器编程模型 C/S

每个网络应用都基于 客户端-服务器模型。采用这种模型，一个应用是由一个服务器进程和一个或多个客户端进程组成。

客户端服务器模型中的基本操作是 **事务（transaction）**。一个客户端-服务器事务由一下四步组成。

1. 当一个客户端需要服务时，它向服务器发送一个请求，发起以一个事务。
2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。
3. 服务器给客户端发送一个响应，并等待下一个请求。
4. 客户端收到响应并处理它。

![image-20200622122729307](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-042731.png)

**客户端-服务器是进程，而不是常提到的机器或主机。** 一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或不同的主机上。无论客户端和服务器是怎样映射到主机上的，客户端-服务器模式是相同的。

![image-20200622123057441](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-043058.png)

### 11.2 网络

客户端和服务器通常运行在不同的主机上，并且通过 **计算机网络** 的硬件和软件资源来通信。

对于主机而言，网络只是又一种 I/O 设备，是数据源和数据接收方。

![image-20200622123417324](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-043420.png)

一个插到 I/O 总线扩展槽的适配器提供了到网络的物理接口。从网络上接收到的数据从适配器经过 I/O 和内存总线复制到内存，通常是通过 DMA 传送。相似地，数据也能从内存复制到网络。

### 以太网协议 

数据链路层协议

![image-20200622132323534](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-052325.png)

* MAC 地址：物理设配唯一的地址
* 以太网协议：传输数据格式，通过协议是怎样进行数据传输的？

一台主机可以发生一段位（称为桢（frame））到这个网段内的其他任何主机。每个桢包括一些固定数量的头部（header）位，用来标识此桢的源和目的地址以及此桢的长度，此后紧随的就是数据为的有效载荷（payload）。

数据封装是关键传输时。

IP 点分十进制

### 11.3.2 域名

![image-20200622144447718](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-064453.png)

域名与IP的映射，开始时映射使用 HTOST.TXT 的文本文件手工维护的。现代是通过分布在世界范围内的 数据库（称为DNS（Domain Name System,域名系统））来维护的。

从概念上而言，DNS 数据库由上百万的 **主机条目结构（host entry structure）** 组成，其中每条定义了一组域名和一组 IP 地址之间的映射。

每台因特网主机都有本地定义的域名 localhost，这个域名总是映射到 回环地址 loopback address 127.0.0.1:

localhost 名字为引用运行在同一台机器上的客户端和服务器提供了一个很便利和可移植的方式，这对调试相当有用。

### 11.3.3 因特网连接

一个套接字是连接的一个端点。每个套接字都有相应的 套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用 “ 地址：端口 ” 来表示。

一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做 **套接字对（socket pair）**,有下列元组来表示：

（cliaddr:cliport,  servaddr:servport）

![image-20200622150325522](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-070327.png)

### 11.4 套接字接口

**套接字接口（socket interface）** 是一组函数，它们和 Unix I/O 函数结合起来使用，用来创建网络应用。

![image-20200622150851758](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-070853.png)

上图是：一个典型的客户端-服务器事务的上下文中的套接字接口概述。

### 11.4.1 套接字地址结构

![image-20200622164702392](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-084709.png)

套接字（socket）是抽象的概念，表示 TCP 链接的一端。

TCP 是端到端的连接，套接字就表示 TCP 的一端。

通过套接字可以进行数据的发送和接受。

![image-20200622165351867](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-085353.png)

TCP 是由两端的连接组成的，那么通过两个套接字就可以指定某个 TCP 的连接。 

![image-20200622165547083](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-085603.png)

而套接字就可以表示成 IP 和 Port 的组合，——通过两个套接字就可以确定一个TCP的连接。（这个属于 TCP 形象化的理解   ）

从 Linux 内核角度来看，一个套接字就是通向的一个端点。从 Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。

![image-20200622151509045](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-071510.png)

### 11.4.2 socket 函数

客户端 和 服务器 使用 socket 函数来创建一个 **套接字描述符（socket descriptor）**。

### 11.4.5

默认情况下，内核认为 socket 函数创建的描述符对应与 **主动套接字（active socket）**,它存在于一个连接的客户端。服务器调用 listen 函数告诉内核，描述符是被服务器而不是客户端使用。



### 11.5.2 web 内容

Web 服务器以两种不同的形式向客户端提供内容：

1. 取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为 静态内容（static content），而返回文件个客户端的过程称为 **服务静态内容（serving static content）**。
2. 运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件的输出称为 **动态内容（dynamic content）**，而运行程序并返回它的输出到客户端的过程称为 **服务动态内容（serving dynamic content）**。

每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每个都有唯一的名字，叫做 URL (Universal Resource Locator ,通用资源定位符)。例如：URL  http://www.google.com:80/index.html

表示因特网主机 www.google.com 上有一个称为 /index.html 的 HTML 文件，它是由一个监听端口 80 的web服务器管理的。端口号是可选的，默认为知名的 HTTP 端口 80。可执行文件的 URL 可以在文件名后包括程序参数。

![image-20200622203818720](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-22-123820.png)

