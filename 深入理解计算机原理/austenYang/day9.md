# 

开篇的一些疑问，带着问题看书更有动力：

1. 线程是如何共享程序数据或保持数据私有的？准确的知道如何在哪里访问共享数据？

**汇编代码**：是机器代码的文本表示。汇编代码非常接近于机器代码，与机器代码二进制相比，汇编代码的主要特征是它用可读性更好的文本格式表示。理解会被代码与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。

3.2 程序编码

`linux > gcc -og -o p pi.c p2.c` 编译选项 -og 告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化级别。

**gcc** 一整套的程序将源代码转化成可执行代码。

1. 首先 C 预处理器扩展源代码，插入所有`#include` 命令指定的文件

，并扩展所有用 `#define` 声明指定的宏。

2. 其次、编译器产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。
3. 接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
4. 最后，链接器 将两个目标代码文件与实现函数库（例如 printf）的代码合并，并产生最终的可执行文件 p (由命令行指示符 `-o p` 指定的)。

`x86-64` 的机器代码和原始 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

* 程序计数器（通常称为 “PC”，在 `x86-64` 中用 `%rip` 表示）给出将要执行的下一条指令子在内存的地址。
* 整数寄存器文件 包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 C 语言中的指针）或整数数据。有些寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数返回值。
* 条件码寄存器 保存着最近执行的算术或逻辑指令的状态信息。它用来实现控制或数据流中的条件变化，比如说用来实现 `if` 和 `while` 语句。
* 一组向量寄存器可以存放一个或多个整数或浮点数值。

操作系统负责将虚拟内存地址翻译成实际处理器内存中的物理地址。

，