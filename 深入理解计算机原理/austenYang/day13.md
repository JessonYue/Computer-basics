![image-20200613164509195](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-13-084514.png)

图7-2 概括了驱动程序在将示例才能够 ASCII 码源文件翻译成可执行目标文件时的行为 

**流程：**

驱动程序首先运行 C 预处理器（cpp）,它将 C 的源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i：

`cpp [other arguments] main.c /tmp/main.i`

接下来，驱动程序运行 C 编译器（ccl）,它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s:

`cll /tmp/main.i -Og [other argumnents] -o /tmp/main.s`

然后，驱动程序运行汇编器（as）,它将 main.s 翻译成一个 **可重定位目标文件（relocatable object file）** main.o:

`as [other arguments] -o /tmp/main.o /tmp/main.s`

驱动程序经过相同的过程生成 `sum.o`，最后，它运行连接器程序 ld，将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个 **可执行目标文件（executable object file）** prog:

`ld -o pro [system object files and args] /tmp/main.o /tmp/sum.o` 

要运行可执行文件 prog，我们再 Linux shell 的命令行上输入它的名字：

`linux> ./prog`

shell 调用操作系统中的一个 叫做 **加载器（loader）** 的函数，它可将执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

### 7.2静态链接

链接器的基本事实：目标文件纯粹是字节块集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。

### 7.3 目标文件

目标文件有三种形式：

1. 可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
2. 可执行目标文件：包含二进制代码和数据，其形式可以直接被复制到内存并执行。
3. 共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器 生成可重定位目标文件（包括共享目标文件）。

链接器生成可执行目标文件。从技术上说，一个 **目标模块（object module）** 就是一个字节序列，而一个 **目标文件（oject file）** 就是一个以文件形式存放在磁盘的目标模块。

目标文件是按照 特定的目标文件格式组织起来的，各个系统的目标文件格式都不相同。





>  一个C/C++编译的程序占用的内存分为以下几个部分：
>
> 1.  栈区：
> 2. 堆区：
> 3. 全局区（静态区）： 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放
> 4. 文字常量区：
> 5. 程序代码区：
>
> ```c
>  //main.cpp
> 
>  int a = 0; 全局初始化区
> 
>  char *p1; 全局未初始化区
> 
>  main()
> 
>  {
> 
>  int b;// 栈
> 
>  char s[] = "abc"; //栈
> 
>  char *p2; //栈
> 
>  char *p3 = "123456"; 123456\0";//在常量区，p3在栈上。
> 
>  static int c =0； //全局（静态）初始化区
> 
>  p1 = (char *)malloc(10);
> 
>  p2 = (char *)malloc(20);
> 
>  //分配得来得10和20字节的区域就在堆区。
> 
>  strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
> 
>  }
> ```



> C语言小知识：利用 `static` 属性隐藏变量和函数名字
>
> 在 C ++ 、Java 使用 `public`、`private` 表明来隐藏内部的变量和函数声明。在 C 中，源文件扮演模块的角色。任何带有 `static` 属性声明的全局变量或者函数都是模块私有的。不带 `static` 属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 `static` 属性来保护你的变量和函数是很好的编程习惯。



### 7.6.1 链接器如何解析多重定义的全局符号

根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：

* 规则1：不允许多个重名的强符号
* 规则2：如果有个一个强符号和多个弱符号，选强符号。
* 规则3：如果有多个弱符号同名，那么从这些若符号中任选泽一个。

### 7.6.2

编译系统提供一种机制，将所有相关的目标模块打成为一个单独的文件，称为 **静态库（static library）** ,它可以用做链接器的输入，当链接器构造一个输出的可执行文件时，它只是复制静态库里面被应用程序引用的目标模块。

`gcc -c main2.c`

`gcc -static -o prog2c main2.o ./libvector.a`

或者

`gcc -c main2.c`

`gcc -static -o prog2c main2.o -L. -lvector` 

链接器行为：

![image-20200614000312221](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-13-160313.png)

`-static` 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。`-lvector 参数是 libvector.a` 的缩写，`-L.` 参数告诉链接器在当前目录下查找 `libvector.a`

当链接器运行时，它判定 main2.o 引用了 addvect.o 定义的 addvec 符号，所以复制 addvec.o 到可执行文件。因为程序不引用任何由 multvec.o 定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还需要复制 libc.a 中的 printf.o 模块，以及许多 C 运行时系统中的其他模块。

### 7.6.3 链接器如何使用静态库来解析引用

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件）在这次扫描中，链接器维护一个可重定位目标文件的集合 E ,一个为解析的符号集合 U（即引用了但尚未定义的符号），以及一个前面输入文件中已定义的符号集合 D。初始时，E、U 和 D 均为空。



关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库可以以任何顺序防止到结尾处。另一个方面，如果库不是相互独立的，那么必须对它们排序，使得对于每一被存档文件的成员外引用的符号 s，在命令行中至少一个 s 的定义的在对 s 的引用之后。

### 7.7 重定位

在重定位步骤中，将合并输入模块，并为每个符号分配运行时地址。

重定位由 2 步组成：

* 重定位节和符号定义。
* 重定位节中的符号引用。

### 7.7.1 重定位条目

代码的重定位条目方法 **.rel.text** 中。

已初始化数据的重定位条目放在 **.rel.data** 中。

### 7.7.2 重定位符号引用

1. 重定位 PC 相对引用
2. 重定位 绝对 引用

### 7.8 可执行目标文件



![image-20200614005911105](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-13-165912.png)

### 7.9 加载可执行目标文件

`linux> ./prog`

shell 认为 prog 是可执行目标文件，通过调用某个驻留在存储器中称为 加载器（loder）的操作系统代码来运行它。

任何 Linux 程序都可以通过 `execve` 函数来调用 加载器。加载器 将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一个指令或入口来运行程序。这个将程序复制到内存中并运行的过程加做 **加载**。

![image-20200614010618710](/Users/austen/Library/Application Support/typora-user-images/image-20200614010618710.png)

> **加载器是如何工作的？**
>
> Linux 系统中的每个程序都运行在一个进程上线文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 `execve` 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆被初始化为 0 。通过将虚拟地址空间的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到 `_start` 地址，它最终会调用应用程序的 `main` 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。知道 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。





