# 12 并发程序

逻辑控制流在时间上叠加，那么它们就是 并发的（concurent）。这种常见的现象称为并发（concurrency）。

现代操作系统提供了三种基本的构造并发程序的方法：

* 进程。用这个方法，每个逻辑控制流都是一个进程，有内核调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显示的 **进程间通信机制（interprocess communiaction ,IPC）**

* I/O 多路复用。这种形式的并发编程中，应用程序在一个进程的上线文中显示地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显示的从一个状态转换为另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。
* 线程。线程是运行在一个单一进程上下文中的逻辑流，又内核进行调度。你可以把线程看成是上面两种方式的混合体，像进程一样由内核进行调度，而像 I/O 多路复用流一样共享一个虚拟地址空间。

### 12.1 基于进程的并发编程

例如：一个构造并发服务器的自然方法就是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新的客户端服务。

### 12.1.2 进程的优劣

对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间即是优点也是缺点。

独立的进程空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显示的 IPC 机制。基于进程的设计的另个缺点是，它们往往比较慢，应为进程控制和 IPC 的开销很高。

waitpid 、信号 、socket

Unix IPC 通常的指的是所有允许进程和同一台主机上其他进程进行通信的技术。其中包括 管道、先进先出（FIFO）、系统 V 共享内存，以及系统 V 信号量（semaphore）。

### 12.2 基于 I/O 多路复用的并发编程

基本思路是使用 `select` 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序，就像在下面的示例中一样：

​	`select` 函数处理类型为 fd_set 的集合，也叫做 **描述符集合**。逻辑上，我们将描述符集合看成一个大小为 n 的位向量。

### 12.2.2 I/O 多路复用技术的优劣



### 12.3 基于线程的并发编程

线程 就是运行在进程上下文中的逻辑流。程序都是由每个进程中的一个线程组成的。现代系统一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有自己的 **线程上线文（thread context）** ，包括一个唯一的 **整数线程ID（Thread ID,TID）**、栈、栈指针、程序计数器、通用目的寄存器和条件码，所有运行在一个进程里的线程共享该进程的整个**虚拟地址空间**。

![image-20200623122957243](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-23-043012.png)

线程执行模型

每个进程开始生命周期时都是单一线程，这个线程称为 主线程，从这个时间开始两个线程就开始并发的运行。最后，因为主线执行一个慢速系统调用，例如 read 或者 sleep ,或者因为被系统的时间间隔器中断，控制就会通过上线文切换传递到对等线程。对等线程执行一段时间，然后控制传递回主线程，以此类推。

线程执行是不同于进程的。因为一个线程的上下文要比一个进程的上下文小得多，线程上下文切换要比进程上下文切换快得多。另一个不同就是 线程不像进程那样，不是按照严格的父子层次来组织。和一个进程相关的线程组成一个对等线程池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中地址运行的线程。线程池的概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。一个对等线程都能读写相同的共享数据。

### 12.3.2 Posix 线程

Posix 线程（Pthreads）是在 C 程序中处理线程的一个标准接口。

Pthreads 定义了大约 60 个函数，它运行程序 创建、杀死、回收线程，与对等线程安全的共享数据，它可以通知对等线程系统状态的变化。 **创建线程**

```c
int pthread_create(pthread_t *tid,pthread_attr_t *attr,void *func,void *arg)

```

`pthread_create` 函数创建一个新的线程，并带着一个输入变量 arg，在新线程上下文中运行 **线程例程f**。能用 attr 参数来改变新线程的默认属性。

`pthread_self(void)` 获取线程 ID

**线程终止**

一个线程是以一下方式之一来终止的：

* 当顶层的线程例程返回时，线程会 **隐式终止**。
* 通过调用 `pthread_exit`函数，线程会 **显示终止**。如果主线程调用，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为 thread_return。

* 某个对等线程调用 Linux 的 exit 函数，该函数终止进程以及所有与该进程相关的线程。
* 另一个对等线程通过以当前线程 ID 作为参数调用 `pthread_cancel` 函数来终止当前线程。

**回收已经终止的线程资源**

`int pthread_join(pthread_t tid,void **thread_return);`

`pthread_join` 函数会阻塞，直到线程 tid 终止，将线程例程返回的通用 `(void *)`指针复制为 `thread_return` 指向位置，然后回收已经终止线程占用的所有内存资源。

**线程分离**

在任何一个时间点上，线程是 可结合（joinable）或者 分离的（detached）。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不被释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时有系统自动释放。默认情况下线程被创建是可结合的。

为了避免内存泄漏，每个可结合线程都应该要么被其他线程回收，要么通过调用 pthread_detach 函数被分离。

`int pthread_detach(pthread_t tild);`

`pthread_detach`  函数可分离可结合线程 tid。线程能通过以 `pthread_self()`为参数的 `pthread_detach` 调用来分离它们自己。

**线程初始化**

```c
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control,void(*init_routine)(void));

```

`once_control` 变量是一个全局或者静态变量，总是被初始化为 `PTHREAD_ONCE_INIT`。当你第一次用参数 once_control 调用 pthread_once 时，它调用 `init_routine`,这是一个没有输入参数，也没有返回值的函数。接下来的以 once_control 为参数的 pthread_once 调用不做任何事情。无论何时，当你需要动态初始化多个线程共享的全局变量时，`pthread_once` 函数是很有用的。

#### 12.4.2 将变量存储到内存

多线程是 C 程序中变量根据它们的类型被映射到虚拟内存：

* 全局变量
* 本地自动变量
* 本地静态变量

#### 12.4.3 共享变量

#### 12.5 用信号量同步线程

共享变量是一个十分方便，但是他们也引入了 **同步错误** 的可能性。

一个关键点：**一般而言你没有办法预测操作系统是否将为你的线程选择个正确的顺序。**

#### 12.5.2 信号量

一种经典的解决同步不执行线程问题的方法，这种方法是基于一种叫 **信号量（semaphore）**的特殊类型变量的。信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V:

* $P(s)$ :如果 s 是非零的，那么 P 将 s 减一，并且立即返回。如果 s 为零，那么就挂起这个线程，知道 s 变为非零，而一个 V 操作会重启这个线程。在重启之后， P 操作将 s 减 1，并将控制返回给调用者。
* $V(s)$： V 操作将 s 加1。如果有任何线程阻塞在 P 操作等待 s 变为非零，那么 V 操作会重启这个线程中的一个，然后该线程将 s 减 1，完成它的 P 操作。

#### 12.5.3 使用信号量来实现互斥

