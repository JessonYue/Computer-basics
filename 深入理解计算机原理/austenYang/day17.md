### 8.2.4 用户模式和内核模式

为了使操作系统提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用某个控制器中的一个 **模式位（mode bit）** 来提供这种功能的，该寄存器描述了进程当前享享有的权限。当设置了模式位时，进程就运行在 **内核模式** 中。一个运行在内核模式中的进程可以执行指令集中的任何命令，并且可以访问系统中任何内存位置。

没有设置模式位时，进程就运行在 **用户模式** 中。用户模式中的进程允许 **特权指令（privileged instruction）** ,比如停止处理器、改变模式位、或发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中的内核区的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接的访问内核代码和数据。

运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过 **中断、故障或陷入系统调用这样的异常**。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回用户模式。

> 2.6 版本的 Linux 引入 /sys 文件系统，它输出关于系统总线和设备的额外的底层信息。

### 8.2.5 上下文切换

操作系统内核使用一种称为 **上下文切换（context switch）** 的较高层形式的异常控制流来实现多任务。

内核为每个进程维护一个 **上下文（context）** 。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一下对象的值组成，这些对象包括通用的 寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的 **页表**、包含有关进程信息的 **进程表**、以及包含进程已打开文件的信息的 **文件表** 。

在进程执行的某个时刻，内核可以决定抢占当前进程，并重新打开一个先前被抢占了的进程。这种抢占策略称为 **调度（scheduling）** ，是由内核中称为 **调度器（scheduler）** 的代码处理的。在内核选择一个新的进程的时候，我们说内核调度了这个进程。在内核调度一个新的进程运行后，它就抢占了当前进程，并使用一种称为 **上线文切换** 的机制来将控制转移到新的进程，**上线文切换** 1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进行。

### 8.4 进程控制

Unix 提供了大量从 C 程序中操作系统进程的系统调用。文章这节中主要介绍 C 中的这些函数数据。

1. 获取进程 ID
2. 创建和终止进程
3. 回收子进程
4. 让进程休眠
5. 加载并运行程序
6. 利用 fork 和 execve 运行程序

- [ ] 上述进程管理操作，需要实战。

### 8.5 信号

更高级的软件形式的异常，Linux 信号。它允许进程和内核中断其他进程。一个信号就是一个小消息，它通知进程系统中发生了一个某种类型的事件。每种信号类型都对应于某种系统事件。底层的硬件异常是由内核异常处理的，正常情况下，对于用户进程而言是不可见的。信号提供一种机制，通知用户进程发生了这些异常。



