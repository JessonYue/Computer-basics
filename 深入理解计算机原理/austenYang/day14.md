### 7.10 动态链接共享库

**共享库** 是致力于解决解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意内存地址，并和一个内存中的程序链接起来。这个过程称为 **动态链接（dynamic linking）** ,是由一个叫做 **动态链接器（dynamic linker）** 的程序来执行的。共享库也称为 **共享目标（shared object）** ，在 Linux 系统中通常用 **.so** 后缀来表示。 微软操作系统大量使用了共享库，它们称为 DDL(动态链接库)。

共享库是以两种不同形式 “共享” 的。

1. 首先，在任何操作系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被赋值和嵌入到引用它们的可执行文件中。

2. 其次，内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。



构造动态库示例：

`linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c` 

`-fpic` 指示编译器生成与位置无关的代码

`-shared` 指示链接器创建一个共享的目标文件



![image-20200614233210672](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-14-153214.png)

### 7.12 位置无关代码

共享库的一个主要的目的就是允许多个正在运行的进程共享内存中相同的库代码，所以会节约内存资源。

多个进程是怎么共享一个副本的呢？

方法1. 给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。

缺点：虽然这个方法简单，但是也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程也不使用这个库，那部分空间还是会被分配出来。它也难以管理，我们必须保证没有片重叠。每一次当一个库修改后，我们必须确认已分配给它的片是否还适合它的大小。如果不适合就必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的，未使用而又不再能使用的小洞。更糟糕的是对于系统而言，库在内存中的分配都是不同的，这就引起了更多令人头疼的管理问题。

方法2: **位置无关代码（Position-Independent Code ,PIC）** ,对 GCC 使用 `-fpic` 指示 GUN 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。

- [ ] 具体的 PIC 原理暂时还不能理解

### 7.13 库打桩机

**打桩库（Library interpositioning）** ，它允许你截获对库函数的调用，取而执行自己的代码。

比如可以实现：追踪某个函数的调用次数，验证和追踪它的输入和输出值，或者把它替换成一个完全不同的实现。

基本思想：给定一个需要打桩的 **目标函数** ，创建一个 **包装函数** ，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。

**打桩可以发生在编译时、链接时或者当程序被加载和执行时。**

### 7.14 处理目标文件的工具

![image-20200615065828563](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-14-225830.png)

