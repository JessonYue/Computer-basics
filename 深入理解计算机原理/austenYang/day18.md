



理解 Linux 信号是什么？

因为 底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程是不可见的。Linux 信号便提供了一种机制，通知用户进程发生了这些异常。

**1. 进程组**

每个进程都属于一个进程组，进程组是由一个正整数 **进程组ID** 来表示的。

默认地，一个进程和它的父进程同属于一个进程组。一个进程可以通过使用 `setpgid` 函数来改变自己或者其他进程的进程组。

**2.用/bin/kill 程序发送信号** 

`/bin/kill` 程序可以向另外的进程发生任意的信息。**一个负的 PID 会导致信号被发送到进程组 PID 中的每个进程。** 

**3. 从键盘发送信号**

- [ ] 后面发送信号的种类整理

### 8.5.3 接受信号

当内核把进程 P 从内核模式切换到用户模式（例如，从系统调用返回或完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合（pending & ~blocked）。如果这个结合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一个指令 $I_{next}$ 。然而，如果集合是非空的，那么内核选择集合中的某个信号 k（通常是最小的 k），并且强制 p 接受信号 k。收到这个信号会触发进程采取某种行为。一但进程完成了这个行为，那么控制就传递回 p 的逻辑控制流的下一条指令 $I_{next}$ 。每个信号都有一个预定的 默认行为。你可以通过 C 函数对信息的默认行为进行改变。但一些特殊的信号是不能修改的。

### 8.5.4 阻塞和解除阻塞信号

Linux 提供阻塞信号的隐式和显示的机制：

**隐式阻塞机制**：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。

**显示阻塞机制**：应用程序可以使用 `sigprocmask`函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

### 8.5.5 编写信号处理程序

信号处理是 Linux 系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析：

1. 处理程序与主程序并发运行，共享同样全局变量，因此可能与主程序和其他处理程序互相干扰；
2. 如何以及何时接受信号的规则常常有违人直觉
3. 不同系统有不同的信号处理语义

下面介绍编写安全、正确和可移植的信号处理程序的一些基本规则。

1. 安全的信号处理
2. 正确的信号处理
3. 可移植的信号处理

- [ ] 细读且实战

### 8.5.6 同步流以避免讨厌的并发错误

如何编写 读写相同储存位置的并发流程序的问题，困扰着数代计算机科学家。一般而言，流可能交错的数量与指令的数量呈指数关系。这些交错中的一些会产生正确的结果，而有些则不会。基本问题是以某种方式同步并发流，从而得到最大的可能的交错的集合，每个可行的交错都能得到正确的结果。

- [ ] 细读且实战

### 8.5.7 显示的等待信号

有时候主程序需要显示地等待某个信号处理程序运行。例如，当 Linux shell 创建一个前台作业，在接受下一条用户命令之前，它必须等待作业终止，被 SIGCHLD 处理程序回收。

- [ ] 细读且实战

### 8.6 非本地跳转

C 语言提供一种用户级别 异常控制流形式，称为 **非本地跳转（nonlocal jump）** ，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。 

> C++ 和 Java 中的软件是较高层次的，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。你可以把 try 语句中的 catch 句看做是类似于 setjmp 函数。相似地，throw 语句就类似于 longjmp 函数。

### 8.7 操作进程的工具

Linux 提供了大量监控和操作进程的有用的工具。

![image-20200618073939337](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-17-233941.png)

### 8.8 小结

异常控制流（ECF）发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。

在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。

有四种不同类型的异常：中断、故障、终止和陷阱。当一个外部 I/O 设备设置了处理器芯片上的中断管脚时，（对于任何指令）中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的执行可能会导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止程序从不将控制返回给中断的流。最后，陷阱就像是用来实现应用提供到操作系统代码的受控的入口点的系统调用的函数调用。

# 9 虚拟内存

一个系统中的进程是与其他进程共享 CPU 和主存资源的。

现代操作系统提供了对主存的抽象概念，叫做 **虚拟内存**

虚拟内存提供三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传递数据，通过这种方式，它高效地使用了主存。
2. 它为每一个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

### 9.1 物理和虚拟寻址

计算机系统的主内存被组织成一个由 M 个连续的字节大小的数组构成。每个字节都有唯一的物理地址（Physical Address,PA）。地址从 0 开始依次类推。CPU 访问内存的最自然的方式就是使用物理地址。我们把这种方式成为**物理寻址（physical addressing） **。



![image-20200619000646286](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-18-160655.png)

上图示例中是物理寻址的示例，该示例的上下文是一条加载指令，它读取从物理地址 4 处开始的 4 个字节。当 CPU 执行这条加载指令时，它会返回一个有效的物理地址，通过内存总线，把它传递给主存。主存取出从物理地址 4 处开始的 4 个字节，并将它返回给 CPU，CPU 会将它存放在一个寄存器里。

现代计算机使用一种称为 **虚拟寻址（virtual addressing）** 的寻址形式，如下图：

![image-20200619001518123](https://note-austen-1256667106.cos.ap-beijing.myqcloud.com/2020-06-18-161520.png)

使用虚拟寻址，CPU 通过生成一个 **虚拟地址（Virtual Address,VA）** 来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做 **地址翻译（address translation）** 。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做 **内存管理单元（Memory Management Unit,MMU）** 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表由操作系统管理。

### 9.2 地址空间

**地址空间（address space）** 是一个非负整数地址的有序集合：

**{0,1,2,3 ......}**

如果地址空间中的整数是连续的，那么我们说它是一个 **线性地址空间（linear address）**。

在一个带虚拟内存的系统中，CPU 从一个有 $N=2^n$ 个地址的地址空间中生成虚拟地址，这个地址空间称为 **虚拟地址空间（virtaul address space）** :

**{0,1,2,3 ......, N - 1}**

一个地址空间的大小是又表示最大地址所需要的位数来描述的。例如，一个包含 $N = 2^n$ 个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32 位或 64 位虚拟地址空间。

一个系统还有一个 **物理地址空间（physical address space）** ，对应系统中物理内存 M 个字节：

**{0,1,2 ...... M - 1}**

M 不要就是 2 的幂，但是为了简化，我们假设 $M=2^m$ 。

地址空间的概念很重要，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。

### 9.3 虚拟内存作为缓存的工具

VM 系统通过将虚拟内存分割为 称为 **虚拟页（Virtual Page,VP）**的大小固定的块来处理问题。每个虚拟页的大小为 $P = 2^p$ 字节。

类似地，物理内存被分割为 **物理页（Physical Page,PP）** ，大小为 P字节（物理页也被称为页桢（page frame））。





