---
title: 《深入理解计算机系统》读书笔记
date: 2020-06-11 20:40:00
tags:
	- 深入理解计算机系统
	- 读书笔记

categories: 
	- 读书笔记
description: 《深入理解计算机系统》读书笔记
cover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591889310669&di=be6eb09cee916539f259689f061f7862&imgtype=0&src=http%3A%2F%2Fimg14.360buyimg.com%2Fn0%2Fjfs%2Ft9730%2F40%2F847174291%2F365589%2F2c1c4949%2F59d88418N7ab46c0e.jpg
---


# 《深入理解计算机系统》读书笔记





## 第七章：链接



本章主要内容概括如下：

> 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time)也就是在程序被加载器（loader)加载到内存并执行时；甚至执行于运行时（runtime)，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker)的程序自动执行的。
>
> 这一章提供了关于链接各方面的全面讨论，从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。我们将使用实际示例来描述基本的机制，而且指出链接问题在哪些情况中会影响程序的性能和正确性。为了使描述具体和便于理解，我们的讨论是基于这样的环境：一个运行Linux的x86-64系统，使用标准的ELF-64(此后称为ELF)目标文件格式。不过，无论是什么样的操作系统、ISA或者目标文件格式，基本的链接概念是通用的，认识到这一点是很重要的。细节可能不尽相同，但是概念是相同的。



### 编译器驱动程序工作流程

.c文件是如何最终成为完全链接的**可执行目标文件**的，以下是编译器驱动程序(compiler drive)的工作流程，涉及到了**语言预处理器**、**编译器**、**汇编器**和**链接器**。一般的话只要输入一个指令就可以帮我们完成下图的所有操作，该指令是：

```
linux> gcc -Og prog main.c sum.c
```

![静态链接](assets/1592209311039.png)

接下来分解这整个过程：

1. c-->i

   指令：cpp [other arguments] main.c /tmp/main.i

   执行者：C预处理器（cpp）

   目的：将C的源程序main.c翻译成一个ASCII码的中间文件main.i

2. i-->s

   指令：ccl /tmp/main.i -Og [otherarguments] -o /tmp/main.s

   执行者：C编译器（ccl）

   目的：它将main.i翻译成一个ASCII汇编语言文件main.s

3. s-->o

   指令：as [other arguments] -o /tmp/main.o /tmp/main.s

   执行者：驱动程序运行汇编器（as)

   目的：它将main.s翻译成一个**可重定位目标文件**（relocatable object file) main.o

4. o-->可执行目标文件

   指令：Id -o prog[system object files and args] /tmp/main.o /tmp/sum.o
   执行者：链接器程序（ld）
   目的：将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件

5. 执行

   指令：linux>./prog
   目的：运行可执行文件prog，shell调用操作系统中一个叫做加载器（loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头


 

### 链接器必须完成两个主要任务

1. 符号解析
2. 重定位

### 目标文件有三种

1. 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。

2. 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。

3. 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

> 从贝尔实验室诞生的第一个Unix系统使用的是a.out格式（直到今天，可执行文件仍然称为a.out文件）。Windows使用可移植可执行（Portable Executable,PE)格式。MacOS-X使用Mach-0格式。现代x86-64 Linux和Unix系统使用可执行可链接格式（Executable and Linkable Format,ELF）。尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。





### ELF（可重定位目标文件）

![ELF可重定位目标文件](assets/1592212913588.png)

- ELF头:  16字节序列,描述生成该文件的系统的字的大小和字节顺序
- .text: 已编译程序的机器代码。
- .todat_a: 只读数据，比如`printf`语句中的格式串和开关语句的跳转表。
- .data: 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在.data 节中，也不出现在 .bss 节中
- .bss: 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0

- .symtab: —个**符号表**，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。 然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。
- .rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
- .rel.data: 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .line: 原始 C 源程序中的行号和.text 节中机器指令之间的映射。只有以-g 选项调用编译器驱动程序时，才会得到这张表。
- .strtab: —个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的令名字。字符串表就是以 null 结尾的字符串的序列。



### 符号表

符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 节中包含 ELF 符号表 。

.symtab 中的 符号表 不包含对应 于本地 非静态 程序变 量的任 何符号 。 这些符 号在运 行时在 栈中被 管理， 链接器 对此类符 号不感 兴趣。

