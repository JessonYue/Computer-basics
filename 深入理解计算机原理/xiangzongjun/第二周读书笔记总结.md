##### 						第二周读书笔记总结



#### 一、程序的机器级表示

#####   1、机器级代码

- 程序计数器（通常称为PC，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含16个命名的位置，分别储存64位的值。这些寄存器可以储存地址（对应c语言的指针）或整数数据。有的寄存器被分别用来记录某些重要的程序状态，而其他的寄存器保存临时数据，例如过程中的参数、局部变量以及函数的返回值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。他们用来实现控制或数据流中的条件变化，比如用来实现while、if语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

  一条机器指令只执行一个非常基本的操作。比如讲存放在寄存器中的两个数字相加，在储存器和寄存器之间传送数据，或条件分支转移到新的指令地址。

##### 	2、数据格式	![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqlsrvt1kj319i0egwra.jpg)

​	大多数gcc生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有4个变种：movb(传送字节)、movw(传送字)、mov1(传送双字)、movq(传送4字)

##### 	3、访问信息

​	一个x86-64的中央处理单元（CPU）包含一组16个储存64值得通用目的寄存器。这些寄存器用来存储整数数据和指针。

![image-20200613134650906](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqm3kk4ymj30wj0u0hdt.jpg)

##### 	4、算术和逻辑操作

​	![image-20200613135522224](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqmcfcft5j31fx0u04os.jpg)

​	特殊的算术操作

​	![image-20200613135833013](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqmfqnw0yj318s0hkasr.jpg)

##### 	5、条件码

​	除了整数寄存器，CPU还维护着一组单个位的条件码寄存器，他们描述着最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。

​	CF：进位标识，最近的操作使最高位产生了进位。可以用来检测无符号操作的溢出。

​	ZF：零标识，最近的操作得出的结果为0.

​	SF：符号标识，最近的操作得到的结果为负数。

​	OF：溢出标识，最近的操作导致一个补码溢出，正溢出或者负溢出。

​	比如说，我们用一条ADD指令完成等价于C表达式t = a+b的功能，这里变量a,b,t都是整型的。然后根据下面的C表达式来设置条件码：

​	CF			(unsigned)t < (unsigned)a			无符号溢出

​	ZF			(t == 0)											  零

​	SF			(t < 0)												负数

​	OF			(a<0 == b<0)&&(t<0 != a<0)		  有符号溢出



​	访问条件码

​	条件码通常不会直接读取，常用的使用方法有3种：

​	1、根据条件码的某种组合，将一个字节设置为0或者1。

​	2、可以条件跳转到程序的某个其他部分。

​	3、可以有条件的传送数据。



##### 	6、数组分配和访问

​	指针运算：C寓言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。

![image-20200613142814226](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnamspudj31f60qchdt.jpg)

​	理解指针：指针是C语言的核心特色，它们以一种统一方式，对不同数据结构中的元素产生引用。

- 每个指针都对应一个类型，这个类型表明指针指向的是哪一类对象。                                   ![image-20200613143734256](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnkc3ai2j31bm0dgqmn.jpg)

- 每个指针都有一个值。这个值是某个指定类型的对象的地址，特殊的值（NULL、0）表示该指针没有指向任何地方。

- 指针用&运算符创建

- *操作符用于间接引用指针。其结果是一个值，它的类型与指针的类型一致。间接引用使用内存引用来实现的，要么储存到一个指定的地址，要么从一个指定的地址取出。

- 数组与指针密切相关。一个数组的名字可以像一个指针变量一样引用（但不能修改）。数组引用与指针运算或间接引用有一样的效果。

- 将指针从一种类型强制转换成另一种类型，只需要改变它的类型，不改变它的值。强制类型的转换是一个指针类型的收缩。例如，如果P是一个char *类型的指针，它的值为P，那么表达式(int *)p+7计算为p+28,而(int *)(p+7)计算为p+7。

- 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这写引用可以被程序的其他某个部分调用，例如：![image-20200613145125741](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnyrbax3j31660gkdri.jpg)

  ##### 7、浮点代码

  处理器的浮点体系结构包括很多方面，会印象对浮点数据操作的程序如何被映射到机器上，包括：

  1、如何存储和访问浮点数值。通常是通过某种寄存器来完成。

  2、对浮点数据操作的指令。

  3、向函数传递浮点数参数和从函数返回浮点数结果的规则。

  4、函数调用过程中保存寄存器的规则----例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。



##### 		本章小结

​		本章大多数都与汇编有关，只看了一些基本指令，但是实际操作怎么运行的还是有很多看不懂的地方。



#### 二、处理器体系结构

##### 		1、Y86-64指令集体系结构

​		定义一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编码规范和异常事件处理。

​		Y86-64指令：Y86-64指令集基本上是x86-64指令集的一个子集。它只包括8字节整数操作，寻址方式较少，操作也较少。因为我们只有8个字节数据，所以称之为”字“不会有任何歧义。

​		Y86-64指令的一些细节：

- X86-64的movq指令分成了4个不同的指令：irmovq、rrmovq、mrmovq和rmmovq，分别显示的指明源和目的的格式。源可以是立即数(i)、寄存器(r)或内存(m)。

- 有4个整数操作指令，如下图中的opq，它们是addq,subq,andq,xorq。它们只对寄存器数据进行操作，而x86-64还允许对内存数据进行这些操作。这些指令会设置3个条件码ZF、SF、OF（零、符号、溢出）。

- 7个跳转指令（如下图中的jxx）是jmp、j1e、j1、je、jne、jge和jg。根据分支指令的类型和条件代码的设置来选择分支。

- 有6个条件传送指令（如下图中cmovxx）：cmovle、cmovl、cmove、cmovne、cmovge和cmovg。这些指令格式于寄存器--寄存器传送指令rrmovq一样,但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。

- call指令将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。

- pushq和popq指令实现了入栈和出栈，就像在x86-64中一样。

- halt指令停止指令的执行。x86-64中有一个与之相当的指令hlt。x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂时停止运行。对于Y86-64来说，执行halt指令会导致处理器停止，并将状态码设置为HLT![image-20200613154507481](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqpimvbbqj31660q4kec.jpg)

  指令编码

  ![image-20200613154658859](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqpkk4l9vj31740o6tsi.jpg)



##### 	2、逻辑设计和硬件控制语言HLC

​	逻辑门：逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值得某个布尔函数。![image-20200613155554538](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqptunc0lj30kc094ae9.jpg)

​	储存器和时钟

​	组合电路从本质上讲它们不存储任何信息。相反，他们只是简单的响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号决定什么时候要把新的值加载到设备中来，考虑两类存储器设备：

- 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。
- 随机访问存储器（简称内存）存储多个字，用地址来选择该读或改写哪个字。随机储存器的例子包括：1、处理器的虚拟内存系统，硬件和软件操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字。2、寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86-64处理器中寄存器文件有15个寄存器（%rax-%r14）![image-20200613160705054](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqq5hmaaaj31690u0u0t.jpg)

![image-20200613160725719](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqq5u3iinj310a0amn1r.jpg)

##### 	3、Y86-64的顺序实现

​	将处理组织成阶段：通常处理一条指令包括很多操作。将他们组成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理处决于正在执行的指令。创建这样的一个框架，我们就能够设计一个充分利用硬件的处理器。

- 取指（fetch）：取指阶段内存中读取指令字节，地址为程序计数器的值。

- 译码（decode）：译码阶段从寄存器指示符字节指示一个或两个寄存器操作数指示符ra、rb，它还可能取出一个四字节常数valc。

- 执行（execute）：在执行阶段，算术/逻辑单元（ALU）要么执行指令知名的操作，计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为valE。

- 访存(memory）：访存阶段可以将数据写入内存，或者从内存读取数据。读出的值为valM。

- 写回（write back）：写回阶段最多可以写两个结果到寄存器文件。

- 更新PC（PC update）：将PC设置成下一条指令的地址。

  处理器无限循环，执行这些阶段。在我们简化的实现制，发现任何异常时，处理器就会停止：它执行halt命令或非法指令，或它试图或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型绝顶的特殊代码。

##### 4、流水线的通用原则

​	流水线化的一个重要特性就是提高了系统的吞吐量，也就是单位时间内服务的顾客总数，不过它也会轻微的增加延迟，也就是服务一个用户所需要的时间。

​	计算流水线：下图给出了一个简单的非流水线化的硬件系统例子。它是由一些执行计算的逻辑以及保存计算结果的寄存器组成的。时钟信号控制在每个特定的时间间隔加载寄存器。CD播放器中的译码器就是这样的一个系统。输入信号是从CD表面读出的位，逻辑电路对这些位进行译码，产生音频信号。![image-20200613163025897](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqqtrp8skj30zm0lkws7.jpg)

​	在现代逻辑设计中，电路延迟以微微秒或皮秒（picosecond简写ps），也就是10^-12秒为单位来计算。在这里例子中我们假设组合逻辑需要300ps，而加载寄存器需要20ps，上图还给出一种时序图，成为流水线图。在途中时间从左向右流动，从上到下写着一组操作（I1、I2、I3），实心的长方形表示这些指令执行的时间，这个现实中，从开始下一条指令之前必须完成前一个。因此这些方框在垂直方向上并没有互相重叠。下面这个公式给出了运行这个系统的最大吞吐量

![image-20200613163647303](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqr0coxn1j317y0te1kx.jpg)

##### 本章小结

主要讲了处理器的指令体系以及一些概念操作，大致了解工作流程，只有大致印象没有深入理解。



#### 三、优化程序性能

##### 	1、提高并行性

​		多个累计变量：对于一个可结合和可交换的合并运算来说，比如整数加法或者乘法，我们可通过将一组合并运算分割成两个或者更多部分，并在最后合并结果来提高性能。如下图所示：它使用了两次循环展开，以使每次迭代合并更多的元素，也使用了两路并行，将索引值为偶数的元素累积在变量acc0中，将索引值为奇数的元素累积在变量acc1中。因此我们将其称为2X2循环展开。同前面一样，我们还包括了第二个循环，对于向量长度不为2的倍数时，这个循环要累积所有剩下的数组元素。然后我们对acc0和acc1应用合并运算，计算最终的结果。	

​	![image-20200613172428249](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqsdz2k0uj30mm0syapr.jpg)

比较只做循环展开和即作循环展开也使用两路并行这两种方法，我们得到下面的性能

![image-20200613172600216](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqsfk25r1j312i09yjy8.jpg)



​	重新结合变换:下图中给出了一个combine7函数，他与combine5的展开代码唯一的区别在于内循环中元素合并的方式。在combine5中合并是以下面这条语句来实现的。

acc = (acc OP data[i]) OP data[i+1];

而在combine7中，合并是以这条语句来实现的。

acc = acc OP (data[i] OP data[i+1]);

差别仅在于两个括号是如何放置的。我们称之为重新结合变换，因为括号改变了向量元素与累积值acc的合并顺序，产生了我们称为”2X1a“的循环展开形式。

![image-20200613174939693](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt45zmkjj30qw0n4alb.jpg)

![image-20200613175048727](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt5dne6ij30ui0p2qg6.jpg)

对于未经训练的人来说，这两个语句看上去本质是一样的，但是当我们测量CPE的时候，得到的结果令人吃惊

![image-20200613175413362](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt8wx93wj31ay0de7ex.jpg)

整数加的性能几乎与使用K X 1展开的版本（combine5）相同，而其他三种情况则与使用并行累积变量的版本（combine6）相同，是K X 1扩展性能的2倍。这些情况已经突破了延迟界限造成的限制。

##### 2、优化合并代码的结果小结

我们极大化对向量元素加或者乘的函数性能的努力获得了成功。下表总结了对于标量代码所获得的结果，没有使用AVX向量指令提供的向量并行性：

![image-20200613180647195](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqtlzgpwbj31060aidok.jpg)

使用多项优化技术，我们获得的CPE已经接近于0.50和1.00的吞吐量界限，只受限于功能单元的容量。与原始代码相比提升了10-20倍，且使用普通的代码和标准的C编译器就获得了所有这些改进。重写代码利用较新的SIMD指令得到了将近4-8倍的性能提升。比如单精度乘法，CPE初值从11.14降到了0.06，整体性能提升了超过180倍。这个例子说明了现代处理器具备有相当的计算能力，但是我们可能需要按非常程式化的方法来编写程序以便将这些能力诱发出来。

##### 3、一些限制因素

​	**寄存器溢出**：循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度P超过了可用的寄存器数量，那么编译器会诉诸溢出，将某些临时值放到内存当中。通常是在运行时堆栈上分配空间。例如将combine6的多累积变量模式扩展到K=10和K=20，其结果的比较如下图所示：![image-20200613181753524](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqtxjw773j31920u04qp.jpg)

累积变量保存为栈上的一个局部变量，其位置距离栈指针偏移量为40.程序必须从内存中读取两个数值，累积变量的值和data[i]的值，将两者相乘后，将结果保存回内存。

一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失，幸运的是x86-64有足够多的寄存器，大多数循环在出现寄存器溢出之前就将到达吞吐量的限制。

**分支预测错误和预测错误处罚**

​	当分支预测逻辑不能正确预测一个分支是否要跳转的时候，条件分支可能会招致很大的预测错误处罚。

​	对于参考机来说，预测错误处罚是19个时钟周期。赌注很高，下面的通用原则可以用。

​	**1、不要过分关心可预测的分支**

​		  我们可以看到错误的分支预测影响可能非常大，但是这并不意味着所有的程序分支后悔减缓程序的执行。实际上，现代处理器中的分支预测逻辑非常善于辨别不同的分支指令的有规律的模式和长期的趋势。

​	**2、书写适合用条件传送的代码**	

​		分支预测只对有规律的模式可行，程序中的许多测试是完全不可预测的，依赖于数据的任意特性，例如一个数是整数还是负数。对于这些测试，分支预测逻辑会处理的很糟糕。对于本质上无法预测的情况如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大提高程序的性能。这不是C语言程序员可以直接控制的，但是有些表达条件行为的方法能够更直接的被翻译成条件传送，而不是其他操作。

##### 本章小结

本章性能优化只认真读了9、10、11三个小节，其余小节快速阅览。主要讲了性能优化，自我理解好像和算法差不多的意思，其中提供并行性和优化合并代码的方式自我理解就是比如一个循环能拆成几个步骤去做，尽量减少循环的次数，最后得到结果，提高程序的效率。



#### 四、存储器层次结构

##### 	1、存储技术

​	随机访问存储器：分为两类静态的（SRAM）和动态的(DRAM)，静态的要比动态的快很多，但也贵得多。SRAM作为高速缓存存储器，既可以在CPU芯片上，也可以在芯片下。

​	下图总结了SRAM和DRAM存储器的特性，只要有供电，SRAM就会保持不变。与DRAM不同，它不需要刷新。SRAM存储比DRAM快，SRAM对诸如光和电噪声这样的干扰不敏感。代价是SRAM比DRAM使用更多的晶体管，因为密集度低，而且贵，功耗更大。![image-20200613194121502](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwcei738j317207c46n.jpg)	访问主存：数据流通称为总线的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务。读事务从主存传送数据到CPU，写事务从CPU传送数据到主存。![image-20200613194914285](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwklju32j30yg0eqahn.jpg)

磁盘存储：磁盘是由盘片构成。每个盘片有两面或者称为表面，表面覆盖者磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟。磁盘通常包含一个或多个这样的盘片并封装在一个密封的容器内。![image-20200613195343835](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwp9owcwj318s0iktpx.jpg)

访问磁盘：CPU使用一种称为内存映射I/O的技术来向I/O设备发射命令，在使用内存映射I/O的系统中，地址空间中有一块地址是为与I/O设备通信保留的。每个这样的地址称为一个I/O端口。当一个设备链接到总线时，它与一个或多个端口相关联。![image-20200613200058129](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwwsw5d0j30yp0u0ngq.jpg)

##### 	2、局部性

​	一个编写良好的计算机程序常常具有良好的局部性。也就是它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项的本身。这种倾向性被称为局部性原理，吃一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。

​	局部性的两种形式：时间局部性和空间局部性。

​	局部性的简单原则：

- 重复引用相同变量的程序有良好的时间局部性。
- 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为l的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序的空间局部性会很差。
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。



##### 	3、存储器层次结构

- 存储技术：不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高，而且容量较小。CPU和主存的速度差距在增大。

- 计算机软件：一个编写良好的程序倾向于展示出良好的局部性。

  下图是一个典型的存储器层次结构，一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。![image-20200613202115215](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxhwt7mjj319c0rub0o.jpg)

现代系统中导出都使用到了缓存

![image-20200613203010141](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxr6oeuhj319k0nw4qp.jpg)

##### 4、高速缓存存储器

​	早期计算机系统的存储层次结构只有三层：CPU寄存器、DRAM主存储器和磁盘存储。不过由于CPU和主存之间逐渐增大的差距，系统设计者被迫在CPU和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存（一级缓存），L1高速缓存的访问速度几乎和CPU寄存器一样快，典型的是大约4个时钟周期。

![image-20200613203511608](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxwef85kj310e0fstkq.jpg)

高速缓存的基本参数

![image-20200613203628007](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxxq7a0lj310w0nqtsn.jpg)

高速缓存的性能影响：有许多指标来衡量高速缓存的性能

- 不明中率。在一个程序执行或程序的一部分执行期间，内存引用不明中的比率。它是这样计算的：不命中数量/引用数量
- 命中率。命中的内存引用比率。它等于1-不命中比率
- 命中时间。从高速缓存传送一个字到CPU的时间包括组选择、行确认和字选择的时间。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。
- 不命中处罚。由于不命中所需要的额外的时间。L1不命中需要从L2得到服务的处罚，通常是数十个周期，从L3得到服务的处罚是50个周期。从主存得到服务的处罚是200个周期。

##### 5、编写高速缓存友好的代码

​	1、让最常见的情况运行的快。程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间花在了少量的循环上。所以要把注意力集中在核心函数里的循环上，而忽略其他部分。

​	2、尽量减少每个循环内部的缓存不命中数量。在其他条件相同的情况下，不命中率较低的循环运行的更快。

```c
int sumvec(int v[N]){
  int i,sum = 0;
  for(i = 0 ; i < N; i++)
  {
    sum += v[]i
  }
  return sum;
}
```

现在考虑一下对向量v的步长为1的引用。一般而言，如果一个高速缓存的块大小为B字节，那么一个步长为k的引用模式平均每次循环迭代会有min(1,(wordsize*k)/B)次缓存不命中，当K=1，它取最小值。所以对V的步长为1的引用确实是高速缓存是有好的。例如，假设V是块对齐的，字为4个字节，高速缓存块为4个字，而高速缓存初始为空（冷高速缓存）。然后无论是什么样的高速缓存结构，对V的引用都会得到下面的命中和不命中模式:![image-20200613210456910](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqyrdnpbjj311m03ugp4.jpg)

在这个例子中对v[0]的引用不会命中，而相应的包含v[0]-v[3]的块会被从内存加载到高速缓存中，因此接下来3个引用都会命中。对v[4]的引用会导致不命中，而一个新的块被加载到高速缓存中，接下来的三个引用都会命中，以此类推，总的来说，4个引用中，3个会命中，在这种冷缓存的情况下，这是我们能做到的最好的情况了。

##### 本章小结

了解了计算机的存储技术以及存储结构层次。最高层访问的速度越快但是花费更快空间也越小。以及文中说的惩罚时间通过理解：如从L1读取的时间和L2读取的时间之差即为惩罚时间，应该就是访问读取的时间增加了，而不是真的惩罚了。明白了代码优化对程序的影响，高质量的代码能很大程度决定程序的快慢与好坏。

欠缺：没有很认真的去看去算这些公式，只对概念性的东西看了一遍，能大概理解。

