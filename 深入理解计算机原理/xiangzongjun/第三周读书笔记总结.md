### 							第三周读书笔记总结



#### 第七章链接

**概念**：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。链接可执行于编译时，也就是源代码被翻译成机器代码时;也可执行于加载时，也就是程序被加载器加载到内存并执行；甚至执行于运行时，也就是由应用程序来执行。

**作用**：理解链接将帮助你构造大型程序；理解链接将帮助你避免一些危险的编程错误；理解链接将帮助你理解语言的作用域规则是如何实现的；理解链接将帮助你理解其他的重要系统概念；理解链接将使你能够利用共享库。



大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器、链接器。下图表示了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。

1、驱动程序首先运行C预处理器（cpp），它将C的源程序main.c翻译成一个ASCII码的中间文件main.i        cpp main.c/tmp/main.i

2、驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII码汇编语言文件main.s		ccl  /tmp/main.i -0g - o /tmp/main.s

3、驱动器运行汇编器(as)，它将main.s翻译成一个可重定位目标文件main.o    as -o/tmp/main.o /tmp/main.s

驱动器经过相同的过程生成sum.o	最后它运行链接器程序ld，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行的目标文件prog;

![image-20200620113034910](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyli2tvh8j30nu0i846w.jpg)

链接器的两个主要任务：符号解析、重定位。



目标文件三种形式：可重定位目标文件、可执行目标文件、共享目标文件。编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件。



下图展示了一个典型的ELF可重定位目标文件的格式。

![image-20200620114540778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfylxqi7mjj30jm0kgagy.jpg)

夹在ELF头部和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节。

- .text:已编译程序的机器代码
- .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表
- .data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中也不出现在.bss节中
- .bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占实际的空间，它仅仅是一个占位符。
- .symtab:一个符号表，它存放在程序中定义和引用的函数的全局变量信息。
- .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
- .rel.data:被模块引用或定义的所有全局变量的重定位信息。
- .debug:符号调试表，其条目是程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。
- .line:原始C源程序中的行号和.text节中的机器指令之间的映射。
- .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。

在链接器的上下文中有三种不同的符号：由模块m定义并能被其他模块引用的全局符号；由其他模块定义并被m模块引用的全局符号，被称为外部符号；只被m模块定义和引用的局部符号



可执行目标文件

![image-20200620125503684](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfynxxq3fgj30yc0kcn9m.jpg)



动态链接共享库：共享库是致力于解决静态库缺陷的一种现代创新产物，共享库是一个目标模块，在运行或加载时可以加载到任意内存地址，并和一个在内存中运行的程序链接起来，这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，Linux系统中通常用.so后缀(windows中是DLL文件)

![image-20200620131504702](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyoisroylj30pg0pmqef.jpg)

动态链接器通过重定位完成链接任务

- 重定位libc.so的文本和数据到某个内存段
- 重定位libvector.so的文本和数据到另一个内存段
- 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用

最后动态链接器将控制转移到应用程序，从这时起，共享库的位置就固定了，并且在程序执行的过程中也不会变。



库打桩机制

- 编译时打桩
- 链接时打桩
- 运行时打桩



处理目标文件的工具

- AR ：创建静态库，插入删除列表和提取成员
- STRINGS:列出一个目标文件中所有可打印的字符转
- STRIP：从目标文件中删除符号表信息
- NM：列出一个目标文件的符号表中定义的符号
- SIZE:列出目标文件中节的大小和名字
- READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息，包含SIZE和NM的功能
- OBJDUMP:所有二进制工具之母，能够显示一个目标文件中所有的信息，它最大的作用是反汇编.text节中的二进制指令。



#### 第八章异常控制流

现代系统通常使控制流发生突变来对应这些情况来做出反应，我们把这些突变称之为异常控制流。



理解ECF的作用

- 帮助理解重要的系统概念。ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制
- 帮助理解应用程序是如何与操作系统互相交互的。
- 帮助编写新的应用程序
- 帮助理解并发
- 帮助理解软件异常如何工作

一场就是控制流中的突变，用来响应处理器状态中的某些变化。下图中，当处理器状态中发生了一个重要的变化时，处理器正当执行某个当前指令Icurr在处理中，状态被编码为不同的位和信号，状态变化称为事件。事件可能和当前指令的执行直接相关。比如发生虚拟内存缺页、算术溢出，或者一条指令试图除以0。另一方面，也可能和当前指令的执行没有关系。比如一个系统定时器产生信号或者一个I/O请求完成。

![image-20200620133700948](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyp5kya69j30py0jen8c.jpg)

![image-20200620134337918](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfypchd8o2j31aw0rqe81.jpg)



异常的分类：

​	中断：中断时异步发生的。是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的。硬件中断异常的处理程序称之为中断处理程序

​	陷阱：陷阱是有意的异常，是执行一条指令的结果。

​	故障：故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时处理器将控制转移给故障处理程序，如果处理器能修正这个错误，它就将控制返回给引起故障的指令，从而重新执行它。否则处理程序返回到内核中abort例程，abort例程将终止引起故障的程序。

​	终止：终止时发生的不可恢复的致命错误而造成的结果，通常是一些硬件错误，终止处理程序从不将控制返回给应用程序。

![image-20200620134839433](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyphp5m3lj31340auk4g.jpg)

![image-20200620135807661](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyprk021ej31be0o61b9.jpg)



进程：进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。



上下文切换：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。



信号

一个信号就是一条消息，它通知进程系统中发生了一个某种类型的事件。

信号术语

- 发送信号  内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程
- 接收信号  当目的进程被内核强迫以某种方式对信号的发送做出反应时，他就接受了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数补货这个信号。

一个发出而没有被接收的信号称为待处理信号。在任何时刻，一种类型至多只会有一个待处理信号

异常控制流发生在计算机系统的各个层次，是计算机系统提供并发的基本机制。



#### 第九章虚拟内存

为了更加有效的管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存（VM），虚拟内存是硬件异常，硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。虚拟内存是计算机系统的重要概念之一。

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址（PA）

![image-20200620151808461](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfys2t974xj30ke0i60zj.jpg)

地址空间：地址空间是一个非负整数地址的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。



在任何时刻虚拟页面的集合都分为三个不相交的子集：

- 未分配的：VM系统还未分配的页
- 缓存的：当前已缓存在物理内存中的已分配页
- 未缓存的：未缓存在物理内存中的已分配页
- ![image-20200620152424027](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfys9bo690j30vm0fs7fu.jpg)

内存映射

​	Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型对象中的一种。

1、Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。

2、匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制0。



fork函数：当fork函数被当前进程调用时，内核会为新进程创建各种数据结构，并分配给他一个唯一的PID，



动态分配内存

动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。

![image-20200620155803641](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyt876s82j30k60q44es.jpg)

malloc和free函数

C标准库提供了一个称为malloc程序包的显示分配器，程序通过调用malloc函数来从堆中分配块。

动态内存分配器，例如malloc，可以通过使用mmap和munmap函数显示的分配和释放堆内存，或者还可以用sbrk函数：

![image-20200620160458872](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfytfeit0dj319s0dawvb.jpg)

程序是通过调用free函数来释放已分配的堆块。

下图展示了一个malloc和free的实现是如何管理一个C程序的16字的小的堆的。

![image-20200620162124514](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfytwi2fbmj313p0u0kjl.jpg)



垃圾收集

垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为辣鸡，自动回收堆存储的过程叫垃圾收集。

![image-20200620162709385](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyu2hg568j316o0pub29.jpg)

C程序中常见的与内存有关的错误

- 间接引用坏指针![image-20200620162859414](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyu4e1o0sj314609kn6g.jpg)

- 读未初始化的内存

  ```c
  int *matvec(int **A,int *x,int n){
    int i,j;
    int *y =(int*)Malloc(n*sizeof(int));
    for(i=0;i<n;i++){
      for(j=0;j<n;j++){
        y[i] += A[i][j] * x[j];
      }
    }
    return y;
  }
  ```

  在这个示例中，程序员不正确的假设向量y被初始化为0，正确的实现方式是显示的将y[i]设置为零，或者使用calloc

- 引用指针，而不是它所指的对象

- ![image-20200620170856324](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyv9yzcdlj315q0oe1kx.jpg)

虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟内存的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。



#### 第十章系统级I/O

输入/输出（I/O）是在主存和外部设备（磁盘驱动器、终端、网络）之间复制数据的过程。输入操作是从I/O设备复制数据到主存，输出操作使从主存复制数据到I/O设备。



每个Linux文件都有一个类型来表明它在系统中的角色

- 普通文件包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII和Unicode字符的普通文件。二进制文件时所有的其他文件，对内核系统而言，文本文件和二进制文件没有区别
- 目录  是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录
- 套接字 是用来与另一个进程进行跨网络通信的文件



Linux系统的目录层次结构的一部分

![image-20200620172524939](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyvr3qw4uj311q0gcqcw.jpg)

进程是通过open函数来打开一个已存在或者新建一个文件。

```c
#include<sys/types.h>
#include<sys/stat.h>
#include<sys/fcntl.h>

int open(char *filename,int flags,mode_t mode);

//返回:若成功则为新文件描述符，若出错则为-1
```

flag参数：

O_RDONLY:只读；

O_WRONLY:只写；

O_RDWR:可读可写；

flag参数也可以是一个或者更多位掩码的或，为写提供一些额外的指示：

- O_CREATE:如果文件不存在，就创建它的一个截断的文件
- O_TRUNC:如果文件已存在就截断他
- O_APPEND:在每次写操作前，设置文件位置到文件的结尾处

![image-20200620173310105](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyvz61axrj30zg0jw1df.jpg)

进程通过调用close函数来关闭一个打开的文件

```c
#include <unistd.h>

int close(int fd);

//返回:若成功则为0，若出错则为-1
```

关闭一个已关闭的描述符会出错



用RIO包健壮的读写

- 无缓冲的输入输出函数，这些函数直接在内存和文件之间传输数据，没有应用级缓冲，它们将对二进制数据读写到网络和从网络读写二进制数据尤其有用![image-20200620174008573](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw6fa9wzj31do0ac4av.jpg)
- 带缓冲的输入函数，这些文件允许你高效的从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为printf这种的标准I/O函数提供的缓冲区。![image-20200620174031096](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw6tbks6j31di0b6n6z.jpg)

![image-20200620174100502](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw7bgp1rj31cl0u0x1v.jpg)

![image-20200620174124964](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw7r2aulj31f20u0qor.jpg)

读取目录内容

应用程序可以通过readdir系列函数来读取目录的内容

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);
//若成功 则为处理的指针，若出错则为NULL
```

函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。

```c
#include <dirent.h>
struct dirent *readdir(DIR * dirp);
//返回：若成功则为指向下一个目录项的指针，若没有更多的目录项或出错，则返回NULL
```



标准I/O

C语言定义了一组搞基输入输出函数，称为标准I/O库。



Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。



#### 第十一章网络编程

客户端-服务器编程模型

客户端-服务器模型中的基本操作是事务，一个客户端-服务器的事务由以下四步组成

1. 当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。例如，当web浏览器需要一个文件时，它就发送一个请求给web服务器
2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当web服务器收到web浏览器发的请求后，它就读一个磁盘文件
3. 服务器给客户端发送一个响应，并等待下一个请求。例如，web服务器将文件发送回客户端
4. 客户端收到响应并处理它。例如，当web浏览器收到来自服务器的一页后，就在屏幕上显示此页。

![image-20200620180008595](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfywr8gn3gj314608ywmr.jpg)



网络

客户端和服务器通常运行在不同的主机上，并且通过计算机网络的硬件和软件资源来通信。

![image-20200620181716138](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyx91zvraj31600qox1g.jpg)

![image-20200620181834149](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyxaeo0m1j318c0r2aqr.jpg)

因特网连接

一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用“地址：端口”来表示

![image-20200620192249848](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyz5agvwwj31300citle.jpg)

在这个示例中客户端的套接字地址是128.2.194.242:51213其中端口号51213是内核分配的临时端口号。



套接字接口

套接字接口是一组函数，它们和UnixI/O函数组合起来，用以创建网络应用。大多数现代系统上都实现套接字接口，包括所有的Unix变种、Windows和macintosh系统，下图是典型的客户端-服务器事务的上下文中的套接字接口概述。

![image-20200620192818937](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyzb0uudej31fb0u04k3.jpg)

套接字地址结构

从Linux内核的角度看，一个套接字就是通信的一个端点。从Linux程序的角度看，套接字就是一个有相应描述符的打开文件。

![image-20200620193336156](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyzgi4vfmj316c0lkh45.jpg)

每个网络应用都是基于客户端-服务器模型的。根据这个模型，一个应用是由一个服务器和一个或多个客户端组成的。服务器管理资源，以某种方式操作资源，为他的客户端提供服务。客户端-服务器模型中的基本操作是客户端-服务器事务，它是由客户端的请求和跟随其后的服务器响应组成的。



#### 第十二章并发编程

基于进程的并发编程

构造并发编程最简单的方法就是用进程，使用熟悉的函数。例如，一个构造并发服务器的方法就是，在父进程中接受客户端的连接请求，然后创建一个新的子进程来为每个新客户端提供服务。



基于进程的并发服务器

下面展示了一个基于进程的并发echo服务器的代码，有几个重要的点：

- 首先服务器通常会运行很长的时间，所以我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源。因为当SIGCHLD处理程序执行时，SIGCHLD信号是塞满的，而Linux信号是不排队的，所以SIGCHLD处理程序必须准备好回收多个僵死子进程的资源
- 其次父进程必须关闭它们各自的connfd副本。这对父进程而言尤为重要，它必须关闭它的已连接描述符，避免内存泄漏。
- 最后因为套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止。

```c
#include <csapp.h>

void echo(int connfd);

void sigchld_handler(int sig){
  while(waitpid(-1,0,WNOHANG))
    ;
  return;
}

int main(int argc,char **argv){
  int listenfd,connfd;
  socklen_t,clientlen;
  struct sockaddr_storage clientaddr;
  
  if(argc != 2)
  {
    fprintf(stderr,"usage:%s <port> \n",argv[0]);
  }
  listenfd = Open_listenfd(argv[1]);
  
  FD_ZERO(&read_set);
  FD_SET(STDIN_FILENO,&read_set)；
  FD_SET(listenfd,&read_set);
  
  while(1){
    ready_set = read_set;
    Select(listenfd+1,&ready_set,NULL,NULL,NULL);
    if(FD_ISSET(STDIN_FILENO,&ready_set))
    {
      command();
    }
    if(FD_ISSET(listenfd,&ready_set))
    {
      clientlen = sizeof(struct sockaddr_storage);
      connfd = Accept(listenfd,(SA *)&clientaddr,&clientlen);
      echo(connfd);
      Close(connfd);
    }
  }
}

void command(void){
  char buf[MAXLINE];
  if(!Fgets(buf,MANLINE,stdin))
    exit(0);
  printf("%s",buf);
}
```



基于线程的并发编程

线程就是运行在进程上下文中的逻辑流。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID（thread ID ，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。

线程执行模型

每个进程在开始生命周期时都是单一线程，这个线程成为主线程，在某一时刻主线程创建一个对等线程，从这个时间点开始，两个线程就并发的运行。最后因为主线程执行一个慢速的系统调用，例如read或者sleep，控制就会通过上下文切换传递到对等线程中，对等线程会执行一段时间，然后控制传递回主线程，以此类推。

![image-20200620202348728](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz0wpv0otj30qi0kg7cx.jpg)

创建线程

线程通过调用pthread_create函数来创建其他线程。

```c
#include <pthread.h>
typedof void*(func)(void*);
int pthread_create(pthread_t *tid,pthread_attr_t *attr,func *f,void *arg);
//若成功返回0  若出错则为非0
```

Pthread_create函数创建一个新的线程，并带着一个输入变量arg，在新线程的上下文中运行线程实例f，能用attr参数来改变新创建线程的默认属性。

当pthread_create返回时，参数pid包含新创建线程的ID。新线程可以通过调用pthread_self函数来获取它自己的线程ID。

```c
#include <pthread.h>
pthread_t pthread_self(void);
//返回调用者的线程ID
```

终止线程

一个线程是以下方式之一来终止的：

- 当顶层的线程例程返回时，线程会隐式的终止。

- 通过调用pthread_exit函数，线程会显示的终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程的整个进程，返回值为pthread_return。

  ```c
  #include <pthread.h>
  void pthread_exit(void *pthread_return);
  //从不返回
  ```

- 某个对等线程调用Linux的exit函数，该函数终止进程以及所有与该进程相关的线程。

- 另一个对等线程通过以当前线程的ID作为参数调用pthread_cancel函数来终止当前线程。

  ```c
  #include <pthread.h>
  void pthread_cancel(pthread_t tid);
  //若成功返回0 若出错则返回非0
  ```



将变量映射到内存

多线程的C程序中变量根据它们的储存类型被映射到虚拟内存

- 全局变量 ：定义在函数之外的变量。在运行时，虚拟内存的读写区域只包含每个全局变量的一个实例，任何线程都可以引用。
- 本地自动变量：定义在函数内部但是没有static属性的变量
- 本地静态变量：定义在函数内部并且有static属性的变量



使用线程提高并行性

并发和并行程序之间的集合关系

![image-20200620210930778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz289y2ugj30me0dkqcu.jpg)

线程安全

线程不安全函数类：

1. 不保护共享变量的函数
2. 保持多个跨越调用的状态的函数
3. 返回指向静态变量的指针的函数
4. 调用线程不安全函数的函数



可重入性

有一类重要的线程安全函数，叫做可重入函数。其特点在于他们拥有这样一种属性，当他们被多个线程调用时，不会引起任何共享数据。尽管线程安全和可重入有时会（不正确地）被用作同义词，但是它们之间还是有清晰的技术差别。![image-20200620211602983](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2f2vgsij30mw0dun9g.jpg)

可重入函数通常比不可重入的线程安全的函数高效一些。

常见的线程不安全的库函数

![image-20200620211935040](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2iqt00cj310m0fik2o.jpg)



死锁

信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁，它指的是一组线程被阻塞了，等待一个永远也不会为真的条件。![image-20200620212137487](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2kwfkkoj31100s0e35.jpg)

程序猿使用P和V操作顺序不当，以至于两个信号量的禁止区域重叠，如果某个执行轨迹线碰巧到达了死锁状态d，那么久不可能有进一步的进展了，因为重叠禁止区域阻塞了每个合法方向上的进展。

重叠的禁止区域引起了一组称为死锁区域的状态。如果一个轨迹线碰巧到达了一个死锁区域中的状态，那么死锁就是不可避免的了。轨迹线可以进入死锁区域，但是它们不能离开。

死锁是相当困难的一个问题，因为他总是不可预测的。



**互斥锁加锁顺序规则**：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

![image-20200620213637816](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz30hkht0j30ye0nqarx.jpg)





#### 总结

##### 今天是第三周计算机这本书只能说是快速刷了一遍，大体了解了讲了哪些内容，看到之后有印象，并没有过多深入的了解。记下了一些概念性的东西，自己基础太差导致看起来很费劲，路哥说的要掌握的章节实际上也只过了一边并没有真的掌握，因为如果要掌握去看的话可能会很花时间，暂时的计划是快速过一遍有整体印象，在通过路哥课上讲解然后自己再去理解一下，还有代码性的东西我觉得还是得多写，因为读书过程中并没有真的去写多少代码，这个目前有很欠缺。