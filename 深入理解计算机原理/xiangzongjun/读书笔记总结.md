#### 						

### 									读书笔记总结



#### 第一章 计算机系统漫游

**1.1 一个程序的生命周期就是从一个源程序或者说源文件开始的，也就是通过编译器创建保存的文本文件，源程序实际就是由0和1组成的位序列，8个位被组织成一组成为字节。**

1.2 大部分的现代计算机系统都使用ASCII标准来表示文本字符，比如下面程序的ASCII码表示如图：

```
#include <stdio.h>
int main(){
printf("hello world\n");
return 0;
}
```

[![img](https://camo.githubusercontent.com/f070bd9f5cf661cfc9caf8b119eb6deb8f69140a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d323030653164303565616136656437662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303032)](https://camo.githubusercontent.com/f070bd9f5cf661cfc9caf8b119eb6deb8f69140a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d323030653164303565616136656437662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303032)

1.3 C语言的起源

[![img](https://camo.githubusercontent.com/1ce2ac5bf33d0c499c2ae35400410690f33c1fbe/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d313966373135353238666439613238302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f393633)](https://camo.githubusercontent.com/1ce2ac5bf33d0c499c2ae35400410690f33c1fbe/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d313966373135353238666439613238302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f393633)

1.4 源程序从创建到可执行程序的过程

[![img](https://camo.githubusercontent.com/2bf4170dc8f98d267259b77c775d4aa52113b08b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d363633616631373862663365656435372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303033)](https://camo.githubusercontent.com/2bf4170dc8f98d267259b77c775d4aa52113b08b/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d363633616631373862663365656435372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303033)

预处理阶段：预处理器cpp跟菊字符#开头的命令修改原始的C程序，通常以.i作为文件扩展名

编译阶段：编译器ccl将文本文件hello.i翻译成文本文件hello.s,包含一个汇编语言程序

汇编阶段：编译器as将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件hello.o中（二进制文件）。

链接阶段：hello程序调用了printf函数（标准C库中的一个函数），printf存在于另一个叫做printf.o的编译好了的目标文件中,这个文件必须用某种方式合并到hello.o程序中。连接器就处理这种合并。

1.5 系统硬件组成

1、总线 ：贯穿整个系统的一组电子管道称作为总线，它携带信息字节负责在各个部件之间传递

2、I/O设备 ：I/O设备是系统与外部世界联系的通道。鼠标键盘作为输入设备，显示器磁盘作为输出设备。每个I/O设备都通过适配器或控制器与总线相连。

[![system](https://camo.githubusercontent.com/b15efd7df102afd68b9374aa2d22e96fe8e4d148/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d303862393962346331626337383466342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f393134)](https://camo.githubusercontent.com/b15efd7df102afd68b9374aa2d22e96fe8e4d148/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d303862393962346331626337383466342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f393134)

3、主存：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

4、处理器：中央处理单元（CPU）简称处理器，是执行储存在主存中指令的引擎，核心是一个大小为一个字节的存储设备（寄存器）。

**1.6运行hello程序**

shell执行一系列指令加载可执行的hello文件，这些指令将hello目标文件中的数据从磁盘复制到主存，一旦目标文件hello中的代码和数据被加载到了主存，处理器就开始执行hello程序main程序中的机器语言指令。这些指令将"hello world\n"字符串中的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。

[![show](https://camo.githubusercontent.com/3866db54a605471accaeba837290b99984ac2eca/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d336535643634386638396337373663622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303033)](https://camo.githubusercontent.com/3866db54a605471accaeba837290b99984ac2eca/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d336535643634386638396337373663622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303033)



系统花费大量的时间把信息从一个地方复制到另一个地方，这些复制就是开销，减慢了程序“真正的”工作，因此系统设计者的一个主要目标就是使这些复制操作尽可能快的完成。

根据机械原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价要远高于同类低速设备。比如：一个系统上的磁盘比主存要大1000倍，但是对处理器而已，从磁盘读取一个字的时间比从主存读取一个字的时间开销要大1000万倍。类似的从寄存器文件中读取数据比从主存中读取几乎快100倍，而寄存器只能存储几百字节信息，而主存可以存放几十亿字节。

针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，成为高速缓存存储器作为暂时的集结区域存放处理器近期可能会需要的信息。

[![memory](https://camo.githubusercontent.com/dbedeb2e116f6d4288bd32ffa5895d0fb665047d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d333836613431383236653365333837342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383831)](https://camo.githubusercontent.com/dbedeb2e116f6d4288bd32ffa5895d0fb665047d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d333836613431383236653365333837342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383831)

计算机系统中存储设备的存储器层次结构

[![level_memory7](https://camo.githubusercontent.com/330349c4a5981c736452550102ed98fb40a21411/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d346131653065386232666630613363662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303336)](https://camo.githubusercontent.com/330349c4a5981c736452550102ed98fb40a21411/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d346131653065386232666630613363662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303336)

**三、操作系统管理硬件**

所有应用程序对硬件的操作尝试都必须经过操作系统。操作系统有两个基本功能（1）防止硬件被时空的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念来实现（进程、虚拟内存、文件）这两个功能

[![hardware](https://camo.githubusercontent.com/5affdd63a83cdd9a9a07a7929c6eece90a8371ab/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d363037373062383739666130356136312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f353232)](https://camo.githubusercontent.com/5affdd63a83cdd9a9a07a7929c6eece90a8371ab/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d363037373062383739666130356136312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f353232)

**四、进程**

进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。

操作系统保持跟踪进程运行所需的所有状态信息，这种状态也就是上下文。包括许多信息，比如PC何寄存器文件的当前值，以及主存的内容。在任何一个时刻处理器都只能执行一个进程的代码。当操作系统决定要把控制权从一个进程转移另一个进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新锦成的上下文，然后将控制权转移到新进程，新进程就会从上次停止的地方开始。

**五、线程**

通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以有多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

**六、虚拟内存**

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占的使用主存。每个进程看到的内存都是一致的，成为虚拟地址空间。

地址空间最上面的区域是保留给操作系统中代码和数据的，这对所有进程来说都是一样的。地址空间底部区域存放用户进程定义的代码和数据，途中地址从下往上是增大的。

[![xuni_memory](https://camo.githubusercontent.com/afe3377e97b7124caa48e5d22e2b4508ba8ee357/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d393262386438336136343630376231642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f373537)](https://camo.githubusercontent.com/afe3377e97b7124caa48e5d22e2b4508ba8ee357/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d393262386438336136343630376231642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f373537)

**七、系统之间通过网络通信**

现代系统通过网络和其他系统连接到一起，网络可以视为一个I/O设备。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘启动器。相似的系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。

使用telnet应用在一个远程主机上运行hello程序

[![Internet](https://camo.githubusercontent.com/3cdea560d7d3bf65f583e83a700134dba7fe77fc/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d343464333233313333326333323639382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303039)](https://camo.githubusercontent.com/3cdea560d7d3bf65f583e83a700134dba7fe77fc/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d343464333233313333326333323639382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303039)

**八、Amdahl定律**

[![Amdahl](https://camo.githubusercontent.com/799c9845f1909a9e7b7e1dc407c60801424c4668/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d326365633730356137373962626337342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303434)](https://camo.githubusercontent.com/799c9845f1909a9e7b7e1dc407c60801424c4668/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d326365633730356137373962626337342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303434)

**九、并发和并行**

线程级并发：构建在进程这个抽象之上，我们能设计出同时有多个程序执行的系统。这就导致了并发。

指令级并行：现代处理器可以执行多条指令的属性成为指令级并行。

单指令、多数据并行：在最低层次上许多现代处理器拥有特殊硬件，允许一条指令产生多个可以并执行的操作，这种方式成为单指令多数据，即SIMD并行。

###### 



#### 第二章 信息的表示和处理

现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字（位）形成了数字革命的基础。

三种重要的数字表示。无符号编码基于传统的二进制表示法，表示大于或者等于0的数字，有符号整数就是可以为正或者负的数字。浮点数编码是表示实数的科学计数法的以2为基数的版本。计算机用这些不同的表示方法实现算数运算。

##### 一、信息存储

大多数计算机使用8位的块或者字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，成为虚拟内存。内存的每个字节都由一个唯一的数字来标识称为它的地址，所有可能的地址的集合称为虚拟地址空间。

十六进制表示法（0-9，A-F），下图展示了16进制对应的十进制和二进制的值

[![16](https://camo.githubusercontent.com/420778949aa6a84f6a48594cf33904d84ad75688/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633565326266373938646461333766632e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303038)](https://camo.githubusercontent.com/420778949aa6a84f6a48594cf33904d84ad75688/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633565326266373938646461333766632e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303038)

C语言中以0X开头的数字常亮被认为是16进制的值，字符A-F可以大小写。

2进制转换16进制 比如0011101 从左到右4个位一组，不足4个前面补0.所以可以分为0001和1101.可以用8421法进行转换即第一组计算为0x2^3+0x2^2+0x2^1+1x2^0 = 1,第二组可以计算变成1x2^3+1x2^2+0x2^1+1x2^0=13,13对于的16进制是D，所以改组二进制转换16进制为1D

16进制转换2进制一样的方法。比如16进制3F换成2进制用8421法第一个数字3那就只能是2+1的可能，所以前面两个数字都是0，第一组即为0011，F对应数字是15，所以也只有8+4+2+1=15，即1111，所以3F对应的二进制是00111111.

##### 二、字数据大小

每台计算机都有一个字长，指明指针数据的标称大小。

[![size](https://camo.githubusercontent.com/6f59b4d34ece0b4ba08c5df765d7453c4f0aa3f4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d343236333330393963353837313463392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f353633)](https://camo.githubusercontent.com/6f59b4d34ece0b4ba08c5df765d7453c4f0aa3f4/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d343236333330393963353837313463392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f353633)

##### 三、寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。

[![gz](https://camo.githubusercontent.com/b9a4db672ee6bcd3abaf535da6985b636e423cf2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d656434626633633064363264653539332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303236)](https://camo.githubusercontent.com/b9a4db672ee6bcd3abaf535da6985b636e423cf2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d656434626633633064363264653539332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303236)

##### 四、布尔代数简介

[![bool](https://camo.githubusercontent.com/ca180a034889ea1148a8be865791fa01e05739dd/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d613138303432313832316432363062362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303238)](https://camo.githubusercontent.com/ca180a034889ea1148a8be865791fa01e05739dd/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d613138303432313832316432363062362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303238)

##### 五、位级运算

[![math](https://camo.githubusercontent.com/b8181f1113f2b3aba028a0abbd3270649786a7b1/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633863383637613865646334313032372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303333)](https://camo.githubusercontent.com/b8181f1113f2b3aba028a0abbd3270649786a7b1/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633863383637613865646334313032372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303333)

##### 六、位移运算

[![move](https://camo.githubusercontent.com/03827a16567f034b8f91ef837347229e631198c5/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d636339656635386530383539613764322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303539)](https://camo.githubusercontent.com/03827a16567f034b8f91ef837347229e631198c5/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d636339656635386530383539613764322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31303539)

##### 七、整数表示

用位来编码整数的两种不同的方式：一种智能是表示非负数，而另一种能够表示负数、零和正数。

[![zhengshu](https://camo.githubusercontent.com/1bbdf67b02b4ba9d3b2b8cf2dfadc51e53b4e680/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633564613062323031653165623464662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383039)](https://camo.githubusercontent.com/1bbdf67b02b4ba9d3b2b8cf2dfadc51e53b4e680/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d633564613062323031653165623464662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383039)

整数数据类型32位：

[![area](https://camo.githubusercontent.com/581d2337b872fb215eeeb1819f5b622019ed4a1f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d616665323530353838313034373732392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383330)](https://camo.githubusercontent.com/581d2337b872fb215eeeb1819f5b622019ed4a1f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d616665323530353838313034373732392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383330)

整数数据类型64位：

[![area64](https://camo.githubusercontent.com/8a0515b6fae21c2537e1118b4adbf0ef1bc9ac70/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d663465666333623861666630363462372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383130)](https://camo.githubusercontent.com/8a0515b6fae21c2537e1118b4adbf0ef1bc9ac70/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31363338323935372d663465666333623861666630363462372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f383130)



​ ###### 第二章阶段总结​
​ ###### 1.对进制间的转换已经了解能够运算。​
​ ###### 2.布尔代数也了解了怎么运算的。​
​ ###### 3.剩下部分比如补码等章节过了一遍，感觉公式很多不是记得很明白，大概有个印象。本章没有过多文字概念性的东西，数学公式偏多。也就是理解了简单基础的一些东西。发现了自我薄弱的地方，通过本周学习以及路哥的建议，下周阅读中改进方法，加快一点进度，不要过于深究一些东西，太费时间。



#### 第三章程序的机器级表示

#####   1、机器级代码

- 程序计数器（通常称为PC，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。

- 整数寄存器文件包含16个命名的位置，分别储存64位的值。这些寄存器可以储存地址（对应c语言的指针）或整数数据。有的寄存器被分别用来记录某些重要的程序状态，而其他的寄存器保存临时数据，例如过程中的参数、局部变量以及函数的返回值。

- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。他们用来实现控制或数据流中的条件变化，比如用来实现while、if语句。

- 一组向量寄存器可以存放一个或多个整数或浮点数值。

  一条机器指令只执行一个非常基本的操作。比如讲存放在寄存器中的两个数字相加，在储存器和寄存器之间传送数据，或条件分支转移到新的指令地址。

##### 	2、数据格式	![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqlsrvt1kj319i0egwra.jpg)

​	大多数gcc生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有4个变种：movb(传送字节)、movw(传送字)、mov1(传送双字)、movq(传送4字)

##### 	3、访问信息

​	一个x86-64的中央处理单元（CPU）包含一组16个储存64值得通用目的寄存器。这些寄存器用来存储整数数据和指针。

![image-20200613134650906](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqm3kk4ymj30wj0u0hdt.jpg)

##### 	4、算术和逻辑操作

​	![image-20200613135522224](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqmcfcft5j31fx0u04os.jpg)

​	特殊的算术操作

​	![image-20200613135833013](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqmfqnw0yj318s0hkasr.jpg)

##### 	5、条件码

​	除了整数寄存器，CPU还维护着一组单个位的条件码寄存器，他们描述着最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。

​	CF：进位标识，最近的操作使最高位产生了进位。可以用来检测无符号操作的溢出。

​	ZF：零标识，最近的操作得出的结果为0.

​	SF：符号标识，最近的操作得到的结果为负数。

​	OF：溢出标识，最近的操作导致一个补码溢出，正溢出或者负溢出。

​	比如说，我们用一条ADD指令完成等价于C表达式t = a+b的功能，这里变量a,b,t都是整型的。然后根据下面的C表达式来设置条件码：

​	CF			(unsigned)t < (unsigned)a			无符号溢出

​	ZF			(t == 0)											  零

​	SF			(t < 0)												负数

​	OF			(a<0 == b<0)&&(t<0 != a<0)		  有符号溢出



​	访问条件码

​	条件码通常不会直接读取，常用的使用方法有3种：

​	1、根据条件码的某种组合，将一个字节设置为0或者1。

​	2、可以条件跳转到程序的某个其他部分。

​	3、可以有条件的传送数据。



##### 	6、数组分配和访问

​	指针运算：C寓言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。

![image-20200613142814226](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnamspudj31f60qchdt.jpg)

​	理解指针：指针是C语言的核心特色，它们以一种统一方式，对不同数据结构中的元素产生引用。

- 每个指针都对应一个类型，这个类型表明指针指向的是哪一类对象。                                   ![image-20200613143734256](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnkc3ai2j31bm0dgqmn.jpg)

- 每个指针都有一个值。这个值是某个指定类型的对象的地址，特殊的值（NULL、0）表示该指针没有指向任何地方。

- 指针用&运算符创建

- *操作符用于间接引用指针。其结果是一个值，它的类型与指针的类型一致。间接引用使用内存引用来实现的，要么储存到一个指定的地址，要么从一个指定的地址取出。

- 数组与指针密切相关。一个数组的名字可以像一个指针变量一样引用（但不能修改）。数组引用与指针运算或间接引用有一样的效果。

- 将指针从一种类型强制转换成另一种类型，只需要改变它的类型，不改变它的值。强制类型的转换是一个指针类型的收缩。例如，如果P是一个char *类型的指针，它的值为P，那么表达式(int *)p+7计算为p+28,而(int *)(p+7)计算为p+7。

- 指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这写引用可以被程序的其他某个部分调用，例如：![image-20200613145125741](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqnyrbax3j31660gkdri.jpg)

  ##### 7、浮点代码

  处理器的浮点体系结构包括很多方面，会印象对浮点数据操作的程序如何被映射到机器上，包括：

  1、如何存储和访问浮点数值。通常是通过某种寄存器来完成。

  2、对浮点数据操作的指令。

  3、向函数传递浮点数参数和从函数返回浮点数结果的规则。

  4、函数调用过程中保存寄存器的规则----例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。



##### 		本章小结

​		本章大多数都与汇编有关，只看了一些基本指令，但是实际操作怎么运行的还是有很多看不懂的地方。



#### 第四章处理器体系结构

##### 		1、Y86-64指令集体系结构

​		定义一个指令集体系结构包括定义各种状态单元、指令集和它们的编码、一组编码规范和异常事件处理。

​		Y86-64指令：Y86-64指令集基本上是x86-64指令集的一个子集。它只包括8字节整数操作，寻址方式较少，操作也较少。因为我们只有8个字节数据，所以称之为”字“不会有任何歧义。

​		Y86-64指令的一些细节：

- X86-64的movq指令分成了4个不同的指令：irmovq、rrmovq、mrmovq和rmmovq，分别显示的指明源和目的的格式。源可以是立即数(i)、寄存器(r)或内存(m)。

- 有4个整数操作指令，如下图中的opq，它们是addq,subq,andq,xorq。它们只对寄存器数据进行操作，而x86-64还允许对内存数据进行这些操作。这些指令会设置3个条件码ZF、SF、OF（零、符号、溢出）。

- 7个跳转指令（如下图中的jxx）是jmp、j1e、j1、je、jne、jge和jg。根据分支指令的类型和条件代码的设置来选择分支。

- 有6个条件传送指令（如下图中cmovxx）：cmovle、cmovl、cmove、cmovne、cmovge和cmovg。这些指令格式于寄存器--寄存器传送指令rrmovq一样,但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。

- call指令将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。

- pushq和popq指令实现了入栈和出栈，就像在x86-64中一样。

- halt指令停止指令的执行。x86-64中有一个与之相当的指令hlt。x86-64的应用程序不允许使用这条指令，因为它会导致整个系统暂时停止运行。对于Y86-64来说，执行halt指令会导致处理器停止，并将状态码设置为HLT![image-20200613154507481](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqpimvbbqj31660q4kec.jpg)

  指令编码

  ![image-20200613154658859](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqpkk4l9vj31740o6tsi.jpg)



##### 	2、逻辑设计和硬件控制语言HLC

​	逻辑门：逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位值得某个布尔函数。![image-20200613155554538](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqptunc0lj30kc094ae9.jpg)

​	储存器和时钟

​	组合电路从本质上讲它们不存储任何信息。相反，他们只是简单的响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号决定什么时候要把新的值加载到设备中来，考虑两类存储器设备：

- 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。
- 随机访问存储器（简称内存）存储多个字，用地址来选择该读或改写哪个字。随机储存器的例子包括：1、处理器的虚拟内存系统，硬件和软件操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字。2、寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86-64处理器中寄存器文件有15个寄存器（%rax-%r14）![image-20200613160705054](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqq5hmaaaj31690u0u0t.jpg)

![image-20200613160725719](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqq5u3iinj310a0amn1r.jpg)

##### 	3、Y86-64的顺序实现

​	将处理组织成阶段：通常处理一条指令包括很多操作。将他们组成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理处决于正在执行的指令。创建这样的一个框架，我们就能够设计一个充分利用硬件的处理器。

- 取指（fetch）：取指阶段内存中读取指令字节，地址为程序计数器的值。

- 译码（decode）：译码阶段从寄存器指示符字节指示一个或两个寄存器操作数指示符ra、rb，它还可能取出一个四字节常数valc。

- 执行（execute）：在执行阶段，算术/逻辑单元（ALU）要么执行指令知名的操作，计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为valE。

- 访存(memory）：访存阶段可以将数据写入内存，或者从内存读取数据。读出的值为valM。

- 写回（write back）：写回阶段最多可以写两个结果到寄存器文件。

- 更新PC（PC update）：将PC设置成下一条指令的地址。

  处理器无限循环，执行这些阶段。在我们简化的实现制，发现任何异常时，处理器就会停止：它执行halt命令或非法指令，或它试图或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型绝顶的特殊代码。

##### 4、流水线的通用原则

​	流水线化的一个重要特性就是提高了系统的吞吐量，也就是单位时间内服务的顾客总数，不过它也会轻微的增加延迟，也就是服务一个用户所需要的时间。

​	计算流水线：下图给出了一个简单的非流水线化的硬件系统例子。它是由一些执行计算的逻辑以及保存计算结果的寄存器组成的。时钟信号控制在每个特定的时间间隔加载寄存器。CD播放器中的译码器就是这样的一个系统。输入信号是从CD表面读出的位，逻辑电路对这些位进行译码，产生音频信号。![image-20200613163025897](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqqtrp8skj30zm0lkws7.jpg)

​	在现代逻辑设计中，电路延迟以微微秒或皮秒（picosecond简写ps），也就是10^-12秒为单位来计算。在这里例子中我们假设组合逻辑需要300ps，而加载寄存器需要20ps，上图还给出一种时序图，成为流水线图。在途中时间从左向右流动，从上到下写着一组操作（I1、I2、I3），实心的长方形表示这些指令执行的时间，这个现实中，从开始下一条指令之前必须完成前一个。因此这些方框在垂直方向上并没有互相重叠。下面这个公式给出了运行这个系统的最大吞吐量

![image-20200613163647303](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqr0coxn1j317y0te1kx.jpg)

##### 本章小结

主要讲了处理器的指令体系以及一些概念操作，大致了解工作流程，只有大致印象没有深入理解。



#### 第五章优化程序性能

##### 	1、提高并行性

​		多个累计变量：对于一个可结合和可交换的合并运算来说，比如整数加法或者乘法，我们可通过将一组合并运算分割成两个或者更多部分，并在最后合并结果来提高性能。如下图所示：它使用了两次循环展开，以使每次迭代合并更多的元素，也使用了两路并行，将索引值为偶数的元素累积在变量acc0中，将索引值为奇数的元素累积在变量acc1中。因此我们将其称为2X2循环展开。同前面一样，我们还包括了第二个循环，对于向量长度不为2的倍数时，这个循环要累积所有剩下的数组元素。然后我们对acc0和acc1应用合并运算，计算最终的结果。	

​	![image-20200613172428249](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqsdz2k0uj30mm0syapr.jpg)

比较只做循环展开和即作循环展开也使用两路并行这两种方法，我们得到下面的性能

![image-20200613172600216](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqsfk25r1j312i09yjy8.jpg)



​	重新结合变换:下图中给出了一个combine7函数，他与combine5的展开代码唯一的区别在于内循环中元素合并的方式。在combine5中合并是以下面这条语句来实现的。

acc = (acc OP data[i]) OP data[i+1];

而在combine7中，合并是以这条语句来实现的。

acc = acc OP (data[i] OP data[i+1]);

差别仅在于两个括号是如何放置的。我们称之为重新结合变换，因为括号改变了向量元素与累积值acc的合并顺序，产生了我们称为”2X1a“的循环展开形式。

![image-20200613174939693](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt45zmkjj30qw0n4alb.jpg)

![image-20200613175048727](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt5dne6ij30ui0p2qg6.jpg)

对于未经训练的人来说，这两个语句看上去本质是一样的，但是当我们测量CPE的时候，得到的结果令人吃惊

![image-20200613175413362](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqt8wx93wj31ay0de7ex.jpg)

整数加的性能几乎与使用K X 1展开的版本（combine5）相同，而其他三种情况则与使用并行累积变量的版本（combine6）相同，是K X 1扩展性能的2倍。这些情况已经突破了延迟界限造成的限制。

##### 2、优化合并代码的结果小结

我们极大化对向量元素加或者乘的函数性能的努力获得了成功。下表总结了对于标量代码所获得的结果，没有使用AVX向量指令提供的向量并行性：

![image-20200613180647195](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqtlzgpwbj31060aidok.jpg)

使用多项优化技术，我们获得的CPE已经接近于0.50和1.00的吞吐量界限，只受限于功能单元的容量。与原始代码相比提升了10-20倍，且使用普通的代码和标准的C编译器就获得了所有这些改进。重写代码利用较新的SIMD指令得到了将近4-8倍的性能提升。比如单精度乘法，CPE初值从11.14降到了0.06，整体性能提升了超过180倍。这个例子说明了现代处理器具备有相当的计算能力，但是我们可能需要按非常程式化的方法来编写程序以便将这些能力诱发出来。

##### 3、一些限制因素

​	**寄存器溢出**：循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度P超过了可用的寄存器数量，那么编译器会诉诸溢出，将某些临时值放到内存当中。通常是在运行时堆栈上分配空间。例如将combine6的多累积变量模式扩展到K=10和K=20，其结果的比较如下图所示：![image-20200613181753524](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqtxjw773j31920u04qp.jpg)

累积变量保存为栈上的一个局部变量，其位置距离栈指针偏移量为40.程序必须从内存中读取两个数值，累积变量的值和data[i]的值，将两者相乘后，将结果保存回内存。

一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失，幸运的是x86-64有足够多的寄存器，大多数循环在出现寄存器溢出之前就将到达吞吐量的限制。

**分支预测错误和预测错误处罚**

​	当分支预测逻辑不能正确预测一个分支是否要跳转的时候，条件分支可能会招致很大的预测错误处罚。

​	对于参考机来说，预测错误处罚是19个时钟周期。赌注很高，下面的通用原则可以用。

​	**1、不要过分关心可预测的分支**

​		  我们可以看到错误的分支预测影响可能非常大，但是这并不意味着所有的程序分支后悔减缓程序的执行。实际上，现代处理器中的分支预测逻辑非常善于辨别不同的分支指令的有规律的模式和长期的趋势。

​	**2、书写适合用条件传送的代码**	

​		分支预测只对有规律的模式可行，程序中的许多测试是完全不可预测的，依赖于数据的任意特性，例如一个数是整数还是负数。对于这些测试，分支预测逻辑会处理的很糟糕。对于本质上无法预测的情况如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大提高程序的性能。这不是C语言程序员可以直接控制的，但是有些表达条件行为的方法能够更直接的被翻译成条件传送，而不是其他操作。

##### 本章小结

本章性能优化只认真读了9、10、11三个小节，其余小节快速阅览。主要讲了性能优化，自我理解好像和算法差不多的意思，其中提供并行性和优化合并代码的方式自我理解就是比如一个循环能拆成几个步骤去做，尽量减少循环的次数，最后得到结果，提高程序的效率。



#### 第六章存储器层次结构

##### 	1、存储技术

​	随机访问存储器：分为两类静态的（SRAM）和动态的(DRAM)，静态的要比动态的快很多，但也贵得多。SRAM作为高速缓存存储器，既可以在CPU芯片上，也可以在芯片下。

​	下图总结了SRAM和DRAM存储器的特性，只要有供电，SRAM就会保持不变。与DRAM不同，它不需要刷新。SRAM存储比DRAM快，SRAM对诸如光和电噪声这样的干扰不敏感。代价是SRAM比DRAM使用更多的晶体管，因为密集度低，而且贵，功耗更大。![image-20200613194121502](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwcei738j317207c46n.jpg)	访问主存：数据流通称为总线的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务。读事务从主存传送数据到CPU，写事务从CPU传送数据到主存。![image-20200613194914285](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwklju32j30yg0eqahn.jpg)

磁盘存储：磁盘是由盘片构成。每个盘片有两面或者称为表面，表面覆盖者磁性记录材料。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是5400-15000转每分钟。磁盘通常包含一个或多个这样的盘片并封装在一个密封的容器内。![image-20200613195343835](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwp9owcwj318s0iktpx.jpg)

访问磁盘：CPU使用一种称为内存映射I/O的技术来向I/O设备发射命令，在使用内存映射I/O的系统中，地址空间中有一块地址是为与I/O设备通信保留的。每个这样的地址称为一个I/O端口。当一个设备链接到总线时，它与一个或多个端口相关联。![image-20200613200058129](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqwwsw5d0j30yp0u0ngq.jpg)

##### 	2、局部性

​	一个编写良好的计算机程序常常具有良好的局部性。也就是它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项的本身。这种倾向性被称为局部性原理，吃一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。

​	局部性的两种形式：时间局部性和空间局部性。

​	局部性的简单原则：

- 重复引用相同变量的程序有良好的时间局部性。
- 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为l的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序的空间局部性会很差。
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。



##### 	3、存储器层次结构

- 存储技术：不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高，而且容量较小。CPU和主存的速度差距在增大。

- 计算机软件：一个编写良好的程序倾向于展示出良好的局部性。

  下图是一个典型的存储器层次结构，一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。![image-20200613202115215](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxhwt7mjj319c0rub0o.jpg)

现代系统中导出都使用到了缓存

![image-20200613203010141](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxr6oeuhj319k0nw4qp.jpg)

##### 4、高速缓存存储器

​	早期计算机系统的存储层次结构只有三层：CPU寄存器、DRAM主存储器和磁盘存储。不过由于CPU和主存之间逐渐增大的差距，系统设计者被迫在CPU和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存（一级缓存），L1高速缓存的访问速度几乎和CPU寄存器一样快，典型的是大约4个时钟周期。

![image-20200613203511608](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxwef85kj310e0fstkq.jpg)

高速缓存的基本参数

![image-20200613203628007](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqxxq7a0lj310w0nqtsn.jpg)

高速缓存的性能影响：有许多指标来衡量高速缓存的性能

- 不明中率。在一个程序执行或程序的一部分执行期间，内存引用不明中的比率。它是这样计算的：不命中数量/引用数量
- 命中率。命中的内存引用比率。它等于1-不命中比率
- 命中时间。从高速缓存传送一个字到CPU的时间包括组选择、行确认和字选择的时间。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。
- 不命中处罚。由于不命中所需要的额外的时间。L1不命中需要从L2得到服务的处罚，通常是数十个周期，从L3得到服务的处罚是50个周期。从主存得到服务的处罚是200个周期。

##### 5、编写高速缓存友好的代码

​	1、让最常见的情况运行的快。程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间花在了少量的循环上。所以要把注意力集中在核心函数里的循环上，而忽略其他部分。

​	2、尽量减少每个循环内部的缓存不命中数量。在其他条件相同的情况下，不命中率较低的循环运行的更快。

```c
int sumvec(int v[N]){
  int i,sum = 0;
  for(i = 0 ; i < N; i++)
  {
    sum += v[]i
  }
  return sum;
}
```

现在考虑一下对向量v的步长为1的引用。一般而言，如果一个高速缓存的块大小为B字节，那么一个步长为k的引用模式平均每次循环迭代会有min(1,(wordsize*k)/B)次缓存不命中，当K=1，它取最小值。所以对V的步长为1的引用确实是高速缓存是有好的。例如，假设V是块对齐的，字为4个字节，高速缓存块为4个字，而高速缓存初始为空（冷高速缓存）。然后无论是什么样的高速缓存结构，对V的引用都会得到下面的命中和不命中模式:![image-20200613210456910](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfqyrdnpbjj311m03ugp4.jpg)

在这个例子中对v[0]的引用不会命中，而相应的包含v[0]-v[3]的块会被从内存加载到高速缓存中，因此接下来3个引用都会命中。对v[4]的引用会导致不命中，而一个新的块被加载到高速缓存中，接下来的三个引用都会命中，以此类推，总的来说，4个引用中，3个会命中，在这种冷缓存的情况下，这是我们能做到的最好的情况了。

##### 本章小结

了解了计算机的存储技术以及存储结构层次。最高层访问的速度越快但是花费更快空间也越小。以及文中说的惩罚时间通过理解：如从L1读取的时间和L2读取的时间之差即为惩罚时间，应该就是访问读取的时间增加了，而不是真的惩罚了。明白了代码优化对程序的影响，高质量的代码能很大程度决定程序的快慢与好坏。

欠缺：没有很认真的去看去算这些公式，只对概念性的东西看了一遍，能大概理解。



#### 第七章链接

**概念**：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。链接可执行于编译时，也就是源代码被翻译成机器代码时;也可执行于加载时，也就是程序被加载器加载到内存并执行；甚至执行于运行时，也就是由应用程序来执行。

**作用**：理解链接将帮助你构造大型程序；理解链接将帮助你避免一些危险的编程错误；理解链接将帮助你理解语言的作用域规则是如何实现的；理解链接将帮助你理解其他的重要系统概念；理解链接将使你能够利用共享库。



大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器、链接器。下图表示了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。

1、驱动程序首先运行C预处理器（cpp），它将C的源程序main.c翻译成一个ASCII码的中间文件main.i        cpp main.c/tmp/main.i

2、驱动程序运行C编译器(ccl)，它将main.i翻译成一个ASCII码汇编语言文件main.s		ccl  /tmp/main.i -0g - o /tmp/main.s

3、驱动器运行汇编器(as)，它将main.s翻译成一个可重定位目标文件main.o    as -o/tmp/main.o /tmp/main.s

驱动器经过相同的过程生成sum.o	最后它运行链接器程序ld，将main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行的目标文件prog;

![image-20200620113034910](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyli2tvh8j30nu0i846w.jpg)

链接器的两个主要任务：符号解析、重定位。



目标文件三种形式：可重定位目标文件、可执行目标文件、共享目标文件。编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件。



下图展示了一个典型的ELF可重定位目标文件的格式。

![image-20200620114540778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfylxqi7mjj30jm0kgagy.jpg)

夹在ELF头部和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节。

- .text:已编译程序的机器代码
- .rodata:只读数据，比如printf语句中的格式串和开关语句的跳转表
- .data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中也不出现在.bss节中
- .bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占实际的空间，它仅仅是一个占位符。
- .symtab:一个符号表，它存放在程序中定义和引用的函数的全局变量信息。
- .rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
- .rel.data:被模块引用或定义的所有全局变量的重定位信息。
- .debug:符号调试表，其条目是程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。
- .line:原始C源程序中的行号和.text节中的机器指令之间的映射。
- .strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。

在链接器的上下文中有三种不同的符号：由模块m定义并能被其他模块引用的全局符号；由其他模块定义并被m模块引用的全局符号，被称为外部符号；只被m模块定义和引用的局部符号



可执行目标文件

![image-20200620125503684](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfynxxq3fgj30yc0kcn9m.jpg)



动态链接共享库：共享库是致力于解决静态库缺陷的一种现代创新产物，共享库是一个目标模块，在运行或加载时可以加载到任意内存地址，并和一个在内存中运行的程序链接起来，这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，Linux系统中通常用.so后缀(windows中是DLL文件)

![image-20200620131504702](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyoisroylj30pg0pmqef.jpg)

动态链接器通过重定位完成链接任务

- 重定位libc.so的文本和数据到某个内存段
- 重定位libvector.so的文本和数据到另一个内存段
- 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用

最后动态链接器将控制转移到应用程序，从这时起，共享库的位置就固定了，并且在程序执行的过程中也不会变。



库打桩机制

- 编译时打桩
- 链接时打桩
- 运行时打桩



处理目标文件的工具

- AR ：创建静态库，插入删除列表和提取成员
- STRINGS:列出一个目标文件中所有可打印的字符转
- STRIP：从目标文件中删除符号表信息
- NM：列出一个目标文件的符号表中定义的符号
- SIZE:列出目标文件中节的大小和名字
- READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息，包含SIZE和NM的功能
- OBJDUMP:所有二进制工具之母，能够显示一个目标文件中所有的信息，它最大的作用是反汇编.text节中的二进制指令。



#### 第八章异常控制流

现代系统通常使控制流发生突变来对应这些情况来做出反应，我们把这些突变称之为异常控制流。



理解ECF的作用

- 帮助理解重要的系统概念。ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制
- 帮助理解应用程序是如何与操作系统互相交互的。
- 帮助编写新的应用程序
- 帮助理解并发
- 帮助理解软件异常如何工作

一场就是控制流中的突变，用来响应处理器状态中的某些变化。下图中，当处理器状态中发生了一个重要的变化时，处理器正当执行某个当前指令Icurr在处理中，状态被编码为不同的位和信号，状态变化称为事件。事件可能和当前指令的执行直接相关。比如发生虚拟内存缺页、算术溢出，或者一条指令试图除以0。另一方面，也可能和当前指令的执行没有关系。比如一个系统定时器产生信号或者一个I/O请求完成。

![image-20200620133700948](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyp5kya69j30py0jen8c.jpg)

![image-20200620134337918](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfypchd8o2j31aw0rqe81.jpg)



异常的分类：

​	中断：中断时异步发生的。是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的。硬件中断异常的处理程序称之为中断处理程序

​	陷阱：陷阱是有意的异常，是执行一条指令的结果。

​	故障：故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时处理器将控制转移给故障处理程序，如果处理器能修正这个错误，它就将控制返回给引起故障的指令，从而重新执行它。否则处理程序返回到内核中abort例程，abort例程将终止引起故障的程序。

​	终止：终止时发生的不可恢复的致命错误而造成的结果，通常是一些硬件错误，终止处理程序从不将控制返回给应用程序。

![image-20200620134839433](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyphp5m3lj31340auk4g.jpg)

![image-20200620135807661](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyprk021ej31be0o61b9.jpg)



进程：进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。



上下文切换：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。



信号

一个信号就是一条消息，它通知进程系统中发生了一个某种类型的事件。

信号术语

- 发送信号  内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程
- 接收信号  当目的进程被内核强迫以某种方式对信号的发送做出反应时，他就接受了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数补货这个信号。

一个发出而没有被接收的信号称为待处理信号。在任何时刻，一种类型至多只会有一个待处理信号

异常控制流发生在计算机系统的各个层次，是计算机系统提供并发的基本机制。



#### 第九章虚拟内存

为了更加有效的管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存（VM），虚拟内存是硬件异常，硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。虚拟内存是计算机系统的重要概念之一。

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址（PA）

![image-20200620151808461](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfys2t974xj30ke0i60zj.jpg)

地址空间：地址空间是一个非负整数地址的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。



在任何时刻虚拟页面的集合都分为三个不相交的子集：

- 未分配的：VM系统还未分配的页
- 缓存的：当前已缓存在物理内存中的已分配页
- 未缓存的：未缓存在物理内存中的已分配页
- ![image-20200620152424027](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfys9bo690j30vm0fs7fu.jpg)

内存映射

​	Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型对象中的一种。

1、Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。

2、匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制0。



fork函数：当fork函数被当前进程调用时，内核会为新进程创建各种数据结构，并分配给他一个唯一的PID，



动态分配内存

动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。

![image-20200620155803641](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyt876s82j30k60q44es.jpg)

malloc和free函数

C标准库提供了一个称为malloc程序包的显示分配器，程序通过调用malloc函数来从堆中分配块。

动态内存分配器，例如malloc，可以通过使用mmap和munmap函数显示的分配和释放堆内存，或者还可以用sbrk函数：

![image-20200620160458872](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfytfeit0dj319s0dawvb.jpg)

程序是通过调用free函数来释放已分配的堆块。

下图展示了一个malloc和free的实现是如何管理一个C程序的16字的小的堆的。

![image-20200620162124514](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfytwi2fbmj313p0u0kjl.jpg)



垃圾收集

垃圾收集器是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为辣鸡，自动回收堆存储的过程叫垃圾收集。

![image-20200620162709385](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyu2hg568j316o0pub29.jpg)

C程序中常见的与内存有关的错误

- 间接引用坏指针![image-20200620162859414](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyu4e1o0sj314609kn6g.jpg)

- 读未初始化的内存

  ```c
  int *matvec(int **A,int *x,int n){
    int i,j;
    int *y =(int*)Malloc(n*sizeof(int));
    for(i=0;i<n;i++){
      for(j=0;j<n;j++){
        y[i] += A[i][j] * x[j];
      }
    }
    return y;
  }
  ```

  在这个示例中，程序员不正确的假设向量y被初始化为0，正确的实现方式是显示的将y[i]设置为零，或者使用calloc

- 引用指针，而不是它所指的对象

- ![image-20200620170856324](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyv9yzcdlj315q0oe1kx.jpg)

虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟内存的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。



#### 第十章系统级I/O

输入/输出（I/O）是在主存和外部设备（磁盘驱动器、终端、网络）之间复制数据的过程。输入操作是从I/O设备复制数据到主存，输出操作使从主存复制数据到I/O设备。



每个Linux文件都有一个类型来表明它在系统中的角色

- 普通文件包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII和Unicode字符的普通文件。二进制文件时所有的其他文件，对内核系统而言，文本文件和二进制文件没有区别
- 目录  是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录
- 套接字 是用来与另一个进程进行跨网络通信的文件



Linux系统的目录层次结构的一部分

![image-20200620172524939](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyvr3qw4uj311q0gcqcw.jpg)

进程是通过open函数来打开一个已存在或者新建一个文件。

```c
#include<sys/types.h>
#include<sys/stat.h>
#include<sys/fcntl.h>

int open(char *filename,int flags,mode_t mode);

//返回:若成功则为新文件描述符，若出错则为-1
```

flag参数：

O_RDONLY:只读；

O_WRONLY:只写；

O_RDWR:可读可写；

flag参数也可以是一个或者更多位掩码的或，为写提供一些额外的指示：

- O_CREATE:如果文件不存在，就创建它的一个截断的文件
- O_TRUNC:如果文件已存在就截断他
- O_APPEND:在每次写操作前，设置文件位置到文件的结尾处

![image-20200620173310105](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyvz61axrj30zg0jw1df.jpg)

进程通过调用close函数来关闭一个打开的文件

```c
#include <unistd.h>

int close(int fd);

//返回:若成功则为0，若出错则为-1
```

关闭一个已关闭的描述符会出错



用RIO包健壮的读写

- 无缓冲的输入输出函数，这些函数直接在内存和文件之间传输数据，没有应用级缓冲，它们将对二进制数据读写到网络和从网络读写二进制数据尤其有用![image-20200620174008573](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw6fa9wzj31do0ac4av.jpg)
- 带缓冲的输入函数，这些文件允许你高效的从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为printf这种的标准I/O函数提供的缓冲区。![image-20200620174031096](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw6tbks6j31di0b6n6z.jpg)

![image-20200620174100502](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw7bgp1rj31cl0u0x1v.jpg)

![image-20200620174124964](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyw7r2aulj31f20u0qor.jpg)

读取目录内容

应用程序可以通过readdir系列函数来读取目录的内容

```c
#include <sys/types.h>
#include <dirent.h>

DIR *opendir(const char *name);
//若成功 则为处理的指针，若出错则为NULL
```

函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。

```c
#include <dirent.h>
struct dirent *readdir(DIR * dirp);
//返回：若成功则为指向下一个目录项的指针，若没有更多的目录项或出错，则返回NULL
```



标准I/O

C语言定义了一组搞基输入输出函数，称为标准I/O库。



Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。



#### 第十一章网络编程

客户端-服务器编程模型

客户端-服务器模型中的基本操作是事务，一个客户端-服务器的事务由以下四步组成

1. 当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。例如，当web浏览器需要一个文件时，它就发送一个请求给web服务器
2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当web服务器收到web浏览器发的请求后，它就读一个磁盘文件
3. 服务器给客户端发送一个响应，并等待下一个请求。例如，web服务器将文件发送回客户端
4. 客户端收到响应并处理它。例如，当web浏览器收到来自服务器的一页后，就在屏幕上显示此页。

![image-20200620180008595](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfywr8gn3gj314608ywmr.jpg)



网络

客户端和服务器通常运行在不同的主机上，并且通过计算机网络的硬件和软件资源来通信。

![image-20200620181716138](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyx91zvraj31600qox1g.jpg)

![image-20200620181834149](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyxaeo0m1j318c0r2aqr.jpg)

因特网连接

一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成的，用“地址：端口”来表示

![image-20200620192249848](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyz5agvwwj31300citle.jpg)

在这个示例中客户端的套接字地址是128.2.194.242:51213其中端口号51213是内核分配的临时端口号。



套接字接口

套接字接口是一组函数，它们和UnixI/O函数组合起来，用以创建网络应用。大多数现代系统上都实现套接字接口，包括所有的Unix变种、Windows和macintosh系统，下图是典型的客户端-服务器事务的上下文中的套接字接口概述。

![image-20200620192818937](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyzb0uudej31fb0u04k3.jpg)

套接字地址结构

从Linux内核的角度看，一个套接字就是通信的一个端点。从Linux程序的角度看，套接字就是一个有相应描述符的打开文件。

![image-20200620193336156](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfyzgi4vfmj316c0lkh45.jpg)

每个网络应用都是基于客户端-服务器模型的。根据这个模型，一个应用是由一个服务器和一个或多个客户端组成的。服务器管理资源，以某种方式操作资源，为他的客户端提供服务。客户端-服务器模型中的基本操作是客户端-服务器事务，它是由客户端的请求和跟随其后的服务器响应组成的。



#### 第十二章并发编程

基于进程的并发编程

构造并发编程最简单的方法就是用进程，使用熟悉的函数。例如，一个构造并发服务器的方法就是，在父进程中接受客户端的连接请求，然后创建一个新的子进程来为每个新客户端提供服务。



基于进程的并发服务器

下面展示了一个基于进程的并发echo服务器的代码，有几个重要的点：

- 首先服务器通常会运行很长的时间，所以我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源。因为当SIGCHLD处理程序执行时，SIGCHLD信号是塞满的，而Linux信号是不排队的，所以SIGCHLD处理程序必须准备好回收多个僵死子进程的资源
- 其次父进程必须关闭它们各自的connfd副本。这对父进程而言尤为重要，它必须关闭它的已连接描述符，避免内存泄漏。
- 最后因为套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止。

```c
#include <csapp.h>

void echo(int connfd);

void sigchld_handler(int sig){
  while(waitpid(-1,0,WNOHANG))
    ;
  return;
}

int main(int argc,char **argv){
  int listenfd,connfd;
  socklen_t,clientlen;
  struct sockaddr_storage clientaddr;
  
  if(argc != 2)
  {
    fprintf(stderr,"usage:%s <port> \n",argv[0]);
  }
  listenfd = Open_listenfd(argv[1]);
  
  FD_ZERO(&read_set);
  FD_SET(STDIN_FILENO,&read_set)；
  FD_SET(listenfd,&read_set);
  
  while(1){
    ready_set = read_set;
    Select(listenfd+1,&ready_set,NULL,NULL,NULL);
    if(FD_ISSET(STDIN_FILENO,&ready_set))
    {
      command();
    }
    if(FD_ISSET(listenfd,&ready_set))
    {
      clientlen = sizeof(struct sockaddr_storage);
      connfd = Accept(listenfd,(SA *)&clientaddr,&clientlen);
      echo(connfd);
      Close(connfd);
    }
  }
}

void command(void){
  char buf[MAXLINE];
  if(!Fgets(buf,MANLINE,stdin))
    exit(0);
  printf("%s",buf);
}
```



基于线程的并发编程

线程就是运行在进程上下文中的逻辑流。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程ID（thread ID ，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。

线程执行模型

每个进程在开始生命周期时都是单一线程，这个线程成为主线程，在某一时刻主线程创建一个对等线程，从这个时间点开始，两个线程就并发的运行。最后因为主线程执行一个慢速的系统调用，例如read或者sleep，控制就会通过上下文切换传递到对等线程中，对等线程会执行一段时间，然后控制传递回主线程，以此类推。

![image-20200620202348728](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz0wpv0otj30qi0kg7cx.jpg)

创建线程

线程通过调用pthread_create函数来创建其他线程。

```c
#include <pthread.h>
typedof void*(func)(void*);
int pthread_create(pthread_t *tid,pthread_attr_t *attr,func *f,void *arg);
//若成功返回0  若出错则为非0
```

Pthread_create函数创建一个新的线程，并带着一个输入变量arg，在新线程的上下文中运行线程实例f，能用attr参数来改变新创建线程的默认属性。

当pthread_create返回时，参数pid包含新创建线程的ID。新线程可以通过调用pthread_self函数来获取它自己的线程ID。

```c
#include <pthread.h>
pthread_t pthread_self(void);
//返回调用者的线程ID
```

终止线程

一个线程是以下方式之一来终止的：

- 当顶层的线程例程返回时，线程会隐式的终止。

- 通过调用pthread_exit函数，线程会显示的终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程的整个进程，返回值为pthread_return。

  ```c
  #include <pthread.h>
  void pthread_exit(void *pthread_return);
  //从不返回
  ```

- 某个对等线程调用Linux的exit函数，该函数终止进程以及所有与该进程相关的线程。

- 另一个对等线程通过以当前线程的ID作为参数调用pthread_cancel函数来终止当前线程。

  ```c
  #include <pthread.h>
  void pthread_cancel(pthread_t tid);
  //若成功返回0 若出错则返回非0
  ```



将变量映射到内存

多线程的C程序中变量根据它们的储存类型被映射到虚拟内存

- 全局变量 ：定义在函数之外的变量。在运行时，虚拟内存的读写区域只包含每个全局变量的一个实例，任何线程都可以引用。
- 本地自动变量：定义在函数内部但是没有static属性的变量
- 本地静态变量：定义在函数内部并且有static属性的变量



使用线程提高并行性

并发和并行程序之间的集合关系

![image-20200620210930778](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz289y2ugj30me0dkqcu.jpg)

线程安全

线程不安全函数类：

1. 不保护共享变量的函数
2. 保持多个跨越调用的状态的函数
3. 返回指向静态变量的指针的函数
4. 调用线程不安全函数的函数



可重入性

有一类重要的线程安全函数，叫做可重入函数。其特点在于他们拥有这样一种属性，当他们被多个线程调用时，不会引起任何共享数据。尽管线程安全和可重入有时会（不正确地）被用作同义词，但是它们之间还是有清晰的技术差别。![image-20200620211602983](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2f2vgsij30mw0dun9g.jpg)

可重入函数通常比不可重入的线程安全的函数高效一些。

常见的线程不安全的库函数

![image-20200620211935040](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2iqt00cj310m0fik2o.jpg)



死锁

信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁，它指的是一组线程被阻塞了，等待一个永远也不会为真的条件。![image-20200620212137487](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz2kwfkkoj31100s0e35.jpg)

程序猿使用P和V操作顺序不当，以至于两个信号量的禁止区域重叠，如果某个执行轨迹线碰巧到达了死锁状态d，那么久不可能有进一步的进展了，因为重叠禁止区域阻塞了每个合法方向上的进展。

重叠的禁止区域引起了一组称为死锁区域的状态。如果一个轨迹线碰巧到达了一个死锁区域中的状态，那么死锁就是不可避免的了。轨迹线可以进入死锁区域，但是它们不能离开。

死锁是相当困难的一个问题，因为他总是不可预测的。



**互斥锁加锁顺序规则**：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

![image-20200620213637816](https://tva1.sinaimg.cn/large/007S8ZIlgy1gfz30hkht0j30ye0nqarx.jpg)





#### 总结

##### 今天是第三周计算机这本书只能说是快速刷了一遍，大体了解了讲了哪些内容，看到之后有印象，并没有过多深入的了解。记下了一些概念性的东西，自己基础太差导致看起来很费劲，路哥说的要掌握的章节实际上也只过了一边并没有真的掌握，因为如果要掌握去看的话可能会很花时间，暂时的计划是快速过一遍有整体印象，在通过路哥课上讲解然后自己再去理解一下，还有代码性的东西我觉得还是得多写，因为读书过程中并没有真的去写多少代码，这个目前有很欠缺。总体来说收获也有很多，以前是0现在最起码不是空白了，继续努力。