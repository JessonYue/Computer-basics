## 											第三章 进程（后半部分）

### 进程切换

为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。

### 硬件上下文

硬件上下文是进程可执行上下文的一个自己，因为可执行上下文包含进程执行是需要的所有信息，在 Linux 中，进程硬件上下文的一部分存放在 TSS 段，而剩余部分存放在内核态堆栈中。

进程切换只发生在内核态。在执行进程切换之前，用户态进程使用的所有寄存器内容都已保存在内核态堆栈上，这也包括ss 和 esp 这对寄存器的内容。

### 任务状态段

80x86 体系结构一个特殊类型的段类型，叫任务状态段（Task State Segment ，TSS）来存放硬件上下文。

当进程在用户态下执行 in 或 out 指令时，控制单元执行下列操作：

1、检查 eflags 寄存器中的2位 IOPL 字段。如果该字段值为3，控制单元就执行 I/O 指令。否则，执行下一个检测。

2、访问 tr 寄存器以确定当前 TSS 和相应的 I/O 许可权位图。

3、检查 I/O 指令中否定的 I/O 端口在 I/O 许可权位图中对应的为。如果该位清零，这条 I/O 指令就执行，否则控制单元产生一个 “General protection” 异常。

每个TSS 有自己8自己的任务状态描述段（Task State Segment Descriptor ，TSSD）。

这个描述符包括指向 TSS 起始地址的 32 位 Base 字段， 20 位 Limit 字段。

每个 CPU 的 tr 寄存器包含相应 TSS 的 TSSD 选择符，也包含了两个隐藏的非编程字段：TSSD 的 Base 字段 和 Limit 字段。这样处理器就能直接对 TSS 寻址而不用从 GDT 中检索 TSS 的地址。

### 执行进程切换

进程切换可能只发生在精心定义的点：schedule（）函数。

每个进程切换有两步组成：

1、切换页全局目录以安装一个新的地址空间

2、切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含 CPU 寄存器。

### clone（）、fork（）及vfork（）系统调用

轻量级进程是有名为 clone（） 的函数创建：

fn：制定一个有新进程执行的函数。当这个函数返回时，子进程终止。

arg： 指向传递给 fn（）函数的数据。

flags： 各种各样的信息。低字节指定子进程结束时发送到父进程的信号代码，通常选择 SIGCHLD 信号。

child_stack：表示把用户态堆栈指针赋给子进程的 esp 寄存器。

tls：表示线程局部存储段（TLS）数据结构的地址，该结构是为轻量级进程定义的。

ptid：表示父进程的用户态变量地址，该父进程具有与新轻量级进程相同的PID。

ctid ：表示新轻量级进程的用户态变量地址，该进程具有这一类进程的 PID。

![image-20200711234239038](/Users/liuchang/Library/Application Support/typora-user-images/image-20200711234239038.png)

![image-20200711234255595](/Users/liuchang/Library/Application Support/typora-user-images/image-20200711234255595.png)

传统的 fork（） 系统调用在 Linux中是用 clone（）实现的，其中 clone（） 的 flags 参数指定为SIGCHLD 信号及所有清零的 clone 标志，而它的 child_stack 参数是父进程当前的堆栈指针。



