## 										第五章 内核同步

### 优化和内存屏障

优化屏蔽 原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言指令，这些汇编语言指令在 C 中都有对应的语句。

优化屏蔽就是 barrier（）宏，它展开为 asm volatile（"":::"memory"）。

volatile 关键字禁止编译器吧 asm 指令与程序中的其他指令重新组合。

![image-20200719234735922](/Users/liuchang/Library/Application Support/typora-user-images/image-20200719234735922.png)

### 自旋锁

一种广泛应用的同步技术是加锁。当内核控制路径必须访问共享数据结构或进入临界区市，就需要为自己获取一把“锁”。

自旋锁是用来在多处理器环境中工作的一种特殊的锁。

自旋锁的循环指令表示“忙等”。

在单处理系统上，这种锁本身并不起锁的左右，自旋锁原语仅仅是禁止或启用内核抢占。

每个自旋锁都用 spinlock_t 结构表示：

slock：表示自旋锁状态：值为 1 表示“未加锁”状态，而任何负数和0都表示“加锁”状态。

break_lock：表示进程正在忙等自旋锁。

![image-20200721121321890](/Users/liuchang/Library/Application Support/typora-user-images/image-20200721121321890.png)

### 读/写自旋锁

读/写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径对数据结构进行修改，读/写自旋锁就允许多个内核控制路径同时读同一个数据结构。

每个读/写自旋锁都是一个 rwlock_t 结构，其 lock 字段是一个 32 位的字段，分为连个不同的部分：

1、24位计数器，表示对受保护的数据结构并发的进行读操作的内核控制路径数目。

2、“未锁”标志字段，当没有内核控制路径在读或写时设置该位，否则清零。

### 顺序锁

顺序锁只是为写者赋予了较高的优先级，即使读者在读的时候也允许写者继续运行。这种策略的好处写者永远不会等待，缺点是有些时候读者不得不反复多次读相同的数据知道他获得有效的副本。

每个读者都必须在读数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器吗，因此暗示读者刚读到数据是无效的。

顺序锁使用条件：

1、被保护的数据结构不搞扩被写者修改和被读者间接引用的指针。

2、读者的临界区代码没有副作用。

### 读-拷贝-更新（RCU）

限制RCP 的范围：

1、RCU 只保护被动态分配并通过指针引用的数据结构。

2、在被 RCU 保护的临界区中，任何内核控制路径都不能睡眠。





















